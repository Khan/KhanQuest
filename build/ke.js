(function () {/**
 * almond 0.2.6 Copyright (c) 2011-2012, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/almond for details
 */
//Going sloppy to avoid 'use strict' string cost, but strict practices should
//be followed.
/*jslint sloppy: true */
/*global setTimeout: false */

var requirejs, require, define;
(function (undef) {
    var main, req, makeMap, handlers,
        defined = {},
        waiting = {},
        config = {},
        defining = {},
        hasOwn = Object.prototype.hasOwnProperty,
        aps = [].slice;

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    /**
     * Given a relative module name, like ./something, normalize it to
     * a real name that can be mapped to a path.
     * @param {String} name the relative name
     * @param {String} baseName a real name that the name arg is relative
     * to.
     * @returns {String} normalized name
     */
    function normalize(name, baseName) {
        var nameParts, nameSegment, mapValue, foundMap,
            foundI, foundStarMap, starI, i, j, part,
            baseParts = baseName && baseName.split("/"),
            map = config.map,
            starMap = (map && map['*']) || {};

        //Adjust any relative paths.
        if (name && name.charAt(0) === ".") {
            //If have a base name, try to normalize against it,
            //otherwise, assume it is a top-level require that will
            //be relative to baseUrl in the end.
            if (baseName) {
                //Convert baseName to array, and lop off the last part,
                //so that . matches that "directory" and not name of the baseName's
                //module. For instance, baseName of "one/two/three", maps to
                //"one/two/three.js", but we want the directory, "one/two" for
                //this normalization.
                baseParts = baseParts.slice(0, baseParts.length - 1);

                name = baseParts.concat(name.split("/"));

                //start trimDots
                for (i = 0; i < name.length; i += 1) {
                    part = name[i];
                    if (part === ".") {
                        name.splice(i, 1);
                        i -= 1;
                    } else if (part === "..") {
                        if (i === 1 && (name[2] === '..' || name[0] === '..')) {
                            //End of the line. Keep at least one non-dot
                            //path segment at the front so it can be mapped
                            //correctly to disk. Otherwise, there is likely
                            //no path mapping for a path starting with '..'.
                            //This can still fail, but catches the most reasonable
                            //uses of ..
                            break;
                        } else if (i > 0) {
                            name.splice(i - 1, 2);
                            i -= 2;
                        }
                    }
                }
                //end trimDots

                name = name.join("/");
            } else if (name.indexOf('./') === 0) {
                // No baseName, so this is ID is resolved relative
                // to baseUrl, pull off the leading dot.
                name = name.substring(2);
            }
        }

        //Apply map config if available.
        if ((baseParts || starMap) && map) {
            nameParts = name.split('/');

            for (i = nameParts.length; i > 0; i -= 1) {
                nameSegment = nameParts.slice(0, i).join("/");

                if (baseParts) {
                    //Find the longest baseName segment match in the config.
                    //So, do joins on the biggest to smallest lengths of baseParts.
                    for (j = baseParts.length; j > 0; j -= 1) {
                        mapValue = map[baseParts.slice(0, j).join('/')];

                        //baseName segment has  config, find if it has one for
                        //this name.
                        if (mapValue) {
                            mapValue = mapValue[nameSegment];
                            if (mapValue) {
                                //Match, update name to the new value.
                                foundMap = mapValue;
                                foundI = i;
                                break;
                            }
                        }
                    }
                }

                if (foundMap) {
                    break;
                }

                //Check for a star map match, but just hold on to it,
                //if there is a shorter segment match later in a matching
                //config, then favor over this star map.
                if (!foundStarMap && starMap && starMap[nameSegment]) {
                    foundStarMap = starMap[nameSegment];
                    starI = i;
                }
            }

            if (!foundMap && foundStarMap) {
                foundMap = foundStarMap;
                foundI = starI;
            }

            if (foundMap) {
                nameParts.splice(0, foundI, foundMap);
                name = nameParts.join('/');
            }
        }

        return name;
    }

    function makeRequire(relName, forceSync) {
        return function () {
            //A version of a require function that passes a moduleName
            //value for items that may need to
            //look up paths relative to the moduleName
            return req.apply(undef, aps.call(arguments, 0).concat([relName, forceSync]));
        };
    }

    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(depName) {
        return function (value) {
            defined[depName] = value;
        };
    }

    function callDep(name) {
        if (hasProp(waiting, name)) {
            var args = waiting[name];
            delete waiting[name];
            defining[name] = true;
            main.apply(undef, args);
        }

        if (!hasProp(defined, name) && !hasProp(defining, name)) {
            throw new Error('No ' + name);
        }
        return defined[name];
    }

    //Turns a plugin!resource to [plugin, resource]
    //with the plugin being undefined if the name
    //did not have a plugin prefix.
    function splitPrefix(name) {
        var prefix,
            index = name ? name.indexOf('!') : -1;
        if (index > -1) {
            prefix = name.substring(0, index);
            name = name.substring(index + 1, name.length);
        }
        return [prefix, name];
    }

    /**
     * Makes a name map, normalizing the name, and using a plugin
     * for normalization if necessary. Grabs a ref to plugin
     * too, as an optimization.
     */
    makeMap = function (name, relName) {
        var plugin,
            parts = splitPrefix(name),
            prefix = parts[0];

        name = parts[1];

        if (prefix) {
            prefix = normalize(prefix, relName);
            plugin = callDep(prefix);
        }

        //Normalize according
        if (prefix) {
            if (plugin && plugin.normalize) {
                name = plugin.normalize(name, makeNormalize(relName));
            } else {
                name = normalize(name, relName);
            }
        } else {
            name = normalize(name, relName);
            parts = splitPrefix(name);
            prefix = parts[0];
            name = parts[1];
            if (prefix) {
                plugin = callDep(prefix);
            }
        }

        //Using ridiculous property names for space reasons
        return {
            f: prefix ? prefix + '!' + name : name, //fullName
            n: name,
            pr: prefix,
            p: plugin
        };
    };

    function makeConfig(name) {
        return function () {
            return (config && config.config && config.config[name]) || {};
        };
    }

    handlers = {
        require: function (name) {
            return makeRequire(name);
        },
        exports: function (name) {
            var e = defined[name];
            if (typeof e !== 'undefined') {
                return e;
            } else {
                return (defined[name] = {});
            }
        },
        module: function (name) {
            return {
                id: name,
                uri: '',
                exports: defined[name],
                config: makeConfig(name)
            };
        }
    };

    main = function (name, deps, callback, relName) {
        var cjsModule, depName, ret, map, i,
            args = [],
            usingExports;

        //Use name if no relName
        relName = relName || name;

        //Call the callback to define the module, if necessary.
        if (typeof callback === 'function') {

            //Pull out the defined dependencies and pass the ordered
            //values to the callback.
            //Default to [require, exports, module] if no deps
            deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;
            for (i = 0; i < deps.length; i += 1) {
                map = makeMap(deps[i], relName);
                depName = map.f;

                //Fast path CommonJS standard dependencies.
                if (depName === "require") {
                    args[i] = handlers.require(name);
                } else if (depName === "exports") {
                    //CommonJS module spec 1.1
                    args[i] = handlers.exports(name);
                    usingExports = true;
                } else if (depName === "module") {
                    //CommonJS module spec 1.1
                    cjsModule = args[i] = handlers.module(name);
                } else if (hasProp(defined, depName) ||
                           hasProp(waiting, depName) ||
                           hasProp(defining, depName)) {
                    args[i] = callDep(depName);
                } else if (map.p) {
                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});
                    args[i] = defined[depName];
                } else {
                    throw new Error(name + ' missing ' + depName);
                }
            }

            ret = callback.apply(defined[name], args);

            if (name) {
                //If setting exports via "module" is in play,
                //favor that over return value and exports. After that,
                //favor a non-undefined return value over exports use.
                if (cjsModule && cjsModule.exports !== undef &&
                        cjsModule.exports !== defined[name]) {
                    defined[name] = cjsModule.exports;
                } else if (ret !== undef || !usingExports) {
                    //Use the return value from the function.
                    defined[name] = ret;
                }
            }
        } else if (name) {
            //May just be an object definition for the module. Only
            //worry about defining if have a module name.
            defined[name] = callback;
        }
    };

    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {
        if (typeof deps === "string") {
            if (handlers[deps]) {
                //callback in this case is really relName
                return handlers[deps](callback);
            }
            //Just return the module wanted. In this scenario, the
            //deps arg is the module name, and second arg (if passed)
            //is just the relName.
            //Normalize module name, if it contains . or ..
            return callDep(makeMap(deps, callback).f);
        } else if (!deps.splice) {
            //deps is a config object, not an array.
            config = deps;
            if (callback.splice) {
                //callback is an array, which means it is a dependency list.
                //Adjust args if there are dependencies
                deps = callback;
                callback = relName;
                relName = null;
            } else {
                deps = undef;
            }
        }

        //Support require(['a'])
        callback = callback || function () {};

        //If relName is a function, it is an errback handler,
        //so remove it.
        if (typeof relName === 'function') {
            relName = forceSync;
            forceSync = alt;
        }

        //Simulate async callback;
        if (forceSync) {
            main(undef, deps, callback, relName);
        } else {
            //Using a non-zero value because of concern for what old browsers
            //do, and latest browsers "upgrade" to 4 if lower value is used:
            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:
            //If want a value immediately, use require('id') instead -- something
            //that works in almond on the global level, but not guaranteed and
            //unlikely to work in other AMD implementations.
            setTimeout(function () {
                main(undef, deps, callback, relName);
            }, 4);
        }

        return req;
    };

    /**
     * Just drops the config on the floor, but returns req in case
     * the config return value is used.
     */
    req.config = function (cfg) {
        config = cfg;
        if (config.deps) {
            req(config.deps, config.callback);
        }
        return req;
    };

    /**
     * Expose module registry for debugging and tooling
     */
    requirejs._defined = defined;

    define = function (name, deps, callback) {

        //This module may not have dependencies
        if (!deps.splice) {
            //deps is not an array, so probably means
            //an object literal or factory function for
            //the value. Adjust args.
            callback = deps;
            deps = [];
        }

        if (!hasProp(defined, name) && !hasProp(waiting, name)) {
            waiting[name] = [name, deps, callback];
        }
    };

    define.amd = {
        jQuery: true
    };
}());

define("third_party/almond.js", function(){});

define('utils/crc32.js',['require'],function(require) {

/*
===============================================================================
Crc32 is a JavaScript function for computing the CRC32 of a string
...............................................................................

Version: 1.2 - 2006/11 - http://noteslog.com/category/javascript/

-------------------------------------------------------------------------------
Copyright (c) 2006 Andrea Ercolino
http://www.opensource.org/licenses/mit-license.php
===============================================================================
*/

// CRC32 Lookup Table
var table = "00000000 77073096 EE0E612C 990951BA 076DC419 706AF48F E963A535 " +
            "9E6495A3 0EDB8832 79DCB8A4 E0D5E91E 97D2D988 09B64C2B 7EB17CBD " +
            "E7B82D07 90BF1D91 1DB71064 6AB020F2 F3B97148 84BE41DE 1ADAD47D " +
            "6DDDE4EB F4D4B551 83D385C7 136C9856 646BA8C0 FD62F97A 8A65C9EC " +
            "14015C4F 63066CD9 FA0F3D63 8D080DF5 3B6E20C8 4C69105E D56041E4 " +
            "A2677172 3C03E4D1 4B04D447 D20D85FD A50AB56B 35B5A8FA 42B2986C " +
            "DBBBC9D6 ACBCF940 32D86CE3 45DF5C75 DCD60DCF ABD13D59 26D930AC " +
            "51DE003A C8D75180 BFD06116 21B4F4B5 56B3C423 CFBA9599 B8BDA50F " +
            "2802B89E 5F058808 C60CD9B2 B10BE924 2F6F7C87 58684C11 C1611DAB " +
            "B6662D3D 76DC4190 01DB7106 98D220BC EFD5102A 71B18589 06B6B51F " +
            "9FBFE4A5 E8B8D433 7807C9A2 0F00F934 9609A88E E10E9818 7F6A0DBB " +
            "086D3D2D 91646C97 E6635C01 6B6B51F4 1C6C6162 856530D8 F262004E " +
            "6C0695ED 1B01A57B 8208F4C1 F50FC457 65B0D9C6 12B7E950 8BBEB8EA " +
            "FCB9887C 62DD1DDF 15DA2D49 8CD37CF3 FBD44C65 4DB26158 3AB551CE " +
            "A3BC0074 D4BB30E2 4ADFA541 3DD895D7 A4D1C46D D3D6F4FB 4369E96A " +
            "346ED9FC AD678846 DA60B8D0 44042D73 33031DE5 AA0A4C5F DD0D7CC9 " +
            "5005713C 270241AA BE0B1010 C90C2086 5768B525 206F85B3 B966D409 " +
            "CE61E49F 5EDEF90E 29D9C998 B0D09822 C7D7A8B4 59B33D17 2EB40D81 " +
            "B7BD5C3B C0BA6CAD EDB88320 9ABFB3B6 03B6E20C 74B1D29A EAD54739 " +
            "9DD277AF 04DB2615 73DC1683 E3630B12 94643B84 0D6D6A3E 7A6A5AA8 " +
            "E40ECF0B 9309FF9D 0A00AE27 7D079EB1 F00F9344 8708A3D2 1E01F268 " +
            "6906C2FE F762575D 806567CB 196C3671 6E6B06E7 FED41B76 89D32BE0 " +
            "10DA7A5A 67DD4ACC F9B9DF6F 8EBEEFF9 17B7BE43 60B08ED5 D6D6A3E8 " +
            "A1D1937E 38D8C2C4 4FDFF252 D1BB67F1 A6BC5767 3FB506DD 48B2364B " +
            "D80D2BDA AF0A1B4C 36034AF6 41047A60 DF60EFC3 A867DF55 316E8EEF " +
            "4669BE79 CB61B38C BC66831A 256FD2A0 5268E236 CC0C7795 BB0B4703 " +
            "220216B9 5505262F C5BA3BBE B2BD0B28 2BB45A92 5CB36A04 C2D7FFA7 " +
            "B5D0CF31 2CD99E8B 5BDEAE1D 9B64C2B0 EC63F226 756AA39C 026D930A " +
            "9C0906A9 EB0E363F 72076785 05005713 95BF4A82 E2B87A14 7BB12BAE " +
            "0CB61B38 92D28E9B E5D5BE0D 7CDCEFB7 0BDBDF21 86D3D2D4 F1D4E242 " +
            "68DDB3F8 1FDA836E 81BE16CD F6B9265B 6FB077E1 18B74777 88085AE6 " +
            "FF0F6A70 66063BCA 11010B5C 8F659EFF F862AE69 616BFFD3 166CCF45 " +
            "A00AE278 D70DD2EE 4E048354 3903B3C2 A7672661 D06016F7 4969474D " +
            "3E6E77DB AED16A4A D9D65ADC 40DF0B66 37D83BF0 A9BCAE53 DEBB9EC5 " +
            "47B2CF7F 30B5FFE9 BDBDF21C CABAC28A 53B39330 24B4A3A6 BAD03605 " +
            "CDD70693 54DE5729 23D967BF B3667A2E C4614AB8 5D681B02 2A6F2B94 " +
            "B40BBE37 C30C8EA1 5A05DF1B 2D02EF8D";

/* Number */
var crc32 = function(str, crc) {
    if (crc == null) {
        crc = 0;
    }
    var n = 0; //a number between 0 and 255
    var x = 0; //a hex number

    crc = crc ^ (-1);
    for (var i = 0, iTop = str.length; i < iTop; i++) {
        n = (crc ^ str.charCodeAt(i)) & 0xFF;
        x = "0x" + table.substr(n * 9, 8);
        crc = (crc >>> 8) ^ x;
    }
    return Math.abs(crc ^ (-1));
};

return crc32;

});

/* khan-exercise.js

    The main entry point here is essentially the onjQueryLoaded method around
    line 750. It loads in many of the pre-reqs and then calls, one way or
    another, setUserExercise and loadModule for each required module in utils/.

    setProblemNum updates some instance vars that get looked at by other
    functions.

    loadModule will load an individual exercise util module (e.g.,
    word-problems.js, etc). It _also_ loads in the Khan Academy site skin and
    exercise template via injectSite which runs prepareSite first then
    makeProblem when it finishes loading dependencies.

    prepareSite and makeProblem are both fairly heavyweight functions.

    If you are trying to register some behavior when the page loads, you
    probably want it to go in either prepareSite here or, if it makes sense, in
    problemTemplateRendered in interface.js. By the time prepareSite is called,
    jQuery and any core plugins are already available.

    If you are trying to do something each time a problem loads, you probably
    want to look at makeProblem.

    At the end of evaluation, the inner Khan object is returned/exposed as well
    as the inner Util object.


    Catalog of events fired on the Khan object by khan-exercises:

    * newProblem -- when a new problem has completely finished rendering

    * hintUsed -- when a hint has been used by the user

    * checkAnswer -- when the user attempts to check an answer, incorrect or
      correct

    * problemDone -- when the user has completed a problem which, in this case,
      usually means supplying the correct answer. Note the user may have made
      multiple attempts to finally get at the correct answer. A summary object
      including {attempts: <number>, card: <Object>} is included as an
      event parameter.

    * attemptError -- when an error occurs during an API attempt

    * apiRequestStarted / apiRequestEnded -- when an API request is sent
      outbound or completed, respectively. Listeners can keep track of whether
      or not khan-exercises is still waiting on API responses.

    * updateUserExercise -- when an updated userExercise has been received
      and is being used by khan-exercises, either via the result of an API
      call or initialization

    * showGuess -- when a guess is populated in the answer area in problem
      history mode

    * attemptMessageShown -- when a user attempts a problem and a message is
      shown in response, e.g. "We don't understand your answer."
*/
define('khan-exercise.js',['require','./utils/crc32.js'],function(require) {

var crc32 = require("./utils/crc32.js");

// Numbers which are coprime to the number of bins, used for jumping through
// exercises.  To quickly test a number in python use code like:
// import fractions
// fractions.gcd( 197, 200)
var primes = [197, 3, 193, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43,
47, 53, 59, 61, 67, 71, 73, 79, 83],

    userExercise,

    // Check to see if we're in local mode
    localMode = typeof Exercises === "undefined",

    // Set in prepareSite when Exercises.init() has already been called
    assessmentMode,

    // The ID, filename, and name of the exercise -- these will only be set here in localMode
    currentExerciseId = ((/([^\/.]+)(?:\.html)?$/.exec(window.location.pathname) || [])[1]) || "",
    currentExerciseFile = currentExerciseId + ".html",
    currentExerciseName = deslugify(currentExerciseId),

    // Bin users into a certain number of realms so that
    // there is some level of reproducability in their questions.
    // If you change this, make sure all entries in the array "primes"
    // set above are coprime to the new value.
    bins = 200,

    // Number of past problems to consider when avoiding duplicates
    dupWindowSize = 5,

    // The seed information
    randomSeed,

    // Holds the current username
    user = null,
    userCRC32,

    // The current problem and its corresponding exercise
    problem,    // the unprocessed contents of a specific problem type
    exercise,   // the unprocessed contents of all problem types and vars

    // The number of the current problem that we're on
    problemNum = 1,

    // Info for constructing the seed
    seedOffset = 0,
    jumpNum = 1,
    currentProblemSeed = 0,
    seedsSkipped = 0,
    consecutiveSkips = 0,

    currentProblemType,

    // The current validator function
    answerData,
    validator,
    getAnswer,

    hints,

    // The exercise elements
    exercises,

    hintsUsed,

    // Bug-hunting "undefined" attempt content
    debugLogLog = ["start of log"],
    debugLog = function(l) {
        debugLogLog.push(l);
    },

    // Dictionary of loading and loaded exercises; keys are exercise IDs,
    // values are promises that are resolved when the exercise is loaded
    exerciseFilePromises = {},

    // A promise for each loaded or loading module, keyed by module filename
    // (module.src) -- will be resolved when the module is loaded (on the live
    // site, immediately)
    modulePromises = {},
    initialModulesPromise = $.Deferred(),

    urlBase = localMode ?  "../" :
        Exercises.khanExercisesUrlBase != null ?
            Exercises.khanExercisesUrlBase :
            "/khan-exercises/",

    // In local mode, we use khan-exercises local copy of the /images
    // directory.  But in production (on www.khanacademy.org), we use
    // the canonical location of images, which is under '/'.
    imageBase = localMode ? urlBase + "images/" : "/images/",

    lastFocusedSolutionInput = null,

    // Keeps track of failures in MakeProblem so we don't endlessly try and
    // re-Make a bad problem
    failureRetryCount = 0,

    // The ul#examples (keep in a global because we need to modify it even when it's out of the DOM)
    examples = null;

// Add in the site stylesheets
if (localMode) {
    (function() {
        var addLink = function(url) {
            var link = document.createElement("link");
            link.rel = "stylesheet";
            link.href = urlBase + url;
            document.getElementsByTagName("head")[0].appendChild(link);
        };

        addLink("css/khan-site.css");
        addLink("css/khan-exercise.css");
        addLink("local-only/katex/katex.css");
        addLink("local-only/katex/fonts/fonts.css");
    })();
}

// The main Khan Module
var Khan = {

    // Set of modules currently in use -- keys are module names, value is
    // always true
    modules: {},

    // Map from exercise ID to a list of required modules (data-require),
    // These module names are used in resetModules() and indirectly by
    // runModules(), where $.fn["module-name"], $.fn["module-nameLoad"],
    // and $.fn["module-nameCleanup"] are called.
    exerciseModulesMap: {},

    // So modules can use file paths properly
    urlBase: urlBase,

    imageBase: imageBase,

    // Inter-util dependencies. This map is currently necessary so that we
    // can expose only the appropriate $.fn["module-nameLoad"] hooks used
    // by each problem. Dependencies on third-party files need not be
    // listed here.
    // TODO(alpert): Now that these deps are now encoded in require()
    // lines, find a way to remove this map.
    moduleDependencies: {
        "math": ["knumber"],
        "exponents": ["math", "math-format"],
        "kinematics": ["math"],
        "math-format": ["math", "expressions"],
        "polynomials": ["math", "expressions"],
        "stat": ["math"],
        "word-problems": ["math"],
        "interactive": ["graphie", "knumber", "kvector", "kpoint", "kline"],
        "mean-and-median": ["stat"],
        "congruency": ["angles", "interactive", "graphie-helpers"],
        "graphie": ["kpoint"],
        "graphie-3d": ["graphie", "kmatrix", "kvector"],
        "graphie-geometry": ["graphie", "kmatrix", "kvector", "kline"],
        "graphie-helpers": ["math-format"],
        "kmatrix": ["expressions"],
        "chemistry": ["math-format"],
        "kvector": ["knumber"],
        "kpoint": ["kvector", "knumber"],
        "kray": ["kpoint", "kvector"],
        "kline": ["kpoint", "kvector"],
        "constructions": ["kmatrix"]
    },

    warnTimeout: function() {
        $(Exercises).trigger("warning", [$._("Your internet might be too " +
                "slow to see an exercise. Refresh the page or " +
                "<a href='' id='warn-report'>report a problem</a>."),
                false]);
        // TODO(alpert): This event binding is kind of gross
        $("#warn-report").click(function(e) {
            e.preventDefault();
            $("#report").click();
        });
    },

    warnFont: function() {
        var warning;
        if ($.browser.msie) {
            warning = $._("You should " +
                "<a href='http://missmarcialee.com/2011/08/" +
                "how-to-enable-font-download-in-internet-explorer-8/' " +
                "target='_blank'>enable font download</a> " +
                "to improve the appearance of math expressions."
            );
        } else {
            warning = $._("You should enable font download in your " +
                "browser to improve the appearance of math expressions");
        }

        $(Exercises).trigger("warning", [warning, true]);
    },

    // TODO(alpert): This doesn't need to be in the Khan object.
    getBaseModules: function() {
        var mods = [];
        // Base modules required for every problem.  These are specified
        // as filenames (minus the .js extension) relative to util/.
        // subhints is here to support the intervention experiment.
        mods.push(
            "answer-types", "tmpl", "tex", "jquery.adhesion",
            "scratchpad", "subhints");

        return mods;
    },

    resetModules: function(exerciseId) {
        var modules = Khan.getBaseModules().concat(
                Khan.exerciseModulesMap[exerciseId]);
        var moduleSet = {};

        $.each(modules, function(i, mod) {
            useModule(mod);
        });

        Khan.modules = moduleSet;

        function useModule(modNameOrObject) {
            if (typeof modNameOrObject === "string") {
                moduleSet[modNameOrObject] = true;
                var deps = Khan.moduleDependencies[modNameOrObject] || [];

                $.each(deps, function(i, mod) {
                    useModule(mod);
                });
            } else if (modNameOrObject.name) {
                moduleSet[modNameOrObject.name] = true;
            }
        }
    },

    loadLocalModeSiteWhenReady: function() {
        initialModulesPromise.then(function() {
            loadLocalModeSite();
        });
    },

    // Populate this with modules
    Util: {
        debugLog: debugLog,

        // http://burtleburtle.net/bob/hash/integer.html
        // This is also used as a PRNG in the V8 benchmark suite
        random: function() {
            // Robert Jenkins' 32 bit integer hash function.
            var seed = randomSeed;
            seed = ((seed + 0x7ed55d16) + (seed << 12)) & 0xffffffff;
            seed = ((seed ^ 0xc761c23c) ^ (seed >>> 19)) & 0xffffffff;
            seed = ((seed + 0x165667b1) + (seed << 5)) & 0xffffffff;
            seed = ((seed + 0xd3a2646c) ^ (seed << 9)) & 0xffffffff;
            seed = ((seed + 0xfd7046c5) + (seed << 3)) & 0xffffffff;
            seed = ((seed ^ 0xb55a4f09) ^ (seed >>> 16)) & 0xffffffff;
            return (randomSeed = (seed & 0xfffffff)) / 0x10000000;
        },

        // Rounds num to X places, and uses the proper decimal seperator.
        // But does *not* insert thousands separators.
        localeToFixed: function(num, places) {
            var localeDecimalSeperator = icu.getDecimalFormatSymbols().decimal_separator;
            var localeFixed = num.toFixed(places).replace(".", localeDecimalSeperator);
            if (localeFixed === "-0") {
                localeFixed = "0";
            }
            return localeFixed;
        }
    },

    // Query String Parser
    // Original from:
    // http://stackoverflow.com/questions/901115/get-querystring-values-in-javascript/2880929#2880929
    queryString: function() {
        var urlParams = {},
            e,
            a = /\+/g,  // Regex for replacing addition symbol with a space
            r = /([^&=]+)=?([^&]*)/g,
            d = function(s) { return decodeURIComponent(s.replace(a, " ")); },
            q = window.location.search.substring(1);

        while ((e = r.exec(q))) {
            urlParams[d(e[1])] = d(e[2]);
        }

        return urlParams;
    },

    // Display error messages
    error: function() {
        if (typeof console !== "undefined") {
            $.each(arguments, function(ix, arg) {
                debugLog("error: " + arg);
                console.error(arg);
            });
        }
    },

    scratchpad: (function() {
        var disabled = false, wasVisible, pad;

        var actions = {
            disable: function() {
                wasVisible = actions.isVisible();
                actions.hide();

                $("#scratchpad-show").hide();
                $("#scratchpad-not-available").show();
                disabled = true;
            },

            enable: function() {
                if (wasVisible) {
                    actions.show();
                    wasVisible = false;
                }

                $("#scratchpad-show").show();
                $("#scratchpad-not-available").hide();
                disabled = false;
            },

            isVisible: function() {
                return $("#scratchpad").is(":visible");
            },

            show: function() {

                if (actions.isVisible()) {
                    return;
                }

                var makeVisible = function() {
                    if (!$("#scratchpad").length) {
                        // Scratchpad's gone! The exercise template
                        // probably isn't on screen right now, so let's
                        // just not try and initialize stuff otherwise
                        // Raphael will attach an <svg> to the body.
                        return;
                    }

                    $("#scratchpad").show();
                    $("#scratchpad-show").text($._("Hide scratchpad"));

                    // If pad has never been created or if it's empty
                    // because it was removed from the DOM, recreate a new
                    // scratchpad.
                    if (!pad || !$("#scratchpad div").children().length) {
                        pad = new DrawingScratchpad(
                            $("#scratchpad div")[0]);
                    }

                    // Outline things floating on top of the scratchpad
                    $(".above-scratchpad").css("border", "1px solid #ccc");
                };

                makeVisible();
            },

            hide: function() {
                if (!actions.isVisible()) {
                    return;
                }

                $("#scratchpad").hide();
                // Un-outline things floating on top of the scratchpad
                $(".above-scratchpad").css("border", "");
                $("#scratchpad-show").text($._("Show scratchpad"));
            },

            toggle: function() {
                actions.isVisible() ? actions.hide() : actions.show();
            },

            clear: function() {
                if (pad) {
                    pad.clear();
                }
            },

            resize: function() {
                if (pad) {
                    pad.resize();
                }
            }
        };

        return actions;
    })(),

    getSeedInfo: function() {
        return {
            // A hash representing the exercise version
            sha1: typeof userExercise !== "undefined" ?
                    userExercise.exerciseModel.sha1 : currentExerciseId,
            seed: currentProblemSeed,
            problem_type: currentProblemType
        };
    },

    getPreviewUrl: function() {
        return window.location.protocol + "//" + window.location.host +
            "/preview/content/e/" + currentExerciseId + "?seed=" +
            currentProblemSeed + "&problem=" + currentProblemType;
    },

    getIssueInfo: function() {
        return {
            framework: "khan-exercises",
            pretitle: currentExerciseName,
            exercise: currentExerciseId,
            item: currentProblemType + "/" + currentProblemSeed,
            sha: userExercise.exerciseModel.sha1,
            previewUrl: "http://sandcastle.kasandbox.org/media/castles/Khan:master/exercises/" +
                    currentExerciseFile + "?seed=" + currentProblemSeed + "&problem=" +
                    currentProblemType + "&debug&lang=" + icu.getLocale(),
            editUrl: "http://exercises.ka.local/exercises/" +
                    currentExerciseFile + "?seed=" + currentProblemSeed + "&problem=" +
                    currentProblemType + "&debug",
            bodyInfo: JSON.stringify(Exercises.guessLog)
        };
    },

    scoreInput: function() {
        return validator(getAnswer());
    },

    submitIssue: function(issueInfo, onSuccess, onFailure) {
        var dataObj = {
            fields: {
                project: { key: "AI" },
                issuetype: { name: "Item issue report" },
                summary: issueInfo.pretitle + " - " + issueInfo.title,
                description: issueInfo.bodyInfo,
                customfield_10024: [issueInfo.exercise],  // exercise
                customfield_10026: issueInfo.sha,         // sha
                customfield_10027: issueInfo.previewUrl,  // preview url
                customfield_10028: issueInfo.editUrl,     // edit url
                customfield_10025: [issueInfo.item],      // item
                customfield_10029: { value: issueInfo.framework },  // framework
                customfield_10202: issueInfo.debugInfo,   // debug info
                customfield_10204: issueInfo.userFlags,   // User Type
                customfield_10205: navigator.userAgent,   // user agent
                customfield_10300: { value: issueInfo.type || "Other" },  // issue type
                customfield_10301: [icu.getLocale()]      // locale
            }
        };

        $.ajax({
            url: "/jirapost",
            type: "POST",
            data: JSON.stringify(dataObj),
            contentType: "application/json",
            dataType: "json",
            success: onSuccess,
            error: onFailure
        });
    },

    autoSubmitIssue: function(title, description) {
        // Capture a stack trace for easier debugging. Safari requires an
        // exception to be thrown in order for .stack to be set
        var err;
        try {
            throw new Error();
        } catch (e) {
            err = e;
        }
        description += "\n\n" + err.stack;

        var framework = Exercises.getCurrentFramework();
        var issueInfo = framework === "khan-exercises" ?
            Khan.getIssueInfo() :
            Exercises.PerseusBridge.getIssueInfo();
        $.extend(issueInfo, {
            pretitle: "AutoGenerated",
            title: title,
            bodyInfo: description,
            type: "Other",
            userFlags: [{ value: "Auto-generated by a robot" }],
            debugInfo: description + "\n\n" +
                JSON.stringify(Khan.getSeedInfo()) +
                "\n\n" + debugLogLog.join("\n")
        });

        Khan.submitIssue(issueInfo);
    },

    /**
     * Hijacks a specified link so that it opens up the issue form.
     * @param {string} selector The link selector - defaults to "#report"
     */
    initReportIssueLink: function(selector) {
        selector = selector || "#report";
        $(selector).click(function(e) {
            e.preventDefault();

            if (typeof KA !== "undefined" && KA.vipIssueReporter) {
                $("#issue .info-box-header").text($._("VIP Issue Report"));
            }

            // If the hint button isn't visible, we don't want the user to
            // see hints for some reason (e.g., this is an assessment).
            // So also hide the show answer button.
            if (!$("#hint").is(':visible')) {
                $("#issue-show-answer").hide();
            }

            var report = $("#issue").css("display") !== "none";
            var form = $("#issue .issue-form").css("display") !== "none";

            if (report && form) {
                $("#issue").hide();
            } else if (!report || !form) {
                $("#issue-status").removeClass("error").hide();
                $("#issue, #issue .issue-form").show();
                $("html, body").animate({
                    scrollTop: $("#issue").offset().top
                }, 500, function() {
                    $("#issue-title").focus();
                });
            }
        });

        $("input[name=issue-type]").on("click", function() {
            if ($(this).prop("id") === "issue-hints-wrong") {
                $("#issue-body").prop("placeholder", $._("Tell us exactly " +
                        "what's wrong with the hints. What answer did " +
                        "you get and how did you get it?"));
            } else if ($(this).prop("id") === "issue-answer-wrong") {
                $("#issue-body").prop("placeholder", $._("Tell us exactly " +
                        "how you tried to input the answer from the " +
                        "hints. Did a different answer work instead?"));
            } else if ($(this).prop("id") === "issue-confusing") {
                $("#issue-body").prop("placeholder", $._("Tell us exactly " +
                        "what you found confusing. How would you reword " +
                        "the question or hints to be less confusing?"));
            } else {
                $("#issue-body").prop("placeholder", "");
            }
        });

        // Hide "Question or hints are in English" option for english users
        if (icu.getLanguage() === "en") {
            $("#issue-i18n").parent().hide();
        }

        // Hide issue form.
        $("#issue-cancel").click(function(e) {
            e.preventDefault();

            $("#issue").hide(500);
            $("#issue-title, #issue-body").val("");
        });

        $("#issue-show-answer").click(function(e) {
            e.preventDefault();
            while (hints.length > 0) {
                $("#hint").click();
            }
            $(this).addClass("disabled");
        });
        $(Exercises).bind("newProblem", function() {
            $("#issue-show-answer").removeClass("disabled");
        });

        // Submit an issue.
        $("#issue .issue-form input:submit").click(function(e) {

            e.preventDefault();

            var framework = Exercises.getCurrentFramework();
            var issueInfo = framework === "khan-exercises" ?
                Khan.getIssueInfo() :
                Exercises.PerseusBridge.getIssueInfo();

            // don't do anything if the user clicked a second time quickly
            if ($("#issue .issue-form").css("display") === "none") {
                return;
            }

            // Validate body
            var body = $("#issue-body").val();
            if (body === "") {
                $("#issue-status").addClass("error")
                    .html($._("Please provide a description of the issue.")).show();
                return;
            }
            issueInfo.bodyInfo = body + "\n\n" + issueInfo.bodyInfo;

            // Title is first 50 characters of description
            issueInfo.title = body.substr(0, 50).replace(/\n/g, " ") +
                    (body.length > 50 ? "..." : "");

            // Validate type
            var type = $("input[name=issue-type]:checked").prop("id");
            if (!type) {
                $("#issue-status").addClass("error")
                    .html($._("Please specify the issue type.")).show();
                return;
            }

            issueInfo.type = {
                "issue-hints-wrong": "Answer in hints is wrong",
                "issue-answer-wrong": "Answer in hints not accepted",
                "issue-confusing": "Question or hints confusing",
                "issue-i18n": "Not translated"
            }[type];


            // Construct debug info
            var mathjaxInfo = "MathJax is " + (typeof MathJax === "undefined" ? "NOT loaded" :
                    ("loaded, " + (MathJax.isReady ? "" : "NOT ") + "ready, queue length: " +
                    MathJax.Hub.queue.queue.length));
            var sessionStorageInfo = (typeof sessionStorage === "undefined" ||
                    typeof sessionStorage.getItem === "undefined" ?
                    "sessionStorage NOT enabled" : null);
            var warningInfo = $("#warning-bar-content").text();
            var parts = [sessionStorageInfo, mathjaxInfo, warningInfo];
            var debugInfo = $.grep(parts, function(e) { return e != null; }).join("\n\n");
            var mathjaxLoadFailures = $.map(MathJax.Ajax.loading, function(info, script) {
                if (info.status === -1) {
                    return [script + ": error"];
                } else {
                    return [];
                }
            }).join("\n");
            if (mathjaxLoadFailures.length > 0) {
                debugInfo += "\n\n" + mathjaxLoadFailures;
            }
            issueInfo.debugInfo += "\n\n" + debugLogLog.join("\n");


            // Flag special users
            var profile = typeof KA !== "undefined" && KA.getUserProfile();
            var powerUser = profile && profile.get("points") >= 500000;
            var vip = typeof KA !== "undefined" && KA.vipIssueReporter;
            issueInfo.userFlags = [];
            if (powerUser) {
                issueInfo.userFlags.push({ value: "500k+ points" });
            }
            if (vip) {
                issueInfo.userFlags.push({ value: "VIP" });
                if (profile) {
                    issueInfo.bodyInfo = "VIP issue from " +
                            profile.get("nickname") + " (" +
                            profile.get("email") + ")\n\n" +
                            issueInfo.bodyInfo;
                }
            }

            var formElements = $("#issue input").add("#issue textarea");

            // disable the form elements while waiting for a server response
            formElements.attr("disabled", true);
            $("#issue-cancel").hide();
            $("#issue-throbber").show();

            var onSuccess = function(data) {
                // hide the form
                $("#issue-throbber").hide();
                $("#issue .issue-form").hide();

                var bugid = data.key;
                // VIPs get a link to the issue
                if (vip) {
                    bugid = "<a href='https://khanacademy.atlassian.net/browse/" +
                            data.key + "'>" + data.key + "</a>";
                }

                // show status message
                $("#issue-status").removeClass("error")
                    .html($._("<p>Thank you for your feedback! " +
                        "Issue <b>%(bugid)s</b> has been opened and " +
                        "we'll look into it shortly.</p>",
                        {bugid: bugid}))
                    .show();

                // reset the form elements
                formElements.attr("disabled", false)
                    .not("input:submit").val("");

                // replace throbber with the cancel button
                $("#issue-cancel").show();
                $("#issue-throbber").hide();
            };

            var onFailure = function() {
                // show status message
                $("#issue-status").addClass("error")
                    .html($._("Communication with issue tracker isn't " +
                        "working. Please file the issue manually at " +
                        "<a href='http://github.com/Khan/khan-exercises/issues/new'>GitHub</a>. " +
                        "Please reference item: <b>%(item)s</b>.",
                        {item: issueInfo.exercise + "/" + issueInfo.item}))
                    .show();

                // enable the inputs
                formElements.attr("disabled", false);

                // replace throbber with the cancel button
                $("#issue-cancel").show();
                $("#issue-throbber").hide();
            };

            $.post("/api/v1/bigbingo/mark_conversions", {
                conversion_ids: "exercise_submit_issue"
            });

            Khan.submitIssue(issueInfo, onSuccess, onFailure);
        });
    },

    cleanupProblem: function() {
        $("#workarea, #hintsarea").runModules(problem, "Cleanup");
    }
};
// see line 178. this ends the main Khan module

// Load query string params
Khan.query = Khan.queryString();

if (Khan.query.activity !== undefined) {
    userExercise = {
        current: true,
        exerciseModel: {},
        readOnly: true,
        userActivity: JSON.parse(Khan.query.activity)
    };
}

// Seed the random number generator with the user's hash
if (localMode && Khan.query.seed) {
    randomSeed = parseFloat(Khan.query.seed);
} else {
    randomSeed = userCRC32 || (new Date().getTime() & 0xffffffff);
}

if (localMode) {
    // Load in jQuery and underscore, as well as the interface glue code
    // TODO(cbhl): Don't load history.js if we aren't in readOnly mode.
    require([
        "./exercises-stub.js",
        "./history.js",
        "./interface.js",
        "./related-videos.js"
    ], function() {
        onjQueryLoaded();
    });
} else {
    onjQueryLoaded();
}

function onjQueryLoaded() {
    initEvents();

    // Initialize to an empty jQuery set
    exercises = $();

    Khan.mathJaxLoaded = loadMathJax();

    $(function() {
        var promises = [];

        // Load all base modules, and if this is local mode, any specified
        // in the data-require on <html>
        var mods = Khan.getBaseModules();
        if (localMode) {
            var modString = document.documentElement.getAttribute(
                    "data-require") || "";
            var exMods = modString.length ? modString.split(" ") : [];

            Khan.exerciseModulesMap[currentExerciseId] = exMods;
            mods.push.apply(mods, exMods);
        }

        $.each(mods, function(i, mod) {
            promises.push(loadModule(mod));
        });

        promises.push(Khan.mathJaxLoaded);

        // Ensure that all local exercises get tagged with the exercise ID
        $("div.exercise").data("name", currentExerciseId);

        $.when.apply($, promises).then(function() {
            // All modules have now been loaded
            initialModulesPromise.resolve();
        });
    });

    $.fn.extend({
        // Run the methods provided by a module against some elements
        runModules: function(problem, type) {
            type = type || "";

            var info = {
                localMode: localMode,
                exerciseId: currentExerciseId
            };

            this.each(function(i, elem) {
                elem = $(elem);

                // Run the main method of any modules
                $.each(Khan.modules, function(mod) {
                    if ($.fn[mod + type]) {
                        elem[mod + type](problem, info);
                    }
                });
            });
            return this;
        }
    });
}

function loadAndRenderExercise(nextUserExercise) {
    debugLog("loadAndRenderExercise(" + (nextUserExercise && nextUserExercise.exercise) + ")");

    setUserExercise(nextUserExercise);

    var typeOverride = userExercise.problemType,
        seedOverride = userExercise.seed;

    var exerciseId = userExercise.exerciseModel.name,
        exerciseFile = userExercise.exerciseModel.fileName;

    function finishRender() {
        // Get all problems of this exercise type...
        var problems = exercises.filter(function() {
            return $.data(this, "name") === exerciseId;
        }).children(".problems").children();

        // Make scratchpad persistent per-user
        if (user && window.LocalStore) {
            var lastScratchpad = LocalStore.get("scratchpad:" + user);
            if (typeof lastScratchpad !== "undefined" && JSON.parse(lastScratchpad)) {
                Khan.scratchpad.show();
            }
        }

        $(Exercises).trigger("clearExistingProblem");

        // Generate a new problem
        makeProblem(exerciseId, typeOverride, seedOverride);
    }

    debugLog("loading and rendering " + exerciseId);
    loadExercise(exerciseId, exerciseFile).then(
        function() {
            debugLog("loaded " + exerciseId + ", now rendering");
            finishRender();
        });
}

/**
 * Returns whether we should skip the current problem because it's
 * a duplicate (or too similar) to a recently done problem in the same
 * exercise.
 */
function shouldSkipProblem() {
    // We don't need to skip duplicate problems in test mode, which allows
    // us to use the LocalStore localStorage abstraction from shared-package
    if (typeof LocalStore === "undefined") {
        return false;
    }

    var cacheKey = "prevProblems:" + user + ":" + currentExerciseName;
    var cached = LocalStore.get(cacheKey);
    var lastProblemNum = (cached && cached["lastProblemNum"]) || 0;

    if (lastProblemNum === problemNum) {
        // Getting here means the user refreshed the page or returned to
        // this exercise after being away. So, we don't need to and
        // shouldn't skip this problem.
        return false;
    }

    var pastHashes = (cached && cached["history"]) || [];
    var varsHash = $.tmpl.getVarsHash();

    // Should skip the current problem if we've already seen it in the past
    // few problems, but not if we've been fruitlessly skipping for a while.
    // The latter situation could happen if a problem has very few unique
    // problems (eg. exterior angles problem type of angles_of_a_polygon).
    if (_.contains(pastHashes, varsHash) && consecutiveSkips < dupWindowSize) {
        consecutiveSkips++;
        return true;
    } else {
        consecutiveSkips = 0;
        pastHashes.push(varsHash);
        while (pastHashes.length > dupWindowSize) {
            pastHashes.shift();
        }

        if (LocalStore.isEnabled()) {
            LocalStore.set(cacheKey, {
                lastProblemNum: problemNum,
                history: pastHashes
            });
        }
        return false;
    }
}


function checkIfAnswerEmpty(guess) {
    // If multiple-answer, join all responses and check if that's empty
    // Remove commas left by joining nested arrays in case multiple-answer is nested
    return $.trim(guess) === "" || (guess instanceof Array &&
             $.trim(guess.join("").replace(/,/g, "")) === "");
}

function makeProblem(exerciseId, typeOverride, seedOverride) {
    debugLog("makeProblem(" + exerciseId + ", " + typeOverride + ", " + seedOverride + ")");

    Khan.scratchpad.enable();

    // Allow passing in an arbitrary seed
    if (typeof seedOverride !== "undefined") {
        currentProblemSeed = seedOverride;

    // If no user, just pick a random seed
    } else if (user == null) {
        currentProblemSeed = Math.abs(randomSeed % bins);
    }
    debugLog("  using seed " + currentProblemSeed + " for " + exerciseId);

    // Set randomSeed to what currentProblemSeed is (save currentProblemSeed for recall later)
    randomSeed = currentProblemSeed;

    // Check to see if we want to test a specific problem
    if (localMode) {
        typeOverride = typeof typeOverride !== "undefined" ? typeOverride : Khan.query.problem;
    }

    // problems contains the unprocessed contents of each problem type within exerciseId
    var problems = exercises.filter(function() {
        return $.data(this, "name") === exerciseId;
    }).children(".problems").children();

    if (!problems.length) {
        Khan.error("No problem matching exerciseId " + exerciseId);
    }

    if (typeof typeOverride !== "undefined") {
        problem = /^\d+$/.test(typeOverride) ?
            // Access a problem by number
            problems.eq(parseFloat(typeOverride)) :

            // Or by its ID
            problems.filter("#" + typeOverride);

        currentProblemType = typeOverride;

    // Otherwise create a random problem from weights
    } else {
        var typeIndex = [];
        $.each(problems, function(index) {
            if ($(this).data("weight") === 0) { return; }
            var weight = $(this).data("weight") || 1;
            _.times(weight, function(){ typeIndex.push(index); });
        });
        var typeNum = typeIndex[Math.floor(Math.random() * typeIndex.length)];
        problem = problems.eq(typeNum);
        currentProblemType = $(problem).attr("id") || "" + typeNum;
    }

    // TODO(brianmerlob): If we still don't have a problem then it's time to fail as gracefully
    // as we can. This probably occurs during mastery challenges when some sort of race
    // condition causes the type for one problem to sneak it's way in for another problem
    // and then `problem = problems.eq(type)` returns an empty object (thus length === 0).
    // This should _never_ happen, and hopefully these autoSubmitIssues will help debug.
    if (!problem.length && problems.length) {
        Khan.autoSubmitIssue("type was for the incorrect problem; failed gracefully");
        problem = problems.eq(Math.floor(Math.random() * problems.length));
    }

    // Find which exercise this problem is from
    exercise = problem.parents("div.exercise").eq(0);

    debugLog("  chose problem type [" + currentProblemType + "] and seed [" + currentProblemSeed + "] for " + exerciseId);

    // Work with a clone to avoid modifying the original
    problem = problem.clone();

    debugLog("cloned problem");

    // problem has to be child of visible #workarea for MathJax metrics to all work right
    $("#workarea").append(problem);

    // If there's an original problem, add inherited elements
    var parentType = problem.data("type");

    while (parentType) {
        // Copy over the parent element to the child
        var original = exercise.find(".problems #" + parentType).clone();
        problem.prepend(original.children().data("inherited", true));

        // Keep copying over the parent elements (allowing for deep inheritance)
        parentType = original.data("type");
    }

    // Add any global exercise defined elements
    problem.prepend(exercise.children(":not(.problems)").clone().data("inherited", true));

    debugLog("cloned global elements");

    // Apply templating
    var children = problem
        // var blocks append their contents to the parent
        .find(".vars").tmplApply({attribute: "class", defaultApply: "appendVars"}).end()

        // Individual variables override other variables with the same name
        .find(".vars [id]").tmplApply().end()

        // We also look at the main blocks within the problem itself to override,
        // ignoring graphie and spin blocks
        .children("[class][class!='graphie'][class!='spin']").tmplApply({attribute: "class"});

    debugLog("ran tmplApply to vars and main elements");

    // Finally we do any inheritance to the individual child blocks (such as problem, question, etc.)
    children.each(function() {
        // Apply while adding problem.children() to include
        // template definitions within problem scope
        $(this).find("[id]").add(children).tmplApply();
    });

    debugLog("ran tmplApply to [id]");

    // Remove and store hints to delay running modules on it
    hints = problem.children(".hints").remove();

    // Only show the calculator if it's specifically allowed for this problem
    if (problem.data("calculator") == null) {
        $("#calculator").hide();
    } else {
        $("#calculator").show();
    }

    debugLog("removed hints from DOM");

    // Evaluate any inline script tags in this exercise's source
    $.each(exercise.data("script") || [], function(i, scriptContents) {
        $.globalEval(scriptContents);
    });

    debugLog("evaled inline scripts");

    // ...and inline style tags.
    if (exercise.data("style")) {
        var exerciseStyleElem = $("#exercise-inline-style");

        // Clear old exercise style definitions
        if (exerciseStyleElem.length && exerciseStyleElem[0].styleSheet) {
            // IE refuses to modify the contents of <style> the normal way
            exerciseStyleElem[0].styleSheet.cssText = "";
        } else {
            exerciseStyleElem.empty();
        }

        // Then add rules specific to this exercise.
        $.each(exercise.data("style"), function(i, styleContents) {
            if (exerciseStyleElem.length && exerciseStyleElem[0].styleSheet) {
                // IE refuses to modify the contents of <style> the normal way
                exerciseStyleElem[0].styleSheet.cssText = exerciseStyleElem[0].styleSheet.cssText + styleContents;
            } else {
                exerciseStyleElem.append(styleContents);
            }
        });
    }

    debugLog("added inline styles");

    // Reset modules to only those required by the current exercise
    Khan.resetModules(exerciseId);

    // Run the main method of any modules
    problem.runModules(problem, "Load");
    debugLog("done with runModules Load");
    problem.runModules(problem);
    debugLog("done with runModules");

    if (typeof seedOverride === "undefined" && shouldSkipProblem()) {
        // If this is a duplicate problem we should skip, just generate
        // another problem of the same problem type but w/ a different seed.
        debugLog("duplicate problem!");
        $(Exercises).trigger("clearExistingProblem");
        nextSeed(1);
        return makeProblem(exerciseId);
    }

    // Store the solution to the problem
    var solution = problem.find(".solution"),

        // Get the multiple choice problems
        choices = problem.find(".choices"),

        // Get the area into which solutions will be inserted,
        // Removing any previous answer
        solutionarea = $("#solutionarea").empty(),

        // See if we're looking for a specific style of answer
        answerType = solution.data("type");

    // Make sure that the answer type exists
    if (answerType) {
        if (Khan.answerTypes && !Khan.answerTypes[answerType]) {
            Khan.error("Unknown answer type specified: " + answerType);
            return;
        }
    }

    if (!answerType) {
        // If a multiple choice block exists
        if (choices.length) {
            answerType = "radio";

        // Otherwise we assume the smart number type
        } else {
            answerType = "number";
        }
    }

    // Generate a type of problem
    // (this includes possibly generating the multiple choice problems,
    // if this fails then we will need to try generating another one.)
    debugLog("decided on answer type " + answerType);
    answerData = Khan.answerTypes[answerType].setup(solutionarea, solution);

    validator = answerData.validator;
    getAnswer = answerData.answer;
    debugLog("validator created");

    // A working solution was generated
    if (validator) {
        // Have MathJax redo the font metrics for the solution area
        // (ugh, this is gross)
        KhanUtil.processAllMath($("#solutionarea")[0], true);

        // Focus the first input
        // Use .select() and on a delay to make IE happy
        var firstInput = solutionarea.find(":input").first();
        if ($(".calculator input:visible").length) {
            firstInput = $(".calculator input");
        }

        setTimeout(function() {
            if (!firstInput.is(":disabled")) {
                firstInput.focus();
                if (firstInput.is("input:text")) {
                    firstInput.select();
                }
            }
        }, 1);

        lastFocusedSolutionInput = firstInput;
        solutionarea.find(":input").focus(function() {
            // Save which input is focused so we can refocus it after the user hits Check Answer
            lastFocusedSolutionInput = this;
        });
    } else {
        // Making the problem failed, let's try again (up to 3 times)
        debugLog("validator was falsey");
        problem.remove();
        if (failureRetryCount < 100) {
            failureRetryCount++;
            // If this seed didn't work for some reason, just try the next
            // seed for the same problem type. This probably happens because:
            //
            // 1)  Something with a multiple-choice answer requires, say 4
            //     choices, but this seed was only able to generate three
            //     choices.
            // 1a) A multiple choice question doesn't require a specific number
            //     of choices and therefore requires all choices to be shown,
            //     but there were duplicates among the generate choices leading
            //     to fewer than all of them able to be shown, so we give up
            //     and have to try with a different seed.
            //
            // TODO(eater): Handle this case better. Since this leads to
            // potentially duplicate problems (e.g., when seed 10, 11, and 12
            // all fall back to seed 12), users see less variety.
            var newSeed = (currentProblemSeed + 1) % bins;

            makeProblem(exerciseId, typeOverride, newSeed);
        } else {
            debugLog("Failed making problem too many times");
            Khan.error("Failed while attempting to MakeProblem too many " +
                "times in a row");
        }
        return;
    }

    // Remove the solution and choices elements from the display
    // Some exercises (e.g., parabola_intuition_3) break if we don't remove
    // so always do it unless ?noremovesolution is explicitly passed
    if (localMode && Khan.query.noremovesolution != null) {
        solution.hide();
        choices.hide();
    } else {
        solution.remove();
        choices.remove();
    }

    // Add the problem into the page
    Khan.scratchpad.resize();

    // Enable the all answer input elements except the check answer button.
    $("#answercontent input")
        .not("#check-answer-button, #show-prereqs-button")
        .prop("disabled", false);

    // Show acceptable formats
    if (examples !== null && answerData.examples && answerData.examples.length > 0) {
        $("#examples-show").show();
        examples.empty();

        $.each(answerData.examples, function(i, example) {
            examples.append("<li>" + example + "</li>");
        });

        if ($("#examples-show").data("qtip")) {
            $("#examples-show").qtip("destroy", /* immediate */ true);
        }

        $("#examples-show").qtip({
            content: {
                text: examples.remove(),
                prerender: true
            },
            style: {classes: "qtip-light leaf-tooltip"},
            position: {
                my: "center right",
                at: "center left"
            },
            show: {
                delay: 200,
                effect: {
                    length: 0
                }
            },
            hide: {delay: 0},
            events: {
                render: function() {
                    // Only run the modules when the qtip is actually shown
                    examples.children().runModules();
                }
            }
        });
    } else {
        $("#examples-show").hide();
    }
    // save a normal JS array of hints so we can shift() through them later
    hints = hints.tmpl().children().get();

    // Hook out for exercise test runner
    if (localMode && parent !== window && typeof parent.jQuery !== "undefined") {
        parent.jQuery(parent.document).trigger("problemLoaded", [makeProblem, answerData.solution]);
    }

    $("#hint").val($._("I'd like a hint"));

    $(Exercises).trigger("newProblem", {
        numHints: hints.length,
        userExercise: userExercise,
        answerData: answerData,
        answerType: answerType,
        solution: solution,
        hints: hints,
        problem: problem
    });

    hintsUsed = userExercise ? userExercise.lastCountHints : 0;

    // The server says the user has taken hints on this problem already
    // show all lastCountHints it says we have seen
    _(hintsUsed).times(showHint);

    // Add autocomplete="off" attribute so IE doesn't try to display previous answers
    $("#problem-and-answer").find("input[type='text'], input[type='number']")
                            .attr("autocomplete", "off");

    // If the textbox is empty disable "Check Answer" button
    // Note: We don't do this for multiple choice, number line, etc.
    if (answerType === "text" || answerType === "number") {
        var checkAnswerButton = $("#check-answer-button");
        var skipQuestionButton = $("#skip-question-button");
        checkAnswerButton.attr("disabled", "disabled").attr(
            "title", $._("Type in an answer first."));
        // Enables the check answer button - added so that people who type
        // in a number and hit enter quickly do not have to wait for the
        // button to be enabled by the key up
        $("#solutionarea")
            .on("keypress.emptyAnswer", function(e) {
                if (e.keyCode !== 13) {
                    checkAnswerButton.prop("disabled", false)
                        .removeAttr("title");
                }
            })
            .on("keyup.emptyAnswer", function(e) {
                var guess = getAnswer();
                if (checkIfAnswerEmpty(guess)) {
                    skipQuestionButton.prop("disabled", false);
                    checkAnswerButton.prop("disabled", true);
                } else if (e.keyCode !== 13) {
                    // Enable check answer button again as long as it is
                    // not the enter key
                    checkAnswerButton.prop("disabled", false);
                    skipQuestionButton.prop("disabled", true);
                }
            });

    }

    return answerType;
}

function showHint() {
    debugLog("showHint()");
    // Called when user hits hint button triggering showHint event or when
    // the server side data says the last_count_hints is not 0 when
    // exercise is loaded.
    var hint = hints.shift();
    if (!hint) {
        // :(
        return;
    }

    hintsUsed++;

    var problem = $(hint).parent();

    // Append first so MathJax can sense the surrounding CSS context properly
    $(hint).appendTo("#hintsarea").runModules(problem);

    if (hints.length === 0) {
        $(hint).addClass("last-hint");
    }

    // TODO(james): figure out a way to trigger hintUsed to ensure that the
    // cards are updated properly, but make sure the ajax calls to
    // submit the hints are not resubmited for the case where we are
    // calling this function because last_count_hints was not 0
}

function renderDebugInfo() {
    debugLog("renderDebugInfo()");
    // triggered on newProblem

    if (userExercise == null || Khan.query.debug != null) {
        $("#problem-permalink").text("Permalink: " +
                                     currentProblemType + " #" +
                                     currentProblemSeed)
            .attr("href", window.location.protocol + "//" + window.location.host + window.location.pathname + "?debug&problem=" + currentProblemType + "&seed=" + currentProblemSeed);
    }

    // Show the debug info
    if (localMode && Khan.query.debug != null) {
        $(document).keypress(function(e) {
            if (e.charCode === 104) {
                $("#hint").click();
            }
        });
        var debugWrap = $("#debug").css({"margin-right": "15px"}).empty();
        var debugURL = window.location.protocol + "//" + window.location.host + window.location.pathname +
            "?debug&problem=" + currentProblemType;

        $("<h3>Debug Info</h3>").appendTo(debugWrap);

        var src = exercise.data("src");
        if (src != null) {
            var srcInfo = $("<p>").appendTo(debugWrap);
            srcInfo.append("From ");

            $("<a>")
                .text(src)
                .attr("href", src + "?debug")
                .appendTo(srcInfo);
        }

        var links = $("<p>").appendTo(debugWrap);

        if (!Khan.query.activity) {
            var historyURL = debugURL + "&seed=" + currentProblemSeed + "&activity=";
            $("<a>Problem history</a>").attr("href", "javascript:").click(function() {
                window.location.href = historyURL + encodeURIComponent(
                        JSON.stringify(Exercises.userActivityLog));
            }).appendTo(links);
        } else {
            $("<a>Random problem</a>")
                .attr("href", window.location.protocol + "//" +
                        window.location.host + window.location.pathname +
                        "?debug")
                .appendTo(links);
        }

        links.append("<br><b>Problem types:</b><br>");

        exercises.children(".problems").children().each(function(n, prob) {
            var probID = $(prob).attr("id") || "" + n;
            links.append($("<div>")
                .css({
                    "padding-left": "20px",
                    "outline":
                        (currentProblemType === probID) ?
                        "1px dashed gray" : ""
                })
                .append($("<span>").text(n + ": "))
                .append($("<a>")
                    .text(probID)
                    .attr("href", window.location.protocol + "//" +
                        window.location.host + window.location.pathname +
                        "?debug&problem=" + probID)
                ));
        });


        // If this is a child exercise, show which one it came from
        if (exercise.data("name") !== currentExerciseId) {
            links.append("<br>");
            links.append("Original exercise: " + exercise.data("name"));
        }

        if ($.tmpl.DATA_ENSURE_LOOPS > 0) {
            var dataEnsureInfo = $("<p>");
            dataEnsureInfo.append("Data-ensure loops: " + $.tmpl.DATA_ENSURE_LOOPS);
            if ($.tmpl.DATA_ENSURE_LOOPS > 15) {
                dataEnsureInfo.css("background-color", "yellow");
            }
            if ($.tmpl.DATA_ENSURE_LOOPS > 30) {
                dataEnsureInfo.css("background-color", "orange");
            }
            if ($.tmpl.DATA_ENSURE_LOOPS > 50) {
                dataEnsureInfo.css("background-color", "red");
            }
            dataEnsureInfo.appendTo(debugWrap);
        }

        if (typeof $.tmpl.VARS !== "undefined") {
            var varInfo = $("<p>");

            $.each($.tmpl.VARS, function(name, value) {
                var str;

                if (typeof value === "function") {
                    str = value.toString();
                } else {
                    // JSON is prettier (when it works)
                    try {
                        str = JSON.stringify(value);
                    } catch (e) {
                        str = value.toString();
                    }
                }

                varInfo.append($("<b>").text(name));
                varInfo.append(": ");
                varInfo.append($("<var>").text(str));
                varInfo.append("<br>");
            });

            varInfo.appendTo(debugWrap);
        }

        // for special style rules

        $("body").addClass("debug");
    }
}

function renderExerciseBrowserPreview() {
    debugLog("renderExerciseBrowserPreview()");
    // triggered on newProblem

    // Version of the site used by Khan/exercise-browser for the iframe
    // preview
    if (localMode && Khan.query.browse != null) {
        $("html").addClass("exercise-browser");

        var browseWrap = $("#browse").empty();

        var links = $("<div>").addClass("problem-types");

        links.append($("<b>").text("Problem types:"));

        exercises.children(".problems").children().each(function(n, prob) {
            var probName = $(prob).attr("id");
            var probID = probName || n;
            var weight = $(prob).data("weight");
            weight = weight != null ? weight : 1;

            if (weight !== 0) {
                $("<a>").addClass("problem-type-link")
                    .text("#" + (n + 1) +
                        (probName != null ? ": " + probName : ""))
                    .attr("href", window.location.protocol + "//" +
                        window.location.host + window.location.pathname +
                        "?browse&problem=" + probID)
                    .appendTo(links);
            }
        });

        browseWrap.append(links);
    }
}

function renderNextProblem(data) {
    if (localMode) {
        // Just generate a new problem from existing exercise
        $(Exercises).trigger("clearExistingProblem");
        makeProblem(currentExerciseId);
    } else {
        loadAndRenderExercise(data.userExercise);
    }
}

/**
 * Called once each time an exercise page is initialized.
 * For multi-exercise pages, this can be called multiple times!
 * (e.g. in a tutorial view, where there is client side navigation between
 * different exercises).
 */
function prepareSite() {
    debugLog("prepareSite()");
    // Grab example answer format container
    examples = $("#examples");

    assessmentMode = !localMode && Exercises.assessmentMode;
    function initializeCalculator() {
        var ansChars = ["+", "-", "/", "*", "^", " "];
        var calculator = $(".calculator"),
            history = calculator.children(".history"),
            output = $("#calc-output-content"),
            outputContainer = $("#calc-output"),
            inputRow = history.children(".calc-row.input"),
            input = inputRow.children("input"),
            buttons = calculator.find("a"),
            previousInstrs = [],
            currentInstrIndex = -1,
            lastInstr = "",
            ans = 0,
            prevAnswer,
            containsAns = false,
            separator = icu.getDecimalFormatSymbols().decimal_separator;

        var formatInputHistory = function(text) {
            return text.replace(/pi/g, "\u03c0") + " =";
        };

        var appendDiv = function(div) {
            output.append(div);
            output.scrollTop(output[0].scrollHeight);
        };

        var insertPrevAnswer = function() {
            var outdiv;
            if (prevAnswer !== undefined) {
                outdiv = $("<div>").addClass("output").text(prevAnswer);
                prevAnswer = undefined;
                appendDiv(outdiv);
            }
        };

        var evaluate = function() {
            var instr = input.val();
            var indiv, output, outstr;
            var isError = false;
            var newInputVal = instr;
            if ($.trim(instr) !== "") {
                lastInstr = instr;
                previousInstrs.unshift(instr);
                indiv = $("<div>").addClass("input-history")
                                  .text(formatInputHistory(instr));
                try {
                    if (separator !== ".") {
                        // i18nize the input numbers' decimal point
                        instr = instr.split(separator).join(".");
                    }
                    output = ans = Calculator.calculate(instr, ans);
                    if (typeof output === "number") {
                        outstr = Math.round(output * 1000000000) / 1000000000;
                        if (separator !== ".") {
                            // i18nize the output number's decimal point
                            outstr = ("" + outstr).replace(".", separator);
                        }
                    } else {
                        outstr = output;
                    }
                    newInputVal = outstr;
                } catch (e) {
                    if (e instanceof Calculator.CalculatorError) {
                        outstr = e.message;
                        newInputVal = instr;
                        isError = true;
                        containsAns = false;
                        input.css({
                            backgroundColor: "#ffcccc"
                        });
                        return;
                    } else {
                        throw e;
                    }
                }
                insertPrevAnswer();
                appendDiv(indiv);
                prevAnswer = outstr;
                // errors should appear immediately
                if (isError) {
                    insertPrevAnswer();
                }
            }

            containsAns = true;
            currentInstrIndex = -1;
            input.val(newInputVal);
        };

        var selected = function(text) {
            return "<span class='selected-anglemode'>" + text + "</span>";
        };

        var unselected = function(text) {
            return "<span class='unselected-anglemode'>" + text + "</span>";
        };

        var updateAngleMode = function() {
            // I18N: "DEGrees" calculator button (3 chars or less)
            var deg = $._("DEG");
            // I18N: "RADians" calculator button (3 chars or less)
            var rad = $._("RAD");
            if (Calculator.settings.angleMode === "DEG") {
                $(".calculator-angle-mode").html(unselected(rad) +
                                                 "<br>" +
                                                 selected(deg));
            } else {
                $(".calculator-angle-mode").html(selected(rad) +
                                                 "<br>" +
                                                 unselected(deg));
            }
        };

        // backspace etc isn't caught by keypress...
        var BACKSPACE = 8;
        var LEFT = 37;
        var RIGHT = 39;
        var UP = 38;
        var DOWN = 40;
        var keysToCancel = [LEFT, RIGHT];
        input.on("keydown", function(e) {
            if (_.contains(keysToCancel, e.keyCode)) {
                containsAns = false;
            }
            if (e.which === BACKSPACE) {
                if (containsAns) {
                    input.val("");
                    insertPrevAnswer();
                    return false;
                }
            }

            if (e.which === UP) {
                insertPrevAnswer();
                currentInstrIndex += 1;
                if (currentInstrIndex >= previousInstrs.length) {
                    currentInstrIndex = previousInstrs.length - 1;
                }
                input.val(previousInstrs[currentInstrIndex]);
                return false;
            }
            if (e.which === DOWN) {
                insertPrevAnswer();
                currentInstrIndex -= 1;
                if (currentInstrIndex < -1) {
                    currentInstrIndex = -1;
                }
                input.val(previousInstrs[currentInstrIndex] || ans);
                return false;
            }
        });

        var insertText = function(inputtedChar) {
            var shouldOverwriteAns = !_.contains(ansChars, inputtedChar) &&
                                    containsAns;

            insertPrevAnswer();
            containsAns = false;
            if (shouldOverwriteAns) {
                input.val("");
            }
            input.css({
                backgroundColor: "white"
            });
        };

        history.on("click", function(e) {
            input.focus();
        });

        // The enter handler needs to bind to keypress to prevent the
        // surrounding form submit... (http://stackoverflow.com/a/587575)
        var ENTER = 13;
        var EQUALS = 61;
        input.on("keypress", function(e) {
            if (e.which === ENTER || e.which === EQUALS) {
                evaluate();
                return false;
            }
            insertText(String.fromCharCode(e.charCode));
        });

        input.on("click", function(e) {
            containsAns = false;
        });

        buttons.on("click", function() {
            var jel = $(this),
                behavior = jel.data("behavior");

            if (behavior != null) {
                if (behavior === "bs") {
                    var val = input.val();
                    input.val(val.slice(0, val.length - 1));
                } else if (behavior === "clear") {
                    input.val("");
                    ans = undefined;
                    prevAnswer = undefined;
                    previousInstrs = [];
                    currentInstrIndex = -1;
                    containsAns = false;
                    output.empty();
                } else if (behavior === "angle-mode") {
                    Calculator.settings.angleMode =
                        Calculator.settings.angleMode === "DEG" ?
                        "RAD" : "DEG";
                    if (typeof window.localStorage !== "undefined") {
                        window.localStorage["calculator_settings:" +
                            window.USERNAME] = JSON.stringify(
                            Calculator.settings);
                    }
                    updateAngleMode();
                } else if (behavior === "evaluate") {
                    evaluate();
                }
            } else {
                var text = jel.data("text") || jel.text();
                insertText(text);
                input.val(input.val() + text);
            }

            input.focus();
            return false;
        });

        $(Exercises).on("gotoNextProblem", function() {
            input.val("");
            history.children().not(inputRow).remove();
        });

        updateAngleMode();

        // i18nize the decimal point button
        $(".calculator-decimal").html(separator);
    }

    require(["./genfiles/calculator.js"], initializeCalculator);
    Khan.initReportIssueLink("#extras .report-issue-link");

    $("#answer_area").delegate("input.button, select", "keydown", function(e) {
        // Don't want to go back to exercise dashboard; just do nothing on backspace
        if (e.keyCode === 8) {
            return false;
        }
    });

    // Prepare for the debug info if requested
    if (localMode && Khan.query.debug != null) {
        $('<div id="debug"></div>').appendTo("#answer_area");
    }

    // Likewise, if we're in browse mode, setup for that
    if (localMode && Khan.query.browse != null) {
        $('<div id="browse"></div>').appendTo("#answer_area");
    }

    $(Khan)
        .bind("updateUserExercise", function(ev, data) {
            // TODO(alpert): Why isn't this in setUserExercise?
            // Any time we update userExercise, check if we're
            // setting/switching usernames
            if (data && data.userExercise) {
                user = data.userExercise.user || user;
                userCRC32 = user != null ? crc32(user) : null;
                randomSeed = userCRC32 || randomSeed;
            }
        });

    $(Khan).bind("gotoNextProblem", function() {
        if (localMode) {
            // Automatically advance to the next problem
            nextProblem(1);
            renderNextProblem();
        } else {
            // Just listen for the readyForNextProblem event, which will
            // include an updated userExercise (and thus an updated problem
            // number)
        }
    });
}

function initEvents() {
    // This function gets called as soon as jQuery is loaded -- on the live
    // site, that's immediately upon execution
    $(Khan)
        .bind("problemTemplateRendered", prepareSite)
        .bind("readyForNextProblem", function(ev, data) {
            renderNextProblem(data);
        })
        .bind("upcomingExercise", function(ev, data) {
            var userExercise = data.userExercise;
            loadExercise(
                    userExercise.exercise,
                    userExercise.exerciseModel.fileName);
        })
        .bind("showHint", function() {
            showHint();
            $(Exercises).trigger("hintShown", {
                card: Exercises.currentCard
            });
        })
        .bind("refocusSolutionInput", function() {
            // Refocus text field so user can type a new answer
            if (lastFocusedSolutionInput != null) {
                setTimeout(function() {
                    var focusInput = $(lastFocusedSolutionInput);

                    if (!focusInput.is(":disabled")) {
                        // focus should always work; hopefully select
                        // will work for text fields
                        focusInput.focus();
                        if (focusInput.is("input:text")) {
                            focusInput.select();
                        }
                    }
                }, 1);
            }
        });
    $(Exercises)
        .bind("newProblem", renderDebugInfo)
        .bind("newProblem", renderExerciseBrowserPreview);
}

function deslugify(name) {
    name = name.replace(/_/g, " ");
    return name.charAt(0).toUpperCase() + name.slice(1);
}

function setProblemNum(num) {
    problemNum = num;
    currentProblemSeed = (seedOffset + jumpNum * (problemNum - 1 + seedsSkipped)) % bins;
}

function getSeedsSkippedCacheKey() {
    return "seedsSkipped:" + user + ":" + currentExerciseName;
}

/**
 * Advances the seed (as if the problem number had been advanced) without
 * actually changing the problem number. Caches how many seeds we've skipped
 * so that refreshing does not change the generated problem.
 * @param {number} num Number of times to advance the seed.
 */
function nextSeed(num) {
    seedsSkipped += num;
    if (typeof LocalStore !== "undefined") {
        LocalStore.set(getSeedsSkippedCacheKey(), seedsSkipped);
    }
    setProblemNum(problemNum);
}

function nextProblem(num) {
    setProblemNum(problemNum + num);
}

function setUserExercise(data) {
    userExercise = data;

    if (data && data.exercise) {
        currentExerciseId = data.exercise;
        currentExerciseName = data.exerciseModel.displayName;
        currentExerciseFile = data.exerciseModel.fileName;
    }

    if (user != null) {
        // How far to jump through the problems
        jumpNum = primes[userCRC32 % primes.length];

        // The starting problem of the user
        seedOffset = userCRC32 % bins;

        // The number of seeds that were skipped due to duplicate problems
        seedsSkipped = (typeof LocalStore !== "undefined" &&
            LocalStore.get(getSeedsSkippedCacheKey()) || 0);

        // Advance to the current problem seed
        setProblemNum(userExercise.totalDone + 1);
    }
}

/**
 * Load an exercise and return a promise that is resolved when an exercise
 * is loaded
 *
 * @param {string} exerciseId uniquely identifies exercise (e.g. addition_1)
 * @param {string} fileName identifies the exercise's path
 */
function loadExercise(exerciseId, fileName) {
    var promise = exerciseFilePromises[exerciseId];
    if (promise != null) {
        // Already started (or finished) loading this exercise
        return promise;
    } else {
        promise = exerciseFilePromises[exerciseId] = $.Deferred();
    }

    // Promises for remote exercises contained within this one
    var subpromises = [];

    debugLog("loadExercise start " + fileName);
    // Packing occurs on the server but at the same "exercises/" URL
    $.get(urlBase + "exercises/" + fileName).done(function(data) {
        debugLog("loadExercise got " + fileName);

        // Get rid of any external scripts in data before we shove data
        // into a jQuery object. IE8 will attempt to fetch these external
        // scripts otherwise.
        // See https://github.com/Khan/khan-exercises/issues/10957
        data = data.replace(/<script(\s)+src=([^<])*<\/script>/, "");

        var newContents = $(data).filter(".exercise");

        // ...then save the exercise ID and fileName for later
        newContents.data({
            name: exerciseId,
            fileName: fileName
        });

        // Add the new exercise elements to the exercises DOM set
        exercises = exercises.add(newContents);

        // Extract data-require
        var match = data.match(
                /<html(?:[^>]+)data-require=(['"])((?:(?!\1).)*)\1/);
        var requires;
        if (match != null) {
            requires = match[2].length ? match[2].split(" ") : [];
        } else {
            requires = [];
        }

        $.each(requires.concat(Khan.getBaseModules()), function(i, mod) {
            debugLog("loadExercise submod " + (mod.src || mod));
            subpromises.push(loadModule(mod));
        });

        // Store the module requirements in exerciseModulesMap
        Khan.exerciseModulesMap[exerciseId] = requires;

        // Extract contents from various tags and save them up for parsing
        // when actually showing this particular exercise.
        var tagsToExtract = {
            // TODO(alpert): Do we use title?
            title: /<title>([^<]*(?:(?!<\/title>)<[^<]*)*)<\/title>/gi,

            // Scripts with no src
            script: /<(?:)script\b[^s>]*(?:(?!src=)s[^s>]*)*>([^<]*(?:(?!<\/script>)<[^<]*)*)<\/script>/gi,

            style: /<style[^>]*>([\s\S]*?)<\/style>/gi
        };

        $.each(tagsToExtract, function(tag, regex) {
            var result = [];
            while ((match = regex.exec(data)) != null) {
                result.push(match[1]);
            }

            newContents.data(tag, result);
        });

        // Wait for any modules to load, then resolve the promise
        $.when.apply($, subpromises).then(function() {
            // Success; all modules loaded
            debugLog("loadExercise finish " + fileName);
            promise.resolve();
        }, function() {
            // Failure; some modules failed to load
            // TODO(alpert): Find a useful error message
            debugLog("loadExercise subfail " + fileName);
            promise.reject();
        });
    }).fail(function(xhr, status) {
        debugLog("loadExercise err " + xhr.status + " " + fileName);
        Khan.warnTimeout();
    });

    return promise;
}

function loadModule(moduleName) {
    // Return the promise if it exists already
    var selfPromise = modulePromises[moduleName];
    if (selfPromise) {
        return selfPromise;
    } else {
        selfPromise = $.Deferred();
    }
    debugLog("loadModule mod " + moduleName);

    // Load the module
    require(["./utils/" + moduleName + ".js"], function() {
        selfPromise.resolve();
    });

    modulePromises[moduleName] = selfPromise;
    return selfPromise;
}

// Load a script by URL, then execute callback
function loadScript(url, callback) {
    var head = document.getElementsByTagName("head")[0];

    debugLog("loadScript loading " + url);

    // Adapted from jQuery getScript (ajax/script.js) -- can't use
    // jQuery here because we load jQuery using this routine
    var script = document.createElement("script");
    script.async = "async";
    script.src = url;

    script.onerror = function() {
        // No error in IE, but this is mostly for debugging during
        // development so it's probably okay
        // http://stackoverflow.com/questions/2027849/how-to-trigger-script-onerror-in-internet-explorer
        Khan.error("Error loading script " + script.src);
    };

    script.onload = script.onreadystatechange = function() {
        if (!script.readyState ||
                (/loaded|complete/).test(script.readyState)) {
            debugLog("loadScript loaded " + url);

            // Handle memory leak in IE
            script.onload = script.onreadystatechange = null;

            // Remove the script
            if (script.parentNode) {
                script.parentNode.removeChild(script);
            }

            // Dereference the script
            script = undefined;

            callback();
        }
    };

    head.appendChild(script);
}

function loadMathJax() {
    var deferred = $.Deferred();

    // We don't want to finish until MathJax is done loading all of its
    // dependencies.

    if (window.MathJax) {
        waitForMathJaxReady();
    } else {
        loadScript(urlBase + "third_party/MathJax/2.1/MathJax.js?config=KAthJax-8f02f65cba7722b3e529bd9dfa6ac25d", waitForMathJaxReady);
    }

    function waitForMathJaxReady() {
        MathJax.Hub.Queue(deferred.resolve);
    }

    return deferred.promise();
}

function loadLocalModeSite() {
    // TODO(alpert): Is the DOM really not yet ready?
    $(function() {
        // Inject the site markup
        if (localMode) {
            $.get(urlBase + "exercises/khan-site.html", function(site) {
                $.get(urlBase + "exercises/khan-exercise.html",
                    function(ex) {
                        injectLocalModeSite(site, ex);
                    });
            });
        }
    });
}

function injectLocalModeSite(html, htmlExercise) {
    $("body").prepend(html);
    $("#container .exercises-header h2").append(document.title);
    $("#container .exercises-body .current-card-contents").html(
            htmlExercise);

    if (Khan.query.layout === "lite") {
        $("html").addClass("lite");
    }

    $(Exercises).trigger("problemTemplateRendered");

    exercises = exercises.add($("div.exercise").detach());
    var problems = exercises.children(".problems").children();

    // Generate the initial problem when dependencies are done being loaded
    makeProblem(currentExerciseId);
}

// Make these publicly accessible
window.Khan = Khan;
window.KhanUtil = Khan.Util;

});

define('utils/answer-types.js',['require'],function(require) {

var MAXERROR_EPSILON = Math.pow(2, -42);

// Function used to get the text of the choices, which is then used
// to check against the correct answer
var extractRawCode = function(elem) {
    var $elem = $(elem).clone(true);
    var code = $elem.find("code");
    if (code.length) {
        // If there are <code> tags in the element, remove them and replace
        // them with their original formulas
        $.each(code, function(i, elem) {
            $(elem).replaceWith(
                // TODO(emily): Adding <code> and <script> tags around this is
                // a horrible hack to make this code backwards-compatible with
                // the old extractRawCode (so that timeline works, etc). Remove
                // this at some point and make it just return the formula, not
                // the wrapping.
                '<code><script type="math/tex">' +
                KhanUtil.retrieveMathFormula(elem) +
                '</script></code>'
            );
        });
    }
    return $elem.html();
};

function getTextSquish(elem) {
    return $(elem).text().replace(/\s+/g, "");
}

// TODO(alpert): Don't duplicate from khan-exercise.js
function checkIfAnswerEmpty(guess) {
    // If multiple-answer, join all responses and check if that's empty
    // Remove commas left by joining nested arrays in case multiple-answer is
    // nested
    return $.trim(guess) === "" || (guess instanceof Array &&
             $.trim(guess.join("").replace(/,/g, "")) === "");
}

/*
 * Answer types
 *
 * Utility for creating answerable questions displayed in exercises
 *
 * Different answer types produce different kinds of input displays, and do
 * different kinds of checking on the solutions.
 *
 * Each of the objects contain two functions, setup and createValidator.
 *
 * The setup function takes a solutionarea and solution, and performs setup
 * within the solutionarea, and then returns an object which contains:
 *
 * answer: a function which, when called, will retrieve the current answer from
 *         the solutionarea, which can then be validated using the validator
 *         function
 * validator: a function returned from the createValidator function (defined
 *            below)
 * solution: the correct answer to the problem
 * examples: a list of example formats to be shown in the "acceptable formats"
 *           popup
 * showGuess: a function which, when given a guess, shows the guess within the
 *            provided solutionarea
 * showGuessCustom: a function which displays parts of a guess that are not
 *                  within the solutionarea; currently only used for custom
 *                  answers
 *
 * The createValidator function only takes a solution, and it returns a
 * function which can be used to validate an answer.
 *
 * The resulting validator function returns:
 * - true: if the answer is fully correct
 * - false: if the answer is incorrect
 * - "" (the empty string): if no answer has been provided (e.g. the answer box
 *   is left unfilled)
 * - a string: if there is some slight error
 *
 * In most cases, setup and createValidator don't really need the solution DOM
 * element so we have setupFunctional and createValidatorFunctional for them
 * which take only $solution.text() and $solution.data(). This makes it easier
 * to reuse specific answer types.
 *
 * TODO(alpert): Think of a less-absurd name for createValidatorFunctional.
 *
 */

Khan.answerTypes = $.extend(Khan.answerTypes, {
    /*
     * text answer type
     *
     * Displays a simple text box, and performs direct string matching on the
     * value typed in an the answer provided
     */
    text: {
        setupFunctional: function(solutionarea, solutionText, solutionData) {
            // Add a text box
            var input;
            if (window.Modernizr && Modernizr.touchevents) {
                // special flag for iOS devices
                input = $('<input type="text" autocapitalize="off">');
            } else {
                input = $('<input type="text">');
            }
            $(solutionarea).append(input);

            return {
                validator: Khan.answerTypes.text.createValidatorFunctional(
                        solutionText, solutionData),
                answer: function() {
                    return input.val();
                },
                solution: $.trim(solutionText),
                examples: [],
                showGuess: function(guess) {
                    input.val(guess === undefined ? "" : guess);
                }
            };
        },
        createValidatorFunctional: function(correct, options) {
            options = $.extend({
                correctCase: "required"
            }, options);

            correct = $.trim(correct);

            return function(guess) {
                // The fallback variable is used in place of the answer, if no
                // answer is provided (i.e. the field is left blank)
                var fallback =
                    options.fallback != null ? "" + options.fallback : "";

                guess = $.trim(guess) || fallback;
                var score = {
                    empty: false,
                    correct: false,
                    message: null,
                    guess: guess
                };
                if (guess.toLowerCase() === correct.toLowerCase()) {
                    if (correct === guess || options.correctCase === "optional") {
                        score.correct = true;
                    } else {
                        if (guess === guess.toLowerCase()) {
                            score.message = $._("Your answer is almost correct, but " +
                                       "must be in capital letters.");
                        } else if (guess === guess.toUpperCase()) {
                            score.message = $._("Your answer is almost correct, but " +
                                       "must not be in capital letters.");
                        } else {
                            score.message = $._("Your answer is almost correct, but " +
                                       "must be in the correct case.");
                        }
                    }
                }
                return score;
            };
        }
    },

    /*
     * predicate answer type
     *
     * performs simple predicate-based checking of a numeric solution, with
     * different kinds of number formats
     *
     * Uses the data-forms option on the solution to choose which number formats
     * are acceptable. Available data-forms:
     *
     * - integer:  3
     * - proper:   3/5
     * - improper: 5/3
     * - pi:       3 pi
     * - log:      log(5)
     * - percent:  15%
     * - mixed:    1 1/3
     * - decimal:  1.7
     *
     * The solution should be a predicate of the form:
     *
     * function(guess, maxError) {
     *     return abs(guess - 3) < maxError;
     * }
     *
     */
    predicate: {
        defaultForms: "integer, proper, improper, mixed, decimal",
        setupFunctional: function(solutionarea, solutionText, solutionData) {
            // retrieve the options from the solution data
            var options = $.extend({
                simplify: "required",
                ratio: false,
                forms: Khan.answerTypes.predicate.defaultForms
            }, solutionData);
            var acceptableForms = options.forms.split(/\s*,\s*/);

            // TODO(jack): remove options.inexact in favor of options.maxError
            if (options.inexact === undefined) {
                // If we aren't allowing inexact, ensure that we don't have a
                // large maxError as well.
                options.maxError = 0;
            }
            // Allow a small tolerance on maxError, to avoid numerical
            // representation issues (2.3 should be correct for a solution of
            // 2.45 with maxError=0.15).
            options.maxError = +options.maxError + MAXERROR_EPSILON;

            var input = $('<input type="text" autocapitalize="off">');
            $(solutionarea).append(input);

            // retrieve the example texts from the different forms
            var exampleForms = {
                integer: $._("an integer, like <code>6</code>"),

                proper: (function() {
                        if (options.simplify === "optional") {
                            return $._("a <em>proper</em> fraction, like " +
                                       "<code>1/2</code> or <code>6/10</code>");
                        } else {
                            return $._("a <em>simplified proper</em> " +
                                       "fraction, like <code>3/5</code>");
                        }
                    })(),

                improper: (function() {
                        if (options.simplify === "optional") {
                            return $._("an <em>improper</em> fraction, like " +
                                       "<code>10/7</code> or <code>14/8</code>");
                        } else {
                            return $._("a <em>simplified improper</em> " +
                                       "fraction, like <code>7/4</code>");
                        }
                    })(),

                pi: $._("a multiple of pi, like <code>12\\ \\text{pi}</code> " +
                    "or <code>2/3\\ \\text{pi}</code>"),

                log: $._("an expression, like <code>\\log(100)</code>"),

                percent: $._("a percent, like <code>%(NUM)s\\%</code>", {NUM: KhanUtil.localeToFixed(12.34, 2)}),

                mixed: $._("a mixed number, like <code>1\\ 3/4</code>"),

                decimal: (function() {
                        if (options.inexact === undefined) {
                            return $._("an <em>exact</em> decimal, like " +
                                "<code>%(NUM)s</code>", {NUM: KhanUtil.localeToFixed(0.75, 2)});
                        } else {
                            return $._("a decimal, like <code>%(NUM)s</code>", {NUM: KhanUtil.localeToFixed(0.75, 2)});
                        }
                    })()
            };

            // extract the examples for the given forms
            var examples = [];
            $.each(acceptableForms, function(i, form) {
                if (exampleForms[form] != null) {
                    examples.push(exampleForms[form]);
                }
            });

            return {
                validator: Khan.answerTypes.predicate.createValidatorFunctional(
                        solutionText, solutionData),
                answer: function() {
                    return input.val();
                },
                solution: $.trim(solutionText),
                examples: examples,
                showGuess: function(guess) {
                    input.val(guess === undefined ? "" : guess);
                }
            };
        },
        createValidatorFunctional: function(predicate, options) {
            // Extract the options from the given solution object
            options = $.extend({
                simplify: "required",
                ratio: false,
                forms: Khan.answerTypes.predicate.defaultForms
            }, options);
            var acceptableForms;
            // this is maintaining backwards compatibility
            // TODO(merlob) fix all places that depend on this, then delete
            if (!_.isArray(options.forms)) {
                acceptableForms = options.forms.split(/\s*,\s*/);
            } else {
                acceptableForms = options.forms;
            }

            // TODO(jack): remove options.inexact in favor of options.maxError
            if (options.inexact === undefined) {
                // If we aren't allowing inexact, ensure that we don't have a
                // large maxError as well.
                options.maxError = 0;
            }
            // Allow a small tolerance on maxError, to avoid numerical
            // representation issues (2.3 should be correct for a solution of
            // 2.45 with maxError=0.15).
            options.maxError = +options.maxError + MAXERROR_EPSILON;

            // If percent is an acceptable form, make sure it's the last one
            // in the list so we don't prematurely complain about not having
            // a percent sign when the user entered the correct answer in a
            // different form (such as a decimal or fraction)
            if (_.contains(acceptableForms, "percent")) {
                acceptableForms = _.without(acceptableForms, "percent");
                acceptableForms.push("percent");
            }

            predicate = _.isFunction(predicate) ?
                    predicate :
                    KhanUtil.tmpl.getVAR(predicate);

            // Take text looking like a fraction, and turn it into a number
            var fractionTransformer = function(text) {
                text = text
                    // Replace unicode minus sign with hyphen
                    .replace(/\u2212/, "-")

                    // Remove space after +, -
                    .replace(/([+-])\s+/g, "$1")

                    // Remove leading/trailing whitespace
                    .replace(/(^\s*)|(\s*$)/gi, "");

                    // Extract numerator and denominator
                var match = text.match(/^([+-]?\d+)\s*\/\s*([+-]?\d+)$/);
                var parsedInt = parseInt(text, 10);
                if (match) {
                    var num = parseFloat(match[1]),
                        denom = parseFloat(match[2]);
                    var simplified = denom > 0 &&
                        (options.ratio || match[2] !== "1") &&
                        KhanUtil.getGCD(num, denom) === 1;
                    return [{
                        value: num / denom,
                        exact: simplified
                    }];
                } else if (!isNaN(parsedInt) && "" + parsedInt === text) {
                    return [{
                        value: parsedInt,
                        exact: true
                    }];
                }

                return [];
            };

            /*
             * Different forms of numbers
             *
             * Each function returns a list of objects of the form:
             *
             * {
             *    value: numerical value,
             *    exact: true/false
             * }
             */
            var forms = {
                // integer, which is encompassed by decimal
                integer: function(text) {
                    // Compare the decimal form to the decimal form rounded to
                    // an integer. Only accept if the user actually entered an
                    // integer.
                    var decimal = forms.decimal(text);
                    var rounded = forms.decimal(text, 1);
                    if ((decimal[0].value != null &&
                            decimal[0].value === rounded[0].value) ||
                            (decimal[1].value != null &&
                            decimal[1].value === rounded[1].value)) {
                        return decimal;
                    }
                    return [];
                },

                // A proper fraction
                proper: function(text) {
                    return $.map(fractionTransformer(text), function(o) {
                        // All fractions that are less than 1
                        if (Math.abs(o.value) < 1) {
                            return [o];
                        } else {
                            return [];
                        }
                    });
                },

                // an improper fraction
                improper: function(text) {
                    return $.map(fractionTransformer(text), function(o) {
                        // All fractions that are greater than 1
                        if (Math.abs(o.value) >= 1) {
                            return [o];
                        } else {
                            return [];
                        }
                    });
                },

                // pi-like numbers
                pi: function(text) {
                    var match, possibilities = [];

                    // Replace unicode minus sign with hyphen
                    text = text.replace(/\u2212/, "-");

                    // - pi
                    if ((match = text.match(
                                    /^([+-]?)\s*(pi?|\u03c0|t(?:au)?|\u03c4|pau)$/i
                                ))) {
                        possibilities = [{ value: parseFloat(match[1] + "1"), exact: true }];

                    // 5 / 6 pi
                    } else if ((match = text.match(/^([+-]?\s*\d+\s*(?:\/\s*[+-]?\s*\d+)?)\s*\*?\s*(pi?|\u03c0|t(?:au)?|\u03c4|pau)$/i))) {
                        possibilities = fractionTransformer(match[1]);

                    // 4 5 / 6 pi
                    } else if ((match = text.match(/^([+-]?)\s*(\d+)\s*([+-]?\d+)\s*\/\s*([+-]?\d+)\s*\*?\s*(pi?|\u03c0|t(?:au)?|\u03c4|pau)$/i))) {
                        var sign = parseFloat(match[1] + "1"),
                            integ = parseFloat(match[2]),
                            num = parseFloat(match[3]),
                            denom = parseFloat(match[4]);
                        var simplified = num < denom &&
                            KhanUtil.getGCD(num, denom) === 1;

                        possibilities = [{
                            value: sign * (integ + num / denom),
                            exact: simplified
                        }];

                    // 5 pi / 6
                    } else if ((match = text.match(/^([+-]?\s*\d+)\s*\*?\s*(pi?|\u03c0|t(?:au)?|\u03c4|pau)\s*(?:\/\s*([+-]?\s*\d+))?$/i))) {
                        possibilities = fractionTransformer(match[1] +
                                                            "/" + match[3]);

                    // - pi / 4
                    } else if ((match = text.match(/^([+-]?)\s*\*?\s*(pi?|\u03c0|t(?:au)?|\u03c4|pau)\s*(?:\/\s*([+-]?\d+))?$/i))) {
                        possibilities = fractionTransformer(match[1] +
                                                            "1/" + match[3]);

                    // 0
                    } else if (text === "0") {
                        possibilities = [{ value: 0, exact: true }];

                    // 0.5 pi (fallback)
                    } else if ((match = text.match(
                                /^(.+)\s*\*?\s*(pi?|\u03c0|t(?:au)?|\u03c4|pau)$/i
                                        ))) {
                        possibilities = forms.decimal(match[1]);
                    } else {
                        possibilities = _.reduce(Khan.answerTypes.predicate.defaultForms.split(/\s*,\s*/), function(memo, form) {
                            return memo.concat(forms[form](text));
                        }, []);
                        $.each(possibilities, function(ix, possibility) {
                            possibility.piApprox = true;
                        });
                        return possibilities;
                    }

                    var multiplier = Math.PI;
                    if (text.match(/t(?:au)?|\u03c4/)) {
                        multiplier = Math.PI * 2;
                    }

                    // We're taking an early stand along side xkcd in the
                    // inevitable ti vs. pau debate... http://xkcd.com/1292
                    if (text.match(/pau/)) {
                        multiplier = Math.PI * 1.5;
                    }

                    $.each(possibilities, function(ix, possibility) {
                        possibility.value *= multiplier;
                    });
                    return possibilities;
                },

                // Converts '' to 1 and '-' to -1 so you can write "[___] x"
                // and accept sane things
                coefficient: function(text) {
                    var possibilities = [];

                    // Replace unicode minus sign with hyphen
                    text = text.replace(/\u2212/, "-");

                    if (text === "") {
                        possibilities = [{ value: 1, exact: true }];
                    } else if (text === "-") {
                        possibilities = [{ value: -1, exact: true }];
                    }
                    return possibilities;
                },

                // simple log(c) form
                log: function(text) {
                    var match, possibilities = [];

                    // Replace unicode minus sign with hyphen
                    text = text.replace(/\u2212/, "-");
                    text = text.replace(/[ \(\)]/g, "");

                    if ((match = text.match(/^log\s*(\S+)\s*$/i))) {
                        possibilities = forms.decimal(match[1]);
                    } else if (text === "0") {
                        possibilities = [{ value: 0, exact: true }];
                    }
                    return possibilities;
                },

                // Numbers with percent signs
                percent: function(text) {
                    text = $.trim(text);
                    // store whether or not there is a percent sign
                    var hasPercentSign = false;

                    if (text.indexOf("%") === (text.length - 1)) {
                        text = $.trim(text.substring(0, text.length - 1));
                        hasPercentSign = true;
                    }

                    var transformed = forms.decimal(text);
                    $.each(transformed, function(ix, t) {
                        t.exact = hasPercentSign;
                        t.value = t.value / 100;
                    });
                    return transformed;
                },

                // Mixed numbers, like 1 3/4
                mixed: function(text) {
                    var match = text
                        // Replace unicode minus sign with hyphen
                        .replace(/\u2212/, "-")

                        // Remove space after +, -
                        .replace(/([+-])\s+/g, "$1")

                        // Extract integer, numerator and denominator
                        .match(/^([+-]?)(\d+)\s+(\d+)\s*\/\s*(\d+)$/);

                    if (match) {
                        var sign = parseFloat(match[1] + "1"),
                            integ = parseFloat(match[2]),
                            num = parseFloat(match[3]),
                            denom = parseFloat(match[4]);
                        var simplified = num < denom &&
                            KhanUtil.getGCD(num, denom) === 1;

                        return [{
                            value: sign * (integ + num / denom),
                            exact: simplified
                        }];
                    }

                    return [];
                },

                // Decimal numbers -- compare entered text rounded to
                // 'precision' Reciprical of the precision against the correct
                // answer. We round to 1/1e10 by default, which is healthily
                // less than machine epsilon but should be more than any real
                // decimal answer would use. (The 'integer' answer type uses
                // precision == 1.)
                decimal: function(text, precision) {
                    if (precision == null) {
                        precision = 1e10;
                    }

                    var normal = function(text) {
                        text = $.trim(text);

                        var match = text
                            // Replace unicode minus sign with hyphen
                            .replace(/\u2212/, "-")
                            // Remove space after +, -
                            .replace(/([+-])\s+/g, "$1")
                            // Extract integer, numerator and denominator. If
                            // commas or spaces are used, they must be in the
                            // "correct" places
                            .match(/^([+-]?(?:\d{1,3}(?:[, ]?\d{3})*\.?|\d{0,3}(?:[, ]?\d{3})*\.(?:\d{3}[, ]?)*\d{1,3}))$/);

                        // You can't start a number with `0,`, to prevent us
                        // interpeting '0.342' as correct for '342'
                        var badLeadingZero = text.match(/^0[0,]*,/);

                        if (match && !badLeadingZero) {
                            var x = parseFloat(match[1].replace(/[, ]/g, ""));

                            if (options.inexact === undefined) {
                                x = Math.round(x * precision) / precision;
                            }

                            return x;
                        }
                    };

                    var commas = function(text) {
                        text = text.replace(/([\.,])/g, function(_, c) {
                            return (c === "." ? "," : ".");
                        });
                        return normal(text);
                    };

                    return [
                        { value: normal(text), exact: true },
                        { value: commas(text), exact: true }
                    ];
                }
            };

            // validator function
            return function(guess) {
                // The fallback variable is used in place of the answer, if no
                // answer is provided (i.e. the field is left blank)
                var fallback =
                    options.fallback != null ? "" + options.fallback : "";

                guess = $.trim(guess) || fallback;
                var score = {
                    empty: guess === "",
                    correct: false,
                    message: null,
                    guess: guess
                };

                // iterate over all the acceptable forms, and if one of the
                // answers is correct, return true
                $.each(acceptableForms, function(i, form) {
                    var transformed = forms[form](guess);

                    for (var j = 0, l = transformed.length; j < l; j++) {
                        var val = transformed[j].value;
                        var exact = transformed[j].exact;
                        var piApprox = transformed[j].piApprox;
                        // If a string was returned, and it exactly matches,
                        // return true
                        if (predicate(val, options.maxError)) {
                            // If the exact correct number was returned,
                            // return true
                            if (exact || options.simplify === "optional") {
                                score.correct = true;
                                score.message = options.message || null;
                                // If the answer is correct, don't say it's
                                // empty. This happens, for example, with the
                                // coefficient type where guess === "" but is
                                // interpreted as "1" which is correct.
                                score.empty = false;
                            } else if (form === "percent") {
                                // Otherwise, an error was returned
                                score.empty = true;
                                score.message = $._("Your answer is almost correct, " +
                                          "but it is missing a " +
                                          "<code>\\%</code> at the end.");
                            } else {
                                if (options.simplify !== "enforced") {
                                    score.empty = true;
                                }
                                score.message = $._("Your answer is almost correct, " +
                                          "but it needs to be simplified.");
                            }

                            return false; // break;
                        } else if (piApprox &&
                                   predicate(val, Math.abs(val * 0.001))) {
                            score.empty = true;
                            score.message = $._("Your answer is close, but you may " +
                                      "have approximated pi. Enter your " +
                                      "answer as a multiple of pi, like " +
                                      "<code>12\\ \\text{pi}</code> or " +
                                      "<code>2/3\\ \\text{pi}</code>");
                        }
                    }
                });

                if (score.correct === false) {
                    var interpretedGuess = false;
                    _.each(forms, function(form) {
                        if(_.any(form(guess), function(t) {
                                return t.value != null && !_.isNaN(t.value);})) {
                            interpretedGuess = true;
                        }
                    });
                    if (!interpretedGuess) {
                        score.empty = true;
                        score.message = $._("We could not understand your answer. " +
                            "Please check your answer for extra text or symbols.");
                        return score;
                    }
                }

                return score;
            };
        }
    },

    /*
     * number answer type
     *
     * wraps the predicate answer type to performs simple number-based checking
     * of a solution
     */
    number: {
        convertToPredicate: function(correct, options) {
            // TODO(alpert): Don't think this $.trim is necessary
            var correctFloat = parseFloat($.trim(correct));

            return [
                    function(guess, maxError) {
                        return Math.abs(guess - correctFloat) < maxError;
                    },
                    $.extend({}, options, {type: "predicate"})
                ];
        },
        setupFunctional: function(solutionarea, solutionText, solutionData) {
            var args = Khan.answerTypes.number.convertToPredicate(
                    solutionText, solutionData);
            return Khan.answerTypes.predicate.setupFunctional(
                    solutionarea,
                    /* text: */ args[0], /* data: */ args[1]);
        },
        createValidatorFunctional: function(correct, options) {
            return Khan.answerTypes.predicate.createValidatorFunctional.apply(
                Khan.answerTypes.predicate,
                Khan.answerTypes.number.convertToPredicate(correct, options));
        }
    },

    /*
     * These next four answer types are just synonyms for number with given
     * forms. Set the correct forms on the solution, and pass it on to number
     */
    decimal: numberAnswerType("decimal"),

    rational: numberAnswerType("integer, proper, improper, mixed"),

    // A little bit of a misnomer as proper fractions are also accepted
    improper: numberAnswerType("integer, proper, improper"),

    mixed: numberAnswerType("integer, proper, mixed"),

    // Perform a regex match on the entered string
    regex: {
        setupFunctional: function(solutionarea, solutionText, solutionData) {
            var input;
            if (window.Modernizr && Modernizr.touchevents) {
                // special flag for iOS devices
                input = $('<input type="text" autocapitalize="off">');
            } else {
                input = $('<input type="text">');
            }
            $(solutionarea).append(input);

            return {
                validator: Khan.answerTypes.regex.createValidatorFunctional(
                        solutionText, solutionData),
                answer: function() {
                   return input.val();
                },
                solution: $.trim(solutionText),
                examples: [],
                showGuess: function(guess) {
                    input.val(guess === undefined ? "" : guess);
                }
            };
        },
        createValidatorFunctional: function(regex, options) {
            var flags = "";

            if (options.caseInsensitive != null) {
                flags += "i";
            }

            regex = new RegExp($.trim(regex), flags);

            return function(guess) {
                // The fallback variable is used in place of the answer, if no
                // answer is provided (i.e. the field is left blank)
                var fallback =
                    options.fallback != null ? "" + options.fallback : "";

                guess = $.trim(guess) || fallback;
                return {
                    empty: false,
                    correct: guess.match(regex) != null,
                    message: null,
                    guess: guess
                };
            };
        }
    },

    // An answer type with two text boxes, for solutions of the form a sqrt(b)
    radical: {
        setupFunctional: function(solutionarea, solutionText, solutionData) {
            var options = $.extend({
                simplify: "required"
            }, solutionData);

            // Add two input boxes
            var inte = $('<input type="text" autocapitalize="off">');
            var rad = $('<input type="text" autocapitalize="off">');

            // Make them look pretty
            $("<div class='radical'>")
                .append($("<span>").append(inte))
                .append('<span class="surd">&radic;</span>')
                .append($("<span>").append(rad).addClass("overline"))
                .appendTo(solutionarea);

            var ansSquared = parseFloat(solutionText);
            var ans = KhanUtil.splitRadical(ansSquared);

            return {
                validator: Khan.answerTypes.radical.createValidatorFunctional(
                        solutionText, solutionData),
                answer: function() {
                    return [$.trim(inte.val()), $.trim(rad.val())];
                },
                solution: ans,
                examples: (options.simplify === "required") ?
                    [$._("a simplified radical, like <code>\\sqrt{2}</code> " +
                         "or <code>3\\sqrt{5}</code>")] :
                    [$._("a radical, like <code>\\sqrt{8}</code> or " +
                         "<code>2\\sqrt{2}</code>")],
                showGuess: function(guess) {
                    inte.val(guess ? guess[0] : "");
                    rad.val(guess ? guess[1] : "");
                }
            };
        },
        createValidatorFunctional: function(ansSquared, options) {
            options = $.extend({
                simplify: "required"
            }, options);

            // The provided answer is the square of what is meant to be
            // entered. Use KhanUtil.splitRadical to find the different parts
            ansSquared = parseFloat(ansSquared);
            var ans = KhanUtil.splitRadical(ansSquared);

            return function(guess) {
                // If nothing typed into either box, don't grade the answer
                if (guess[0].length === 0 && guess[1].length === 0) {
                    return {
                        empty: true,
                        correct: false,
                        message: null,
                        guess: guess
                    };
                }
                // If nothing is typed into one of the boxes, use 1
                guess[0] = guess[0].length > 0 ? guess[0] : "1";
                guess[1] = guess[1].length > 0 ? guess[1] : "1";
                // Parse the two floats from the guess
                var inteGuess = parseFloat(guess[0]);
                var radGuess = parseFloat(guess[1]);

                // The answer is correct if the guess square is equal to the
                // given solution
                var correct =
                    Math.abs(inteGuess) * inteGuess * radGuess === ansSquared;
                // the answer is simplified if the sqrt portion and integer
                // portion are the same as what is given by splitRadical
                var simplified = inteGuess === ans[0] && radGuess === ans[1];

                var score = {
                    empty: false,
                    correct: false,
                    message: null,
                    guess: guess
                };

                if (correct) {
                    if (simplified || options.simplify === "optional") {
                        score.correct = true;
                    } else {
                        score.message = $._("Your answer is almost correct, but it " +
                                   "needs to be simplified.");
                    }
                }
                return score;
            };
        }
    },

    // An answer type with two text boxes, for solutions of the form a cuberoot(b)
    cuberoot: {
        setupFunctional: function(solutionarea, solutionText, solutionData) {
            var options = $.extend({
                simplify: "required"
            }, solutionData);

            // Add two input boxes
            var inte = $('<input type="text" autocapitalize="off">');
            var rad = $('<input type="text" autocapitalize="off">');

            // Make them look pretty
            $("<div class='radical'>")
                .append($("<span>").append(inte))
                .append('<span class="surd" style="vertical-align: 6px;"><code>\\sqrt[3]{}</code></span>')
                .append($("<span>").append(rad).addClass("overline"))
                .appendTo(solutionarea).tex();

            var ansCubed = parseFloat(solutionText);
            var ans = KhanUtil.splitCube(ansCubed);

            return {
                validator: Khan.answerTypes.cuberoot.createValidatorFunctional(
                        solutionText, solutionData),
                answer: function() {
                    return [inte.val(), rad.val()];
                },
                solution: ans,
                examples: (options.simplify === "required") ?
                    [$._("a simplified radical, like <code>\\sqrt[3]{2}</code> " +
                         "or <code>3\\sqrt[3]{5}</code>")] :
                    [$._("a radical, like <code>\\sqrt[3]{8}</code> or " +
                         "<code>2\\sqrt[3]{2}</code>")],
                showGuess: function(guess) {
                    inte.val(guess ? guess[0] : "");
                    rad.val(guess ? guess[1] : "");
                }
            };
        },
        createValidatorFunctional: function(ansCubed, options) {
            options = $.extend({
                simplify: "required"
            }, options);

            // The provided answer is the cube of what is meant to be
            // entered. Use KhanUtil.splitCube to find the different parts
            ansCubed = parseFloat(ansCubed);
            var ans = KhanUtil.splitCube(ansCubed);

            return function(guess) {
                // If nothing typed into either box, don't grade the answer
                if (guess[0].length === 0 && guess[1].length === 0) {
                    return {
                        empty: true,
                        correct: false,
                        message: null,
                        guess: guess
                    };
                }
                // If nothing is typed into one of the boxes, use 1
                guess[0] = guess[0].length > 0 ? guess[0] : "1";
                guess[1] = guess[1].length > 0 ? guess[1] : "1";
                // Parse the two floats from the guess
                var inteGuess = parseFloat(guess[0]);
                var radGuess = parseFloat(guess[1]);

                // The answer is correct if the guess square is equal to the
                // given solution
                var correct =
                    Math.abs(inteGuess) * inteGuess * inteGuess * radGuess === ansCubed;
                // the answer is simplified if the sqrt portion and integer
                // portion are the same as what is given by splitCube
                var simplified = inteGuess === ans[0] && radGuess === ans[1];

                var score = {
                    empty: false,
                    correct: false,
                    message: null,
                    guess: guess
                };

                if (correct) {
                    if (simplified || options.simplify === "optional") {
                        score.correct = true;
                    } else {
                        score.message = $._("Your answer is almost correct, but it " +
                                   "needs to be simplified.");
                    }
                }
                return score;
            };
        }
    },

    /*
     * Multiple answer type
     *
     * This answer type allows for multiple different other answer types to be
     * combined into a single answer.
     *
     * It works by finding html elements with the "sol" class, and converting
     * them into mini solutionareas, which are then filled in by the setup
     * functions of their cooresponding answer types. In order to do solution
     * checking, the answers of each of the areas are placed in an array, and
     * then the validator works by iterating over the array and making sure
     * each of the individual solutions are correct
     */
    multiple: {
        setup: function(solutionarea, solution) {
            // Very quickly place all of the elements in the solution area
            // Clone it, because we don't want to modify or move it
            $(solutionarea).append(
                    $(solution).clone(true).texCleanup().contents()
                        .runModules()
            );

            var answerDataArray = [];

            // Iterate over each of the .sol elements
            $(solutionarea).find(".sol").each(function(idx) {
                var type = $(this).data("type");
                type = type != null ? type : "number";

                // find the corresponding answer
                var sol = $(solution).find(".sol").eq(idx);

                // empty the .sol element in preperation for treating it as a
                // solutionarea
                var solarea = $(this).empty();

                // perform setup on each of the areas
                var answerData = Khan.answerTypes[type].setup(solarea, sol);
                // Store the returned data, for use later
                answerDataArray.push(answerData);
            });

            // Remove the examples from the solutionarea
            $(solutionarea).find(".example").remove();

            return {
                validator: Khan.answerTypes.multiple.createValidator(solution),
                answer: function() {
                    var answer = [];

                    // Go through each of the answerDatas, and call the answer
                    // functions in turn, storing each of the answers in an
                    // array
                    $.each(answerDataArray, function(i, answerData) {
                        answer.push(answerData.answer());
                    });

                    return answer;
                },
                solution: (function() {
                    // Retrieve each of the solutions from the answerDatas
                    $.map(answerDataArray, function(answerData) {
                        return answerData.solution;
                    });
                })(),
                // Find all the example classes from the solution, and store
                // those
                examples: (function() {
                    var ex = solution.find(".example").texCleanup()
                                     .map(function(i, el) {
                        return $(el).html();
                    });
                    if (ex.length === 0 && answerDataArray.length === 1) {
                        ex = answerDataArray[0].examples;
                    }
                    return ex;
                })(),
                showGuess: function(guess) {
                    // Iterate through each of the answerDatas, and show the
                    // cooresponding guess for each
                    $.each(answerDataArray, function(i, answerData) {
                        if (guess !== undefined) {
                            answerData.showGuess(guess[i]);
                        } else {
                            answerData.showGuess();
                        }
                    });
                },
                showCustomGuess: function(guess) {
                    // Iterate through each of the answerDatas, and show the
                    // cooresponding custom guess for each if it exists
                    $.each(answerDataArray, function(i, answerData) {
                        if (!_.isFunction(answerData.showCustomGuess)) {
                            return;
                        }
                        if (guess !== undefined) {
                            answerData.showCustomGuess(guess[i]);
                        } else {
                            answerData.showCustomGuess();
                        }
                    });
                }
            };
        },
        createValidator: function(solution) {
            var validators = [];

            // Iterate over all of the .sols in the answer
            $(solution).find(".sol").each(function() {
                var sol = $(this);

                var type = sol.data("type");
                type = type != null ? type : "number";

                // create a validator for each of the solutions
                var validator = Khan.answerTypes[type].createValidator(sol);
                validators.push(validator);
            });

            return function(guess) {
                var score = {
                    empty: true,
                    correct: true,
                    message: null,
                    guess: guess
                };
                var blockGradingMessage = null;

                // If the answer is completely empty, don't grade it
                if (checkIfAnswerEmpty(guess)) {
                    score.empty = true;
                    score.correct = false;
                    return score;
                }

                // Iterate over each of the elements in the guess
                $.each(guess, function(i, g) {
                    // Check whether that answer is right by validating it
                    // with the corresponding validator
                    var pass = validators[i](g);

                    if (pass.message && pass.empty) {
                        // Special case where a validator returns a message
                        // for an "empty" response. This probably means it's
                        // not really empty, but a correct-but-not-simplified
                        // answer. Rather that treating this as actually empty,
                        // possibly leading to the entire multiple being marked
                        // wrong for being incomplete, note the situation but
                        // continue determining whether the entire answer is
                        // otherwise correct or not before forwarding on the
                        // message.
                        blockGradingMessage = pass.message;
                    } else {
                        score.empty = score.empty && pass.empty;
                        score.correct = score.correct && pass.correct;
                        // TODO(eater): This just forwards one message
                        score.message = score.message || pass.message;
                    }
                });

                if (score.correct && blockGradingMessage != null) {
                    return {
                        empty: true,
                        correct: false,
                        message: blockGradingMessage,
                        guess: guess
                    };
                } else {
                    score.empty = false;
                    return score;
                }
            };
        }
    },

    /*
     * The set answer type allows for multiple different answers with the same
     * kind of input.
     *
     * The different correct answers are stored in .set-sol elements, each of
     * which describes a different correct answer
     *
     * the method of input is stored in the .input-format element, with each
     * .entry element within that describing an answer-type from which input
     * should be retrieved
     *
     * The guess is retrieved as a list of the answers given from each of the
     * .entry elements within the solution area
     *
     * If there are more solutions given than inputs, then all of the inputs
     * must be filled. If there are more inputs than solutions, then all of the
     * solutions must be given. Either way, every given solution must be
     * correct, or the whole thing is wrong.
     */
    set: {
        setup: function(solutionarea, solution) {
            // Append the input format to the solution area
            $(solutionarea).append(
                $(solution).find(".input-format").clone(true).texCleanup()
                        .contents().runModules()
            );

            var inputArray = [];
            var showGuessArray = [];
            // For each of the entry elements
            $(solutionarea).find(".entry").each(function() {
                var input = $(this), type = $(this).data("type");
                type = type != null ? type : "number";

                var sol = input.clone(true),
                    solarea = input.empty();

                // Perform setup within that element
                var validator = Khan.answerTypes[type].setup(solarea, sol);
                // Store the answer and showGuess functions
                inputArray.push(validator.answer);
                showGuessArray.push(validator.showGuess);
            });

            var solutionArray = [];

            // Make fake solutionareas, and store the solutions from each
            // TODO(emily): fix this horrible hack, by making the solution
            //              easier to access
            $(solution).find(".set-sol").clone(true).each(function() {
                var type = $(this).data("type");
                type = type != null ? type : "number";

                var solarea = $("<div>");

                var validator = Khan.answerTypes[type].setup(solarea, $(this));

                solutionArray.push(validator.solution);
            });

            return {
                validator: Khan.answerTypes.set.createValidator(solution),
                answer: function() {
                    var answer = [];

                    // For each of the inputs, get the answer and store it in
                    // the answer array
                    $.each(inputArray, function(i, getAns) {
                        answer.push(getAns());
                    });

                    return answer;
                },
                solution: solution,
                examples: solution.find(".example").texCleanup()
                                  .map(function(i, el) {
                    return $(el).html();
                }),
                showGuess: function(guess) {
                    // For each of the inputs, call the appropriate showGuess
                    // function
                    $.each(showGuessArray, function(i, showGuess) {
                        if (guess === undefined) {
                            showGuess();
                        } else {
                            showGuess(guess[i]);
                        }
                    });
                }
            };
        },
        createValidator: function(solution) {
            var validatorArray = [];

            // Fill validatorArray with validators for each acceptable answer
            $(solution).find(".set-sol").clone(true).each(function() {
                var type = $(this).data("type");
                type = type != null ? type : "number";

                var validator = Khan.answerTypes[type]
                                    .createValidator($(this));

                validatorArray.push(validator);
            });

            return function(guess) {
                var score = {
                    // If there are no validators, empty input is correct
                    empty: validatorArray.length === 0 ? false : true,
                    correct: true,
                    message: null,
                    guess: guess
                };
                var blockGradingMessage = null;

                // Store a copy of each of the validators. If one correctly
                // identifies a guess, remove it from this array, so duplicate
                // answers aren't marked correct twice
                var unusedValidators = validatorArray.slice(0);

                // Go through each of the guesses
                $.each(guess, function(i, g) {
                    // Whether or not the guess is correct
                    var correct = false;

                    // Go through each of the unused validators
                    $.each(unusedValidators, function(i, validator) {
                        var pass = validator(g);

                        // If this validator is trying to block grading
                        if (pass.empty && pass.message) {
                            // remove the working validator
                            unusedValidators.splice(i, 1);
                            // We want to block the entire answer from being
                            // accepted as correct but continue checking in
                            // case another part is wrong.
                            blockGradingMessage = pass.message;
                            correct = true;
                            // break
                            return false;
                        }

                        // If this validator completely accepts this answer
                        // or returns a check answer message
                        if (pass.correct || pass.message) {
                            // remove the working validator
                            unusedValidators.splice(i, 1);
                            // store correct
                            correct = pass.correct || pass.message;
                            // break
                            return false;
                        }
                    });

                    if (!checkIfAnswerEmpty(g) &&
                            !checkIfAnswerEmpty(correct)) {
                        score.empty = false;
                    }

                    // If we didn't get it right, and the answer isn't empty,
                    // the entire solution is false
                    //
                    // TODO(emily): make the "is the answer empty" part of this
                    //              work better for all the different answer
                    //              types
                    // TODO(emily): Perhaps provide insight to the student
                    //              about whether or not part of their answer
                    //              is correct? While this could be abused, it
                    //              would seem more friendly.
                    if (!correct && $.trim([g].join("")) !== "") {
                        score.correct = false;
                        return false;  // break
                    }

                    // If we have a check answer message
                    if (typeof correct === "string") {
                        score.message = correct;
                        score.correct = false;
                    }
                });

                // If there were more correct answers than possible guesses
                if (validatorArray.length > guess.length) {
                    // If not all of the guesses were filled in with correct
                    // answers
                    if (unusedValidators.length >
                        validatorArray.length - guess.length) {
                        // incorrect, more answers needed
                        score.correct = false;
                    }
                // Otherwise, if not all of the answers were provided
                } else if (unusedValidators.length > 0) {
                    // incorrect, some of the answers are missing
                    score.correct = false;
                }

                if (score.correct && blockGradingMessage != null) {
                    return {
                        empty: true,
                        correct: false,
                        message: blockGradingMessage,
                        guess: guess
                    };
                } else {
                    return score;
                }
            };
        }
    },

    /*
     * The radio answer type provides multiple choice type answers
     *
     * The different possible multiple choice answers are provided in a
     * seperate .choices element siblings with the main .solution element, with
     * the correct answer residing within the .solution element.
     *
     * There are two different modes of operation. Category mode and
     * non-category mode.
     *
     * In non-category mode, the answers (which don't include the correct
     * answer) combined with the correct answer are scrambled together. This is
     * meant for questions where the answers radically change from question to
     * question, and thus scrambling increases the difficulty, and makes the
     * solutions harder to pattern match. This is the default.
     *
     * In category mode, the answers are provided in the order they are given
     * within the .choices element, and the correct answer is duplicated in
     * both the solution and within the choices. This is meant for questions
     * where the solutions generally do not change from problem to problem.
     * This is enabled by adding data-category to the .choices element.
     */
    radio: {
        setup: function(solutionarea, solution) {
            // Add a list to the solution area
            var $list = $("<ul></ul>");
            $(solutionarea).append($list);

            // Retrieve the list of choices from the problem
            var $choices = $(solution).siblings(".choices");

            // Get the wrong choices and the solution. Note that we cleanup all
            // the math here, so we don't have to deal with annoying MathJax
            // stuff in our solutions, and also that we can directly compare
            // the .text() values of all of the nodes
            var $choicesClone = $choices.clone(true).texCleanup();
            var $solutionClone = $(solution).clone(true).texCleanup();

            // Retrieve the text of the solution so we can store it later
            var solutionText = $solutionClone.text();

            // Whether this is a category question, or if we should shuffle the
            // answers up.
            var isCategory = !!$choices.data("category");

            var possibleChoices;
            if (isCategory) {
                // If it's a category question, insert the solution into the
                // list of choices at the correct place, by comparing by the
                // text value of the elements.
                var correctText = getTextSquish($solutionClone);
                possibleChoices = _.map(
                    $choicesClone.children().get(),
                    function(elem) {
                        if (getTextSquish(elem) === correctText) {
                            return $solutionClone[0];
                        } else {
                            return elem;
                        }
                    });
            } else {
                // Otherwise, the possible choices is just the correct answer
                // and the other choices. We shuffle the choices here so that
                // when we slice off some of the choices later, we don't always
                // slice off the same ones.
                possibleChoices = $solutionClone.get().concat(
                    KhanUtil.shuffle($choicesClone.children().get())
                );
            }

            // The number of choices is either the number specified or the
            // number of choices in the list of possible choices.
            var numChoices = +$choices.data("show") || possibleChoices.length;

            // Whether to show a "none of the above" solution in our set of
            // answers.
            var showNone = !!$choices.data("none");

            // This code removes duplicate answers by looking at the text
            // values of the choices and keeping the non-duplicate answers
            var shownChoices = _.uniq(possibleChoices, false, function(elem) {
                return getTextSquish(elem);
            });

            // Here, we duplicate the old behaviour where, if there is one less
            // choice than we want, we will just add in the "none of the above"
            // choice instead of having it replace one of the real ones.
            var addNoneChoice = showNone &&
                    shownChoices.length === numChoices - 1;

            // If removing duplicates made it so there aren't enough showing
            // solutions (and we're not going to add in one last choice),
            // regenerate the problem
            if (shownChoices.length < numChoices && !addNoneChoice) {
                return false;
            // Otherwise, if there are too many choices, throw away some from
            // the end
            } else if (shownChoices.length > numChoices) {
                shownChoices = shownChoices.slice(0, numChoices);
            }

            // Shuffle the answers if we're not in category mode
            if (!isCategory) {
                shownChoices = KhanUtil.shuffle(shownChoices);
            }

            // Find the index of the correct answer
            var correctIndex;
            _.each(shownChoices, function(choice, i) {
                if (choice === $solutionClone[0]) {
                    correctIndex = i;
                }
            });

            // We figure out if the "none of the above" choice is correct if we
            // have such an answer and if the last shown answer is correct.
            // Note that we check against numChoices to decide if it is the
            // last choice, not shownChoices.length, because in the case that
            // we're going to be strictly adding the "none of the above"
            // choice, shownChoices.length won't accurately show the number of
            // choices that will be shown.
            var noneIsCorrect = showNone && correctIndex === numChoices - 1;

            // If showNone, replace the last solution with "None of the above",
            // which reveals the correct answer when it is picked and is right.
            if (showNone) {
                var $none = $("<span>").html($._("None of the above"));
                $none.data("noneOfTheAbove", true);

                // If the answer is correct, we add some data about what the
                // true answer is so we can show it later
                if (noneIsCorrect) {
                    $list.data("realAnswer",
                        $("<span>").addClass("value").append(
                            $solutionClone.clone(true).contents()
                        )
                    );
                }

                var noneIndex = shownChoices.length - 1;
                if (addNoneChoice) {
                    noneIndex = shownChoices.length;
                }

                shownChoices.splice(noneIndex, 1,
                    // We have to wrap this in something so that when we unwrap
                    // it below, it maintains its data attributes
                    $("<span>").append($none));
            }

            // Wrap each of the choices in elements and add radio buttons
            var wrappedChoices = _.map(shownChoices, function(choice, i) {
                return $("<li><label></label></li>").find("label").append([
                    $('<input type="radio" name="solution">').val(i),
                    $('<span class="value"></span>').append(
                        $(choice).contents()
                    )
                ]).end();
            });

            // Here we finally re-run modules, so that the math is reformatted
            $list.append(wrappedChoices).runModules();

            return {
                // We send some extra data to the validator so that it is
                // easier to grade
                validator: Khan.answerTypes.radio.createValidator({
                    solution: solution,
                    index: correctIndex,
                    noneIsCorrect: noneIsCorrect
                }),
                answer: function() {
                    // Find the chosen answer
                    var $choice = $list.find("input:checked");

                    // If nothing's checked, return null immediately
                    if ($choice.length === 0) {
                        return null;
                    }

                    // Find it's cooresponding value
                    var $choiceVal = $choice.siblings(".value");

                    // This (probably) only does something useful when the
                    // selected answer is the "none of the above" one
                    var $choiceNoneChild = $choiceVal.children().eq(0);

                    return {
                        // Some data about the "none of the above" answer
                        isNone: $choiceNoneChild.data("noneOfTheAbove"),
                        // The raw text value that was chosen
                        // TODO(emily): Remove this at the same time references
                        // to guess.value are removed down below, maybe (unless
                        // we want to have the text of the correct answer in
                        // the database)
                        value: extractRawCode($choiceVal),
                        // The index of the value that was chosen
                        index: +$choice.val()
                    };
                },
                solution: solutionText,
                examples: [],
                showGuess: function(guess) {
                    if (guess == null) {
                        $(solutionarea).find("input:checked")
                                       .attr("checked", false);
                    } else {
                        // Select the correct radio button
                        $list.children().filter(function() {
                            // Filter using the index to choose the radio
                            return guess.index ===
                                $(this).find("input").val();
                        }).find("input").attr("checked", true);
                    }
                }
            };
        },
        createValidator: function(solution) {
            // TODO(emily): Remove this backwards compatible code sometime
            // after 8/2013
            var correct = extractRawCode(solution.solution || solution);

            function showReal() {
                // Hacky stuff to make the correct solution appear when "none
                // of the above" is the correct answer
                var $list = $("#solutionarea").find("ul");
                var $choice =
                    $list.children().filter(function() {
                        return $(this).find("span.value > span")
                                      .data("noneOfTheAbove");
                    }).find("input");
                $choice.next().fadeOut("fast", function() {
                    var $real = $list.data("realAnswer");
                    $(this).replaceWith($real);
                    $real.tex().fadeIn("fast");
                });
            }

            return function(guess) {
                var score = {
                    empty: false,
                    correct: false,
                    message: null,
                    guess: guess
                };

                if (guess == null) {
                    score.empty = true;
                    return score;
                }

                if (guess.index) {
                    // New solutions include information about the correct
                    // answer like the correct index, etc. We can use that to
                    // make checking a lot simpler.

                    if (guess.isNone && solution.noneIsCorrect) {
                        showReal();
                        score.correct = true;
                    } else {
                        score.correct = guess.index === solution.index;
                    }
                } else {
                    // Old solutions just included the solution element, so we
                    // have to use the old checks to see if the solution is
                    // correct
                    // TODO(emily): Remove this backwards compatible code
                    // sometime after 8/2013

                    // Check to see if the "none of the above" answer is
                    // checked
                    if (guess.isNone &&
                            $("#solutionarea").find("ul").data("real-answer") != null) {
                        showReal();
                        score.correct = true;
                    // Otherwise, just compare the text
                    } else if ($.trim(guess.value).replace(/\r\n?|\n/g, "") ===
                               $.trim(correct.replace(/\r\n?|\n/g, ""))) {
                        score.correct = true;
                    } else {
                        score.correct = false;
                    }
                }
                return score;
            };
        }
    },

    /*
     * The list answer type provides a drop-down menu to select from a list of
     * different answers
     *
     * The different choices are stored as an array in the data-choices value
     * of the solution element
     */
    list: {
        setupFunctional: function(solutionarea, solutionText, solutionData) {
            var input = $("<select></select>");
            $(solutionarea).append(input);

            // Get the choices
            var choices = $.tmpl.getVAR(solutionData.choices);
            $.each(choices, function(index, value) {
                // Add each one to the selection
                input.append('<option value="' + value + '">' +
                    value + "</option>");
            });

            return {
                validator: Khan.answerTypes.list.createValidatorFunctional(
                        solutionText, solutionData),
                answer: function() {
                    return input.val();
                },
                solution: $.trim(solutionText),
                examples: [],
                showGuess: function(guess) {
                    input.val(guess === undefined ? "" : guess);
                }
            };
        },
        createValidatorFunctional: function(correct, options) {
            correct = $.trim(correct);

            return function(guess) {
                guess = $.trim(guess);
                return {
                    empty: false,
                    correct: correct === guess,
                    message: null,
                    guess: guess
                };
            };
        }
    },

    /*
     * The custom answer type provides a very general way to create answers,
     * which generally have input methods beyond the answer area, and have to
     * do more complex checking for answers
     *
     * There are 6 elements within the custom solution that are used.
     *
     * The .instruction element is directly copied into the solution area. This
     * is meant for instructions and any extra input needed by the question
     *
     * The .guess element is evaluated as javascript whenever the current
     * answer needs to be checked. Its result is passed in to the validator,
     * and show guess functions.
     *
     * The .validator element is evaluated as javascript with the added guess
     * variable. It should return one of the usual return types depending on
     * whether the answer is correct or not.
     *
     * The .show-guess and .show-guess-solutionarea elements are evaluated as
     * javascript whenever the guess needs to be re-displayed (mostly in the
     * timeline). The .show-guess function should be used to change elements
     * outside of the solutionarea, and the .show-guess-solutionarea one should
     * be used to modify elements within the solutionarea
     *
     * The text of the .example elements are used in the acceptable formats
     * popup
     */
    custom: {
        setup: function(solutionarea, solution) {
            // copy the instruction element into the solution area
            solution.find(".instruction")
                    .appendTo(solutionarea)
                    .runModules();

            // Retrieve some code
            var guessCode = solution.find(".guess").text();
            var showCustomGuessCode = solution.find(".show-guess").text();
            var showGuessCode = solution.find(".show-guess-solutionarea").text();

            return {
                validator: Khan.answerTypes.custom.createValidator(solution),
                answer: function() {
                    // Run the guess code
                    return KhanUtil.tmpl.getVAR(guessCode,
                                                KhanUtil.currentGraph);
                },
                solution: $.trim($(solution).text()),
                examples: solution.find(".example").texCleanup()
                                  .map(function(i, el) {
                    return $(el).html();
                }),
                showCustomGuess: function(guess) {
                    // run the show guess code
                    var code =
                        "(function() { " +
                            "var guess = " + JSON.stringify(guess) + ";" +
                            showCustomGuessCode +
                        "})()";
                    KhanUtil.tmpl.getVAR(code, KhanUtil.currentGraph);
                },
                showGuess: function(guess) {
                    // run the answer area show guess code
                    var code =
                        "(function() { " +
                            "var guess = " + JSON.stringify(guess) + ";" +
                            showGuessCode +
                        "})()";
                    KhanUtil.tmpl.getVAR(code, KhanUtil.currentGraph);
                }
            };
        },
        createValidator: function(solution) {
            // store some code
            var validatorCode = $(solution).find(".validator-function").text();

            var validator = function(guess) {
                // run the validator code
                var code = "(function() { " +
                                "var guess = " + JSON.stringify(guess) + ";" +
                                validatorCode +
                            "})()";
                return KhanUtil.tmpl.getVAR(code, KhanUtil.currentGraph);
            };

            return function(guess) {
                var pass = validator(guess);
                // If `pass` is an object, it's a new-style return type
                if (typeof pass === "object") {
                    return pass;
                } else {
                    // TODO(eater): For now most custom answers use the "old"
                    // true/false/""/"..." return type.
                    return {
                        empty: pass === "",
                        correct: pass === true,
                        message: typeof pass === "string" ? pass : null,
                        guess: guess
                    };
                }
            };
        }
    },

    /*
     * The prime factorization answer type checks whether the correct list of
     * prime factors matches the guess, by ordering the prime factors in
     * ascending order, and placing "x"s between them
     */
    primeFactorization: {
        // Same as the text function, the differences lie in the validator
        // TODO(alpert): Use predicate or something like that?
        setupFunctional: function(solutionarea, solutionText, solutionData) {
            var input;
            if (window.Modernizr && Modernizr.touchevents) {
                // special flag for iOS devices
                input = $('<input type="text" autocapitalize="off">');
            } else {
                input = $('<input type="text">');
            }
            $(solutionarea).append(input);

            return {
                validator: Khan.answerTypes.primeFactorization.createValidatorFunctional(
                        solutionText, solutionData),
                answer: function() {
                    return input.val();
                },
                solution: $.trim(solutionText),
                examples: [
                    $._("a product of prime factors, like <code>2 \\times 3</code>"),
                    $._("a single prime number, like <code>5</code>")
                ],
                showGuess: function(guess) {
                    input.val(guess === undefined ? "" : guess);
                }
            };
        },
        createValidatorFunctional: function(correct, options) {
            correct = $.trim(correct);

            return function(guess) {
                // Get rid of all the whitespace
                guess = guess.split(" ").join("").toLowerCase();
                // Split on x, *, or unicode x
                guess = guess.split(/x|\*|\u00d7/);

                // Replace a^b with b lots of axa
                var terms = [];
                for (var i = 0; i < guess.length; i++) {
                    var t = guess[i].split('^');
                    if (t.length > 1) {
                        for (var j = 0; j < t[1]; j++) {
                            terms.push(t[0]);
                        }
                    } else {
                        terms.push(guess[i]);
                    }
                }

                // Sort, and join with xs
                guess = KhanUtil.sortNumbers(terms).join("x");
                // perform simple string comparison
                return {
                    empty: guess === "",
                    correct: guess === correct,
                    message: null,
                    guess: guess
                };
            };
        }
    },

    /*
     * The checkbox answer type provides a single checkbox, with the solution
     * being true or false
     */
    checkbox: {
        setupFunctional: function(solutionarea, solutionText, solutionData) {
            // Make a checkbox
            var input = $('<input type="checkbox">');
            $(solutionarea).append(input);

            return {
                validator: Khan.answerTypes.checkbox.createValidatorFunctional(
                        solutionText, solutionData),
                answer: function() {
                    // False as "" so that checkIfAnswerEmpty recognizes it as
                    // empty
                    return input.is(":checked") || "";
                },
                solution: $.trim(solutionText),
                examples: [],
                showGuess: function(guess) {
                    input.attr("checked", guess === undefined ? false : guess);
                }
            };
        },
        createValidatorFunctional: function(correct, options) {
            // store whether the correct answer is true or false
            correct = $.trim(correct) === "true";

            return function(guess) {
                var score = {
                    empty: false,
                    correct: false,
                    message: null,
                    guess: guess
                };
                // If checkbox is unchecked, guess will be ""; cast to bool
                /* jshint -W018 */
                if (!!correct === !!guess) {
                /* jshint +W018 */
                    score.correct = true;
                } else if (!guess) {
                    // If unchecked, we'll say that the answer is empty, which
                    // is necessary to ensure that a new question with
                    // checkboxes counts as empty. Empty in a multiple grades
                    // as false though so this shouldn't have any adverse
                    // effects.
                    score.empty = true;
                } else {
                    score.correct = false;
                }
                return score;
            };
        }
    },

    /*
     * The expression answer type parses a given expression or equation
     * and semantically compares it to the solution. In addition, instant
     * feedback is provided by rendering the last answer that fully parsed.
     *
     * Parsing options:
     * functions (e.g. data-functions="f g h")
     *     A space or comma separated list of single-letter variables that
     *     should be interpreted as functions. Case sensitive. "e" and "i"
     *     are reserved.
     *
     *     no functions specified: f(x+y) == fx + fy
     *     with "f" as a function: f(x+y) != fx + fy
     *
     * Comparison options:
     * same-form (e.g. data-same-form)
     *     If present, the answer must match the solution's structure in
     *     addition to evaluating the same. Commutativity and excess negation
     *     are ignored, but all other changes will trigger a rejection. Useful
     *     for requiring a particular form of an equation, or if the answer
     *     must be factored.
     *
     *     example question:    Factor x^2 + x - 2
     *     example solution:    (x-1)(x+2)
     *     accepted answers:    (x-1)(x+2), (x+2)(x-1), ---(-x-2)(-1+x), etc.
     *     rejected answers:    x^2+x-2, x*x+x-2, x(x+1)-2, (x-1)(x+2)^1, etc.
     *     rejection message:   Your answer is not in the correct form
     *
     * simplify (e.g. data-simplify)
     *     If present, the answer must be fully expanded and simplified. Use
     *     carefully - simplification is hard and there may be bugs, or you
     *     might not agree on the definition of "simplified" used. You will
     *     get an error if the provided solution is not itself fully expanded
     *     and simplified.
     *
     *     example question:    Simplify ((n*x^5)^5) / (n^(-2)*x^2)^-3
     *     example solution:    x^31 / n
     *     accepted answers:    x^31 / n, x^31 / n^1, x^31 * n^(-1), etc.
     *     rejected answers:    (x^25 * n^5) / (x^(-6) * n^6), etc.
     *     rejection message:   Your answer is not fully expanded and simplified
     *
     * Rendering options:
     * times (e.g. data-times)
     *     If present, explicit multiplication (such as between numbers) will
     *     be rendered with a cross/x symbol (TeX: \times) instead of the usual
     *     center dot (TeX: \cdot).
     *
     *     normal rendering:    2 * 3^x -> 2 \cdot 3^{x}
     *     but with "times":    2 * 3^x -> 2 \times 3^{x}
     */
    expression: {
        setupFunctional: function(solutionarea, solutionText, solutionData) {

            // Convert options to a form KAS can understand
            var options = {
                form: solutionData.sameForm != null,
                simplify: solutionData.simplify != null,
                times: solutionData.times != null
            };

            if (solutionData.functions) {
                options.functions = _.compact(
                    solutionData.functions.split(/[ ,]+/));
            }

            // Check immediately if the provided solution is valid
            var solution = KAS.parse(solutionText, options);
            if (!solution.parsed) {
                throw new Error("The provided solution (" + solutionText +
                    ") didn't parse.");
            } else if (options.simplified && !solution.expr.isSimplified()) {
                throw new Error("The provided solution (" + solutionText +
                    ") isn't fully expanded and simplified.");
            } else {
                solution = solution.expr;
            }

            // Assemble the solution area
            var $input = $('<input type="text">');
            var $tex = $('<span class="tex"/>');
            var $error = $('<span class="error"/>').append(
                $('<span class="buddy"/>'),
                $('<span class="message">Sorry, I don\'t understand that!</span>')
            );

            $(solutionarea).append(
                $('<span class="expression"/>').append(
                    $input,
                    $('<span class="output"/>').append(
                        $tex,
                        $('<span class="placeholder"/>').append(
                            $error
                        )
                    )
                )
            );

            // Specify how instant render (and error message) should update
            var errorTimeout = null;
            var lastParsedTex = "";

            var update = function() {
                clearTimeout(errorTimeout);
                var result = KAS.parse($input.val(), options);
                if (result.parsed) {
                    hideError();
                    $tex.css({opacity: 1.0});
                    var tex = result.expr.asTex(options);
                    if (tex !== lastParsedTex) {
                        $tex.empty().append($("<code>").text(tex)).tex();
                        lastParsedTex = tex;
                    }
                } else {
                    errorTimeout = setTimeout(showError, 2000);
                    $tex.css({opacity: 0.5});
                }
            };

            var showError = function() {
                if (!$error.is(":visible")) {
                    $error.css({ top: 50, opacity: 0.1 }).show()
                        .animate({ top: 0, opacity: 1.0 }, 300);
                }
            };

            var hideError = function() {
                if ($error.is(":visible")) {
                    $error.animate({ top: 50, opacity: 0.1 }, 300, function() {
                        $(this).hide();
                    });
                }
            };

            // Define event handlers
            $input.on("input propertychange", update);

            $input.on("keydown", function(event) {
                var input = $input[0];

                var start = input.selectionStart;
                var end = input.selectionEnd;
                var supported = start !== undefined;

                if (supported && event.which === 8 /* backspace */) {
                    var val = input.value;
                    if (start === end && val.slice(start - 1, start + 1) === "()") {
                        // "f(|)" + backspace -> "f|" (| is the cursor position)
                        event.preventDefault();
                        input.value = val.slice(0, start - 1) + val.slice(start + 1);
                        input.selectionStart = start - 1;
                        input.selectionEnd = end - 1;
                        update();
                    }
                }
            });

            $input.on("keypress", function(event) {
                var input = $input[0];

                var start = input.selectionStart;
                var end = input.selectionEnd;
                var supported = start !== undefined;

                if (supported && event.which === 40 /* left paren */) {
                    var val = input.value;
                    event.preventDefault();

                    if (start === end) {
                        // "f|" + "(" -> "f(|)"
                        var insertMatched = _.any([" ", ")", ""], function(c) {
                            return val.charAt(start) === c;
                        });

                        input.value = val.slice(0, start) +
                                (insertMatched ? "()" : "(") + val.slice(end);
                    } else {
                        // "f|x+y|" + "(" -> "f(|x+y|)"
                        input.value = val.slice(0, start) +
                                "(" + val.slice(start, end) + ")" + val.slice(end);
                    }

                    input.selectionStart = start + 1;
                    input.selectionEnd = end + 1;
                    update();

                } else if (supported && event.which === 41 /* right paren */) {
                    var val = input.value;
                    if (start === end && val.charAt(start) === ")") {
                        // f(|) + ")" -> "f()|"
                        event.preventDefault();
                        input.selectionStart = start + 1;
                        input.selectionEnd = end + 1;
                        update();
                    }
                }
            });

            // Examples
            var explicitMul = $._("For <code>2\\cdot2</code>, enter <strong>2*2</strong>");
            if (options.times) {
                explicitMul = explicitMul.replace(/\\cdot/g, "\\times");
            }

            return {
                validator: Khan.answerTypes.expression.createValidatorFunctional(
                        solution, options),
                answer: function() { return $input.val(); },
                solution: solution.print(),
                examples: [
                    explicitMul,
                    $._("For <code>3y</code>, enter <strong>3y</strong> or <strong>3*y</strong>"),
                    $._("For <code>\\dfrac{1}{x}</code>, enter <strong>1/x</strong>"),
                    $._("For <code>x^{y}</code>, enter <strong>x^y</strong>"),
                    $._("For <code>\\sqrt{x}</code>, enter <strong>sqrt(x)</strong>"),
                    $._("For <code>\\pi</code>, enter <strong>pi</strong>"),
                    $._("For <code>\\sin \\theta</code>, enter <strong>sin(theta)</strong>"),
                    $._("For <code>\\le</code> or <code>\\ge</code>, enter <strong><=</strong> or <strong>>=</strong>"),
                    $._("For <code>\\neq</code>, enter <strong>=/=</strong>")
                ],
                showGuess: function(guess) {
                    $input.val(guess === undefined ? "" : guess);
                }
            };
        },
        createValidatorFunctional: function(solution, options) {
            return function(guess) {
                var score = {
                    empty: false,
                    correct: false,
                    message: null,
                    guess: guess
                };
                // Don't bother parsing an empty input
                if (!guess) {
                    score.empty = true;
                    return score;
                }

                var answer = KAS.parse(guess, options);

                // An unsuccessful parse doesn't count as wrong
                if (!answer.parsed) {
                    score.empty = true;
                    return score;
                }

                var result = KAS.compare(answer.expr, solution, options);

                if (result.equal) {
                    // Correct answer
                    score.correct = true;
                } else if (result.message) {
                    // Nearly correct answer
                    score.message = result.message;
                } else {
                    // Replace x with * and see if it would have been correct
                    var answerX = KAS.parse(guess.replace(/[xX]/g, "*"), options);
                    if (answerX.parsed) {
                        var resultX = KAS.compare(answerX.expr, solution, options);
                        if (resultX.equal) {
                            score.empty = true;
                            score.message = "I'm a computer. I only " +
                                    "understand multiplication if you use an " +
                                    "asterisk (*) as the multiplication sign.";
                        } else if (resultX.message) {
                            score.message = resultX.message + " Also, " +
                                    "I'm a computer. I only " +
                                    "understand multiplication if you use an " +
                                    "asterisk (*) as the multiplication sign.";
                        }
                    }
                }
                return score;
            };
        }
    }
});

/**
 * Return a new answer type that uses number but with the passed-in forms only.
 */
function numberAnswerType(forms) {
    return {
        setupFunctional: function(solutionarea, solutionText, solutionData) {
            return Khan.answerTypes.number.setupFunctional(
                    solutionarea,
                    solutionText,
                    $.extend({}, solutionData, {forms: forms}));
        },
        createValidatorFunctional: function(correct, options) {
            return Khan.answerTypes.number.createValidatorFunctional(
                    correct,
                    $.extend({}, options, {forms: forms}));
        }
    };
}

_.each(Khan.answerTypes, function(info, type) {
    if (!("setup" in info)) {
        info.setup = function(solutionarea, solution) {
            var $solution = $(solution);
            return info.setupFunctional(
                    solutionarea, $solution.text(), $solution.data());
        };
    }

    if (!("createValidator" in info)) {
        info.createValidator = function(solution) {
            var $solution = $(solution);
            return info.createValidatorFunctional(
                    $solution.text(), $solution.data());
        };
    }
});

});

define('utils/tex.js',['require'],function(require) {

function findChildOrAdd(elem, className) {
    var $child = $(elem).find("." + className);
    if ($child.length === 0) {
        return $("<span>").addClass(className).appendTo($(elem));
    } else {
        return $child;
    }
}

function doCallback(elem, callback) {
    var tries = 0;
    (function check() {
        var height = elem.scrollHeight;
        // Heuristic to guess if the font has kicked in
        // so we have box metrics (magic number ick,
        // but this seems to work mostly-consistently)
        if (height > 18 || tries >= 10) {
            callback();
        } else {
            tries++;
            setTimeout(check, 100);
        }
    })();
}


$.extend(KhanUtil, {
    // Process a node and add math inside of it. This attempts to use KaTeX to
    // format the math, and if that fails it falls back to MathJax.
    //
    // elem: The element which the math should be added to.
    //
    // text: The text that should be formatted inside of the node. If the node
    //       has already had math formatted inside of it before, this doesn't
    //       have to be provided. If this is not provided, and the node hasn't
    //       been formatted before, the text content of the node is used.
    //
    // force: (optional) if the node has been processed before, then it will
    //        not be formatted again, unless this argument is true
    //
    // callback: (optional) a callback to be run after the math has been
    //           processed (note: this might be called synchronously or
    //           asynchronously, depending on whether KaTeX or MathJax is used)
    processMath: function(elem, text, force, callback) {
        var $elem = $(elem);

        // Only process if it hasn't been done before, or it is forced
        if ($elem.attr("data-math-formula") == null || force) {
            var $katexHolder = findChildOrAdd($elem, "katex-holder");
            var $mathjaxHolder = findChildOrAdd($elem, "mathjax-holder");

            // Search for MathJax-y script tags inside of the node. These are
            // used by MathJax to denote the formula to be typeset. Before, we
            // would update the formula by updating the contents of the script
            // tag, which shouldn't happen any more, but we manage them just in
            // case.
            var script = $mathjaxHolder.find("script[type='math/tex']")[0];

            // If text wasn't provided, we look in two places
            if (text == null) {
                if ($elem.attr("data-math-formula")) {
                    // The old typeset formula
                    text = $elem.attr("data-math-formula");
                } else if (script) {
                    // The contents of the <script> tag
                    text = script.text || script.textContent;
                }
            }

            text = text != null ? text + "" : "";

            // Attempt to clean up some of the math
            if (KhanUtil.cleanMath) {
                text = KhanUtil.cleanMath(text);
            }

            // Store the formula that we're using
            $elem.attr("data-math-formula", text);

            if (Exercises.useKatex) {
                // Try to process the nodes with KaTeX first
                try {
                    katex.process(text, $katexHolder[0]);
                    // If that worked, and we previously formatted with
                    // mathjax, do some mathjax cleanup
                    if ($elem.attr("data-math-type") === "mathjax") {
                        // Remove the old mathjax stuff
                        var jax = MathJax.Hub.getJaxFor(script);
                        if (jax) {
                            var e = jax.SourceElement();
                            if (e.previousSibling &&
                                    e.previousSibling.className) {
                                jax.Remove();
                            }
                        }
                    }
                    $elem.attr("data-math-type", "katex");
                    // Call the callback
                    if (callback) {
                        doCallback(elem, callback);
                    }
                    return;
                } catch (err) {
                    // IE doesn't do instanceof correctly, so we resort to
                    // manual checking
                    /* jshint -W103 */
                    if (err.__proto__ !== katex.ParseError.prototype) {
                        throw err;
                    }
                    /* jshint +W103 */
                }
            }

            // Otherwise, fallback to MathJax

            // (Note: we don't need to do any katex cleanup here, because
            // KaTeX is smart and cleans itself up)
            $elem.attr("data-math-type", "mathjax");
            // Update the script tag, or add one if necessary
            if (!script) {
                $mathjaxHolder.append("<script type='math/tex'>" +
                        text.replace(/<\//g, "< /") + "</script>");
            } else {
                if ("text" in script) {
                    // IE8, etc
                    script.text = text;
                } else {
                    script.textContent = text;
                }
            }
            if (typeof MathJax !== "undefined") {
                // Put the process, a debug log, and the callback into the
                // MathJax queue
                MathJax.Hub.Queue(["Reprocess", MathJax.Hub,
                    $mathjaxHolder[0]]);
                MathJax.Hub.Queue(function() {
                    KhanUtil.debugLog("MathJax done typesetting (" + text +
                            ")");
                });
                if (callback) {
                    MathJax.Hub.Queue(function() {
                        var cb = MathJax.Callback(function() {});
                        doCallback(elem, function() {
                            callback();
                            cb();
                        });
                        return cb;
                    });
                }
            }
        }
    },

    processAllMath: function(elem, force) {
        var $elem = $(elem);
        $elem.filter("code").add($elem.find("code")).each(function() {
            var $this = $(this);
            var text = $this.attr("data-math-formula");
            if (text == null) {
                text = $this.text();
                $this.empty();
            }
            KhanUtil.processMath(this, text, force);
        });
    },

    // Function to restore a node to a non-math-processed state
    cleanupMath: function(elem) {
        var $elem = $(elem);

        // Only mess with it if it's been processed before
        if ($elem.attr("data-math-formula")) {
            // Remove MathJax remnants
            if (typeof MathJax !== "undefined") {
                var jax = MathJax.Hub.getJaxFor($elem.find("script")[0]);
                if (jax) {
                    var e = jax.SourceElement();
                    if (e.previousSibling && e.previousSibling.className) {
                        jax.Remove();
                    }
                }
            }

            $elem.text($elem.attr("data-math-formula"));
            $elem.attr("data-math-formula", null);
            $elem.attr("data-math-type", null);
        }

        return elem;
    },

    // Function to retrieve the formula of a typeset math node
    retrieveMathFormula: function(elem) {
        return $(elem).attr("data-math-formula");
    }
});

$.fn.tex = function() {
    KhanUtil.processAllMath(this, false);

    return this;
};

$.fn.texCleanup = function() {
    this.filter("code").add(this.find("code")).each(function() {
        KhanUtil.cleanupMath(this);
    });

    return this;
};

});

define('utils/tmpl.js',['require','./crc32.js'],function(require) {

var crc32 = require("./crc32.js");

var localMode;

// Keep the template variables private, to prevent external access
var VARS = {};

$.tmpl = {
    DATA_ENSURE_LOOPS: 0,

    // Processors that act based on element attributes
    attr: {
        "data-ensure": function(elem, ensure) {
            // Returns a function in order to run after other templating and var assignment
            return function(elem) {
                // Return a boolean corresponding to the ensure's value
                // False means all templating will be run again, so new values will be chosen
                var result = !!(ensure && $.tmpl.getVAR(ensure));
                if (!result) {
                    if ($.tmpl.DATA_ENSURE_LOOPS++ > 10000 && localMode) {
                        // Shucks, probably not possible. Just give up in order
                        // to not hang the dev's browser.
                        alert("unsatisfiable data-ensure?");
                        return true;
                    }
                }
                return result;
            };
        },

        "data-if": function(elem, value) {
            var $elem = $(elem);

            value = value && $.tmpl.getVAR(value);

            // Save the result of this data-if in the next sibling for data-else-if and data-else
            // Only save the value if no previous value has been set
            var $nextElem = $elem.next();
            if ($nextElem.data("lastCond") === undefined) {
                $nextElem.data("lastCond", value);
            }

            if (!value) {
                // Delete the element if the data-if evaluated to false
                return [];
            }
        },

        "data-else-if": function(elem, value) {
            var $elem = $(elem);

            var lastCond = $elem.data("lastCond");

            // Show this element iff the preceding element was hidden AND this data-if returns truthily
            value = !lastCond && value && $.tmpl.getVAR(value);

            // Succeeding elements care about the visibility of both me and my preceding siblings
            // Only save the value if no previous value has been set
            var $nextElem = $elem.next();
            if ($nextElem.data("lastCond") === undefined) {
                $nextElem.data("lastCond", lastCond || value);
            }

            if (!value) {
                // Delete the element if appropriate
                return [];
            }
        },

        "data-else": function(elem) {
            var $elem = $(elem);

            if ($elem.data("lastCond")) {
                // Delete the element if the data-if of the preceding element was true
                return [];
            }
        },

        "data-each": function(elem, value) {
            var match;

            // Remove the data-each attribute so it doesn't end up in the generated elements
            $(elem).removeAttr("data-each");

            // HINT_COUNT times
            // HINT_COUNT times as INDEX
            if ((match = /^(.+) times(?: as (\w+))?$/.exec(value))) {
                var times = $.tmpl.getVAR(match[1]);

                return {
                    items: $.map(new Array(times), function(e, i) { return i; }),
                    value: match[2],
                    oldValue: VARS[match[2]]
                };

            // Extract the 1, 2, or 3 parts of the data-each attribute, which could be
            //   - items
            //   - items as value
            //   - items as pos, value
            } else if ((match = /^(.*?)(?: as (?:(\w+), )?(\w+))?$/.exec(value))) {
                // See "if (ret.items)" in traverse() for the other half of the data-each code
                return {
                    // The collection which we'll iterate through
                    items: $.tmpl.getVAR(match[1]),

                    // "value" and "pos" as strings
                    value: match[3],
                    pos: match[2],

                    // Save the values of the iterator variables so we don't permanently overwrite them
                    oldValue: VARS[match[3]],
                    oldPos: VARS[match[2]]
                };
            }
        },

        "data-unwrap": function(elem) {
            return $(elem).contents();
        },

        "data-video-hint": function(elem) {
            var youtubeIds = $(elem).data("youtube-id");
            if (!youtubeIds) {
                return;
            }

            youtubeIds = youtubeIds.split(/,\s*/);

            var author = $(elem).data("video-hint-author") || "Sal";
            var msg = $._("Watch %(author)s work through a very similar " +
                "problem:", {author: author});
            var preface = $("<p>").text(msg);

            var wrapper = $("<div>", { "class": "video-hint" });
            wrapper.append(preface);

            _.each(youtubeIds, function(youtubeId) {
                var href = "http://www.khanacademy.org/embed_video?v=" +
                            youtubeId;
                var iframe = $("<iframe>").attr({
                    "frameborder": "0",
                    "scrolling": "no",
                    "width": "100%",
                    "height": "360px",
                    "src": href
                });

                wrapper.append(iframe);
            });

            return wrapper;
        }

    },

    // Processors that act based on tag names
    type: {
        "var": function(elem, value) {
            // When called by process(), value is undefined

            // If the <var> has any child elements, run later with the innerHTML
            // Use $ instead of getElementsByTagName to exclude comment nodes in IE
            if (!value && $(elem).children().length > 0) {
                return function(elem) {
                    return $.tmpl.type["var"](elem, elem.innerHTML);
                };
            }

            // Evaluate the contents of the <var> as a JS string
            value = value || $.tmpl.getVAR(elem);

            // If an ID was specified then we're going to save the value
            var name = elem.id;
            if (name) {

                // Utility function for VARS[name] = value, warning if the name overshadows a KhanUtil property
                var setVAR = function(name, value) {
                    if (KhanUtil[name]) {
                        Khan.error("Defining variable '" + name + "' overwrites utility property of same name.");
                    }

                    VARS[name] = value;
                };

                // Destructure the array if appropriate
                if (name.indexOf(",") !== -1) {
                    // Nested arrays are not supported
                    var parts = name.split(/\s*,\s*/);

                    $.each(parts, function(i, part) {
                        // Ignore empty parts
                        if (part.length > 0) {
                            setVAR(part, value[i]);
                        }
                    });

                // Just a normal assignment
                } else {
                    setVAR(name, value);
                }

            // No value was specified so we replace it with a text node of the value
            } else {
                if (value == null) {
                    // Don't show anything
                    return [];
                } else {
                    // Convert the value to a string and replace with those elements and text nodes
                    // Add a space so that it can end with a "<" in Safari
                    var div = $("<div>");
                    var html = div.append(value + " ").html();
                    return div.html(html.slice(0, -1)).contents();
                }
            }
        }
    },

    // Eval a string in the context of Math, KhanUtil, VARS, and optionally another passed context
    getVAR: function(elem, ctx) {
        // We need to compute the value
        var code = elem.nodeName ? $(elem).text() : elem;

        // If no extra context was passed, use an empty object
        if (ctx == null) {
            ctx = {};
        }

        function doEval() {
            /* jshint -W085 */
            // Use the methods from JavaScript's built-in Math methods
            with (Math) {
                // And the methods provided by the library
                with (KhanUtil) {
                    // And the passed-in context
                    with (ctx) {
                        // And all the computed variables
                        with (VARS) {
                            return eval("(function() { return (" + code + "); })()");
                        }
                    }
                }
            }
            /* jshint +W085 */
        }

        if (Khan.query.debug != null) {
            // Skip try-catch in debug mode so that the script panel works
            return doEval();
        } else {
            try {
                return doEval();
            } catch (e) {
                var info;

                if (elem.nodeName) {
                    info = elem.nodeName.toLowerCase();

                    if (elem.id != null && elem.id.length > 0) {
                        info += "#" + elem.id;
                    }
                } else {
                    info = JSON.stringify(code);
                }

                Khan.error("Error while evaluating " + info, e);
            }
        }
    },

    /**
     * Get a hash of the problem variables for duplication detection purposes.
     */
    // TODO(david): Allow exercise developers to specify which variables are not
    //     important for duplicate determination purposes.
    // TODO(david): Just a possibility, but allow exercise developers to specify
    //     their own variable hash function, so that, eg. for addition 1, 2 + 3
    //     could hash to the same value as 3 + 2.
    getVarsHash: function() {
        // maybe TODO(david): Can base-64 encode the crc32 integer if we want to
        //     save a few bytes, since localStorage stores strings only.

        // Just convert top-level values to strings instead of recursively
        // stringifying, due to issues with circular references.
        return crc32(JSON.stringify($.map(VARS, function(value, key) {
            return [key, String(value)];
        })));
    }
};

if (typeof KhanUtil !== "undefined") {
    KhanUtil.tmpl = $.tmpl;
}

// Reinitialize VARS for each problem
$.fn.tmplLoad = function(problem, info) {
    VARS = {};
    $.tmpl.DATA_ENSURE_LOOPS = 0;

    localMode = info.localMode;

    // Expose the variables if we're in local mode
    if (localMode) {
        $.tmpl.VARS = VARS;
    }
};

$.fn.tmpl = function() {
    // Call traverse() for each element in the $ object
    for (var i = 0, l = this.length; i < l; i++) {
        traverse(this[i]);
    }

    return this;

    // Walk through the element and its descendants, process()-ing each one using the processors defined above
    function traverse(elem) {
        // Array of functions to run after doing the rest of the processing
        var post = [],

            // Live NodeList of child nodes to traverse if we don't remove/replace this element
            child = elem.childNodes,

            // Result of running the attribute and tag processors on the element
            ret = process(elem, post);

        // If false, rerun all templating (like data-ensure)
        if (ret === false) {
            return traverse(elem);

        // If undefined, do nothing
        } else if (ret === undefined) {

        // If a (possibly-empty) array of nodes, replace this one with those
        // The type of ret is checked to ensure it is not a function
        } else if (typeof ret === "object" && typeof ret.length !== "undefined") {
            if (elem.parentNode) {
                // All nodes must be inserted before any are traversed
                $.each(ret, function(i, rep) {
                    if (rep.nodeType) {
                        elem.parentNode.insertBefore(rep, elem);
                    }
                });

                $.each(ret, function(i, rep) {
                    traverse(rep);
                });

                elem.parentNode.removeChild(elem);
            }

            return null;

        // If { items: ... }, this is a data-each loop
        } else if (ret.items) {
            // We need these references to insert the elements in the appropriate places
            var origParent = elem.parentNode,
                origNext = elem.nextSibling;

            // Loop though the given array
            $.each(ret.items, function(pos, value) {
                // Set the value if appropriate
                if (ret.value) {
                    VARS[ret.value] = value;
                }

                // Set the position if appropriate
                if (ret.pos) {
                    VARS[ret.pos] = pos;
                }

                // Do a deep clone (including event handlers and data) of the element
                var clone = $(elem).clone(true)
                    .removeAttr("data-each").removeData("each")[0];

                // Prepend all conditional statements with a declaration of ret.value
                // and ret.post and an assignment of their current values so that
                // the conditional will still make sense even when outside of the
                // data-each context
                var conditionals = ["data-if", "data-else-if", "data-else"];

                var declarations = "";
                declarations += (ret.pos) ? "var " + ret.pos + " = " + JSON.stringify(pos) + ";" : "";
                declarations += (ret.value) ? "var " + ret.value + " = " + JSON.stringify(value) + ";" : "";

                for (var i = 0; i < conditionals.length; i++) {
                    var conditional = conditionals[i];
                    $(clone).find("[" + conditional + "]").each(function() {
                        var code = $(this).attr(conditional);
                        code = "(function() { " + declarations + " return " + code + " })()";
                        $(this).attr(conditional, code);
                    });
                }

                // Do the same for graphie code
                $(clone).find(".graphie").addBack().filter(".graphie").each(function() {
                    var code = $(this).text();
                    $(this).text(declarations + code);
                });

                // Insert in the proper place (depends on whether the loops is the last of its siblings)
                if (origNext) {
                    origParent.insertBefore(clone, origNext);
                } else {
                    origParent.appendChild(clone);
                }

                // Run all templating on the new element
                traverse(clone);
            });

            // Restore the old value of the value variable, if it had one
            if (ret.value) {
                VARS[ret.value] = ret.oldValue;
            }

            // Restore the old value of the position variable, if it had one
            if (ret.pos) {
                VARS[ret.pos] = ret.oldPos;
            }

            // Remove the loop element and its handlers now that we've processed it
            $(elem).remove();

            // Say that the element was removed so that child traversal doesn't skip anything
            return null;
        }

        // Loop through the element's children if it was not removed
        for (var i = 0; i < child.length; i++) {
            // Traverse the child; decrement the counter if the child was removed
            if (child[i].nodeType === 1 && traverse(child[i]) === null) {
                i--;
            }
        }

        // Run through each post-processing function
        for (var i = 0, l = post.length; i < l; i++) {
            // If false, rerun all templating (for data-ensure and <code> math)
            if (post[i](elem) === false) {
                return traverse(elem);
            }
        }

        return elem;
    }

    // Run through the attr and type processors, return as soon as one of them is decisive about a plan of action
    function process(elem, post) {
        var ret,
            $elem = $(elem);

        // Look through each of the attr processors, see if our element has the matching attribute
        for (var attr in $.tmpl.attr) {
            if ($.tmpl.attr.hasOwnProperty(attr)) {
                var value;

                if ((/^data-/).test(attr)) {
                    value = $elem.data(attr.replace(/^data-/, ""));
                } else {
                    value = $elem.attr(attr);
                }

                if (value !== undefined) {
                    ret = $.tmpl.attr[attr](elem, value);

                    // If a function, run after all of the other templating
                    if (typeof ret === "function") {
                        post.push(ret);

                    // Return anything else (boolean, array of nodes for replacement, object for data-each)
                    } else if (ret !== undefined) {
                        return ret;
                    }
                }
            }
        }

        // Look up the processor based on the tag name
        var type = elem.nodeName.toLowerCase();
        if ($.tmpl.type[type] != null) {
            ret = $.tmpl.type[type](elem);

            // If a function, run after all of the other templating
            if (typeof ret === "function") {
                post.push(ret);
            }
        }

        return ret;
    }
};

$.extend($.expr[":"], {
    inherited: function(el) {
        return $(el).data("inherited");
    }
});

$.fn.extend({
    tmplApply: function(options) {
        options = options || {};

        // Get the attribute which we'll be checking, defaults to "id"
        // but "class" is sometimes used
        var attribute = options.attribute || "id",

            // Figure out the way in which the application will occur
            defaultApply = options.defaultApply || "replace",

            // Store for elements to be used later
            parent = {};

        return this.each(function() {
            var $this = $(this),
                name = $this.attr(attribute),
                hint = $this.data("apply") && !$this.data("apply").indexOf("hint");

            // Only operate on the element if it has the attribute that we're using
            if (name) {
                // The inheritance only works if we've seen an element already
                // that matches the particular name and we're not looking at hint
                // templating
                if (name in parent && !hint) {
                    // Get the method through which we'll be doing the application
                    // You can specify an application style directly on the sub-element
                    parent[name] = $.tmplApplyMethods[$this.data("apply") || defaultApply]

                        // Call it with the context of the parent and the sub-element itself
                        .call(parent[name], this);

                    if (parent[name] == null) {
                        delete parent[name];
                    }

                // Store the parent element for later use if it was inherited from somewhere else
                } else if ($this.closest(":inherited").length > 0) {
                    parent[name] = this;
                }
            }
        });
    }
});

$.extend({
    // These methods should be called with context being the parent
    // and first argument being the child.
    tmplApplyMethods: {
        // Removes both the parent and the child
        remove: function(elem) {
            $(this).remove();
            $(elem).remove();
        },

        // Replaces the parent with the child
        replace: function(elem) {
            $(this).replaceWith(elem);
            return elem;
        },

        // Replaces the parent with the child's content. Useful when
        // needed to replace an element without introducing additional
        // wrappers.
        splice: function(elem) {
            $(this).replaceWith($(elem).contents());
        },

        // Appends the child element to the parent element
        append: function(elem) {
            $(this).append(elem);
            return this;
        },

        // Appends the child element's contents to the parent element.
        appendContents: function(elem) {
            $(this).append($(elem).contents());
            $(elem).remove();
            return this;
        },

        // Prepends the child element to the parent.
        prepend: function(elem) {
            $(this).prepend(elem);
            return this;
        },

        // Prepends the child element's contents to the parent element.
        prependContents: function(elem) {
            $(this).prepend($(elem).contents());
            $(elem).remove();
            return this;
        },

        // Insert child before the parent.
        before: function(elem) {
            $(this).before(elem);
            return this;
        },

        // Insert child's contents before the parent.
        beforeContents: function(elem) {
            $(this).before($(elem).contents());
            $(elem).remove();
            return this;
        },

        // Insert child after the parent.
        after: function(elem) {
            $(this).after(elem);
            return this;
        },

        // Insert child's contents after the parent.
        afterContents: function(elem) {
            $(this).after($(elem).contents());
            $(elem).remove();
            return this;
        },

        // Like appendContents but also merges the data-ensures
        appendVars: function(elem) {
            var parentEnsure = $(this).data("ensure") || "1";
            var childEnsure = $(elem).data("ensure") || "1";
            $(this).data("ensure",
                "(" + parentEnsure + ") && (" + childEnsure + ")");

            return $.tmplApplyMethods.appendContents.call(this, elem);
        },

        // Like prependContents but also merges the data-ensures
        prependVars: function(elem) {
            var parentEnsure = $(this).data("ensure") || "1";
            var childEnsure = $(elem).data("ensure") || "1";
            $(this).data("ensure",
                "(" + childEnsure + ") && (" + parentEnsure + ")");

            return $.tmplApplyMethods.prependContents.call(this, elem);
        }
    }
});

});

(function(root) {
define("utils/jquery.adhesion.js", [], function() {
  return (function() {
(function($) {
    $.fn.adhere = function(options) {
        options = $.extend({
            container: null,
            topMargin: 0,
            bottomMargin: 0
        }, options);

        var container = $(options.container).eq(0);

        $(this).each(function() {
            var el = $(this);
            var data = el.data("adhesion");
            var updateDimensions = (data != null);

            if (data == null) {
                data = {};
                el.data("adhesion", data);
            }

            var shim = data.shim != null ? data.shim : $("<div>");

            shim.css({
                margin: 0,
                padding: 0,
                border: 0
            });

            if (updateDimensions) {
                if (data.scrollHandler != null) {
                    data.scrollHandler();
                }

                return;
            }

            el.before(shim);
            el.parent().css("position", "relative");
            var state = "unstuck";
            var height;

            var stick = function(update) {
                if (state === "stuck" && update !== true) {
                    return;
                }

                shim.height(height);
                el.parent().height("auto");

                el.css({
                    position: "fixed",
                    top: options.topMargin,
                    bottom: "auto",
                    left: el.parent().offset().left,
                    width: shim.width()
                });

                state = "stuck";
            };

            var unstick = function() {
                if (state === "unstuck") {
                    return;
                }

                shim.height(0);
                el.parent().height("auto");

                el.css({
                    position: "static",
                    width: "auto"
                });

                state = "unstuck";
            };

            var bottom = function() {
                if (state === "bottom") {
                    return;
                }

                shim.height(0);
                el.parent().height(container.height());

                el.css({
                    position: "absolute",
                    top: "auto",
                    bottom: 0,
                    left: "auto",
                    width: shim.width()

                });

                state = "bottom";
            };

            var scrollHandler = function(update) {
                var scrollTop = $(window).scrollTop();
                var windowHeight = $(window).height();
                var containerOffset = container.offset();
                var containerHeight = container.outerHeight();
                height = el.outerHeight(true);

                var containerScrolledTop = containerOffset.top - scrollTop;
                var containerScrolledBottom = containerScrolledTop + containerHeight;

                var elFixedBottom = height + options.topMargin + options.bottomMargin;
                var shimRight = shim.offset().left + shim.outerWidth();

                if (elFixedBottom < windowHeight && containerScrolledTop - options.topMargin < 0 && shimRight <= $(window).width()) {
                    if (elFixedBottom < containerScrolledBottom) {
                        stick(update);
                    } else {
                        bottom();
                    }
                } else {
                    unstick();
                }
            };

            var resizeHandler = function() {
                scrollHandler(true);
            };

            data.scrollHandler = scrollHandler;

            $(window).scroll(scrollHandler);
            $(window).resize(resizeHandler);
        });
    };
})(jQuery);


  }).apply(root, arguments);
});
}(this));

(function(root) {
define("genfiles/calculator.js", [], function() {
  return (function() {
/* parser generated by jison 0.4.13 */
/*
  Returns a Parser object of the following structure:

  Parser: {
    yy: {}
  }

  Parser.prototype: {
    yy: {},
    trace: function(),
    symbols_: {associative list: name ==> number},
    terminals_: {associative list: number ==> name},
    productions_: [...],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),
    table: [...],
    defaultActions: {...},
    parseError: function(str, hash),
    parse: function(input),

    lexer: {
        EOF: 1,
        parseError: function(str, hash),
        setInput: function(input),
        input: function(),
        unput: function(str),
        more: function(),
        less: function(n),
        pastInput: function(),
        upcomingInput: function(),
        showPosition: function(),
        test_match: function(regex_match_array, rule_index),
        next: function(),
        lex: function(),
        begin: function(condition),
        popState: function(),
        _currentRules: function(),
        topState: function(),
        pushState: function(condition),

        options: {
            ranges: boolean           (optional: true ==> token location info will include a .range[] member)
            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)
            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)
        },

        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),
        rules: [...],
        conditions: {associative list: name ==> set},
    }
  }


  token location info (@$, _$, etc.): {
    first_line: n,
    last_line: n,
    first_column: n,
    last_column: n,
    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)
  }


  the parseError function receives a 'hash' object with these members for lexer and parser errors: {
    text:        (matched text)
    token:       (the produced terminal token, if any)
    line:        (yylineno)
  }
  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {
    loc:         (yylloc)
    expected:    (string describing the set of expected tokens)
    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)
  }
*/
var Calculator = (function(){
var parser = {trace: function trace() { },
yy: {},
symbols_: {"error":2,"expressions":3,"e":4,"EOF":5,"+":6,"-":7,"*":8,"/":9,"^":10,"!":11,"FN":12,"(":13,")":14,"E":15,"PI":16,"ANS":17,"NUM":18,"$accept":0,"$end":1},
terminals_: {2:"error",5:"EOF",6:"+",7:"-",8:"*",9:"/",10:"^",11:"!",12:"FN",13:"(",14:")",15:"E",16:"PI",17:"ANS",18:"NUM"},
productions_: [0,[3,2],[4,3],[4,3],[4,3],[4,3],[4,3],[4,2],[4,2],[4,4],[4,3],[4,1],[4,1],[4,1],[4,1]],
performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {
/* this == yyval */

var $0 = $$.length - 1;
switch (yystate) {
case 1:return $$[$0-1];
break;
case 2:this.$ = ["+", $$[$0-2], $$[$0]];
break;
case 3:this.$ = ["-", $$[$0-2], $$[$0]];
break;
case 4:this.$ = ["*", $$[$0-2], $$[$0]];
break;
case 5:this.$ = ["/", $$[$0-2], $$[$0]];
break;
case 6:this.$ = ["^", $$[$0-2], $$[$0]];
break;
case 7:this.$ = ["!", $$[$0-1]];
break;
case 8:this.$ = ["-", $$[$0]];
break;
case 9:this.$ = [$$[$0-3], $$[$0-1]];
break;
case 10:this.$ = $$[$0-1];
break;
case 11:this.$ = $$[$0];
break;
case 12:this.$ = $$[$0];
break;
case 13:this.$ = $$[$0];
break;
case 14:this.$ = Number(yytext);
break;
}
},
table: [{3:1,4:2,7:[1,3],12:[1,4],13:[1,5],15:[1,6],16:[1,7],17:[1,8],18:[1,9]},{1:[3]},{5:[1,10],6:[1,11],7:[1,12],8:[1,13],9:[1,14],10:[1,15],11:[1,16]},{4:17,7:[1,3],12:[1,4],13:[1,5],15:[1,6],16:[1,7],17:[1,8],18:[1,9]},{13:[1,18]},{4:19,7:[1,3],12:[1,4],13:[1,5],15:[1,6],16:[1,7],17:[1,8],18:[1,9]},{5:[2,11],6:[2,11],7:[2,11],8:[2,11],9:[2,11],10:[2,11],11:[2,11],14:[2,11]},{5:[2,12],6:[2,12],7:[2,12],8:[2,12],9:[2,12],10:[2,12],11:[2,12],14:[2,12]},{5:[2,13],6:[2,13],7:[2,13],8:[2,13],9:[2,13],10:[2,13],11:[2,13],14:[2,13]},{5:[2,14],6:[2,14],7:[2,14],8:[2,14],9:[2,14],10:[2,14],11:[2,14],14:[2,14]},{1:[2,1]},{4:20,7:[1,3],12:[1,4],13:[1,5],15:[1,6],16:[1,7],17:[1,8],18:[1,9]},{4:21,7:[1,3],12:[1,4],13:[1,5],15:[1,6],16:[1,7],17:[1,8],18:[1,9]},{4:22,7:[1,3],12:[1,4],13:[1,5],15:[1,6],16:[1,7],17:[1,8],18:[1,9]},{4:23,7:[1,3],12:[1,4],13:[1,5],15:[1,6],16:[1,7],17:[1,8],18:[1,9]},{4:24,7:[1,3],12:[1,4],13:[1,5],15:[1,6],16:[1,7],17:[1,8],18:[1,9]},{5:[2,7],6:[2,7],7:[2,7],8:[2,7],9:[2,7],10:[2,7],11:[2,7],14:[2,7]},{5:[2,8],6:[2,8],7:[2,8],8:[2,8],9:[2,8],10:[1,15],11:[1,16],14:[2,8]},{4:25,7:[1,3],12:[1,4],13:[1,5],15:[1,6],16:[1,7],17:[1,8],18:[1,9]},{6:[1,11],7:[1,12],8:[1,13],9:[1,14],10:[1,15],11:[1,16],14:[1,26]},{5:[2,2],6:[2,2],7:[2,2],8:[1,13],9:[1,14],10:[1,15],11:[1,16],14:[2,2]},{5:[2,3],6:[2,3],7:[2,3],8:[1,13],9:[1,14],10:[1,15],11:[1,16],14:[2,3]},{5:[2,4],6:[2,4],7:[2,4],8:[2,4],9:[2,4],10:[1,15],11:[1,16],14:[2,4]},{5:[2,5],6:[2,5],7:[2,5],8:[2,5],9:[2,5],10:[1,15],11:[1,16],14:[2,5]},{5:[2,6],6:[2,6],7:[2,6],8:[2,6],9:[2,6],10:[1,15],11:[1,16],14:[2,6]},{6:[1,11],7:[1,12],8:[1,13],9:[1,14],10:[1,15],11:[1,16],14:[1,27]},{5:[2,10],6:[2,10],7:[2,10],8:[2,10],9:[2,10],10:[2,10],11:[2,10],14:[2,10]},{5:[2,9],6:[2,9],7:[2,9],8:[2,9],9:[2,9],10:[2,9],11:[2,9],14:[2,9]}],
defaultActions: {10:[2,1]},
parseError: function parseError(str, hash) {
    if (hash.recoverable) {
        this.trace(str);
    } else {
        throw new Error(str);
    }
},
parse: function parse(input) {
    var self = this, stack = [0], vstack = [null], lstack = [], table = this.table, yytext = '', yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
    var args = lstack.slice.call(arguments, 1);
    this.lexer.setInput(input);
    this.lexer.yy = this.yy;
    this.yy.lexer = this.lexer;
    this.yy.parser = this;
    if (typeof this.lexer.yylloc == 'undefined') {
        this.lexer.yylloc = {};
    }
    var yyloc = this.lexer.yylloc;
    lstack.push(yyloc);
    var ranges = this.lexer.options && this.lexer.options.ranges;
    if (typeof this.yy.parseError === 'function') {
        this.parseError = this.yy.parseError;
    } else {
        this.parseError = Object.getPrototypeOf(this).parseError;
    }
    function popStack(n) {
        stack.length = stack.length - 2 * n;
        vstack.length = vstack.length - n;
        lstack.length = lstack.length - n;
    }
    function lex() {
        var token;
        token = self.lexer.lex() || EOF;
        if (typeof token !== 'number') {
            token = self.symbols_[token] || token;
        }
        return token;
    }
    var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
    while (true) {
        state = stack[stack.length - 1];
        if (this.defaultActions[state]) {
            action = this.defaultActions[state];
        } else {
            if (symbol === null || typeof symbol == 'undefined') {
                symbol = lex();
            }
            action = table[state] && table[state][symbol];
        }
                    if (typeof action === 'undefined' || !action.length || !action[0]) {
                var errStr = '';
                expected = [];
                for (p in table[state]) {
                    if (this.terminals_[p] && p > TERROR) {
                        expected.push('\'' + this.terminals_[p] + '\'');
                    }
                }
                if (this.lexer.showPosition) {
                    errStr = 'Parse error on line ' + (yylineno + 1) + ':\n' + this.lexer.showPosition() + '\nExpecting ' + expected.join(', ') + ', got \'' + (this.terminals_[symbol] || symbol) + '\'';
                } else {
                    errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\'' + (this.terminals_[symbol] || symbol) + '\'');
                }
                this.parseError(errStr, {
                    text: this.lexer.match,
                    token: this.terminals_[symbol] || symbol,
                    line: this.lexer.yylineno,
                    loc: yyloc,
                    expected: expected
                });
            }
        if (action[0] instanceof Array && action.length > 1) {
            throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
        }
        switch (action[0]) {
        case 1:
            stack.push(symbol);
            vstack.push(this.lexer.yytext);
            lstack.push(this.lexer.yylloc);
            stack.push(action[1]);
            symbol = null;
            if (!preErrorSymbol) {
                yyleng = this.lexer.yyleng;
                yytext = this.lexer.yytext;
                yylineno = this.lexer.yylineno;
                yyloc = this.lexer.yylloc;
                if (recovering > 0) {
                    recovering--;
                }
            } else {
                symbol = preErrorSymbol;
                preErrorSymbol = null;
            }
            break;
        case 2:
            len = this.productions_[action[1]][1];
            yyval.$ = vstack[vstack.length - len];
            yyval._$ = {
                first_line: lstack[lstack.length - (len || 1)].first_line,
                last_line: lstack[lstack.length - 1].last_line,
                first_column: lstack[lstack.length - (len || 1)].first_column,
                last_column: lstack[lstack.length - 1].last_column
            };
            if (ranges) {
                yyval._$.range = [
                    lstack[lstack.length - (len || 1)].range[0],
                    lstack[lstack.length - 1].range[1]
                ];
            }
            r = this.performAction.apply(yyval, [
                yytext,
                yyleng,
                yylineno,
                this.yy,
                action[1],
                vstack,
                lstack
            ].concat(args));
            if (typeof r !== 'undefined') {
                return r;
            }
            if (len) {
                stack = stack.slice(0, -1 * len * 2);
                vstack = vstack.slice(0, -1 * len);
                lstack = lstack.slice(0, -1 * len);
            }
            stack.push(this.productions_[action[1]][0]);
            vstack.push(yyval.$);
            lstack.push(yyval._$);
            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
            stack.push(newState);
            break;
        case 3:
            return true;
        }
    }
    return true;
}};
/* generated by jison-lex 0.2.1 */
var lexer = (function(){
var lexer = {

EOF:1,

parseError:function parseError(str, hash) {
        if (this.yy.parser) {
            this.yy.parser.parseError(str, hash);
        } else {
            throw new Error(str);
        }
    },

// resets the lexer, sets new input
setInput:function (input) {
        this._input = input;
        this._more = this._backtrack = this.done = false;
        this.yylineno = this.yyleng = 0;
        this.yytext = this.matched = this.match = '';
        this.conditionStack = ['INITIAL'];
        this.yylloc = {
            first_line: 1,
            first_column: 0,
            last_line: 1,
            last_column: 0
        };
        if (this.options.ranges) {
            this.yylloc.range = [0,0];
        }
        this.offset = 0;
        return this;
    },

// consumes and returns one char from the input
input:function () {
        var ch = this._input[0];
        this.yytext += ch;
        this.yyleng++;
        this.offset++;
        this.match += ch;
        this.matched += ch;
        var lines = ch.match(/(?:\r\n?|\n).*/g);
        if (lines) {
            this.yylineno++;
            this.yylloc.last_line++;
        } else {
            this.yylloc.last_column++;
        }
        if (this.options.ranges) {
            this.yylloc.range[1]++;
        }

        this._input = this._input.slice(1);
        return ch;
    },

// unshifts one char (or a string) into the input
unput:function (ch) {
        var len = ch.length;
        var lines = ch.split(/(?:\r\n?|\n)/g);

        this._input = ch + this._input;
        this.yytext = this.yytext.substr(0, this.yytext.length - len - 1);
        //this.yyleng -= len;
        this.offset -= len;
        var oldLines = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1);
        this.matched = this.matched.substr(0, this.matched.length - 1);

        if (lines.length - 1) {
            this.yylineno -= lines.length - 1;
        }
        var r = this.yylloc.range;

        this.yylloc = {
            first_line: this.yylloc.first_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.first_column,
            last_column: lines ?
                (lines.length === oldLines.length ? this.yylloc.first_column : 0)
                 + oldLines[oldLines.length - lines.length].length - lines[0].length :
              this.yylloc.first_column - len
        };

        if (this.options.ranges) {
            this.yylloc.range = [r[0], r[0] + this.yyleng - len];
        }
        this.yyleng = this.yytext.length;
        return this;
    },

// When called from action, caches matched text and appends it on next action
more:function () {
        this._more = true;
        return this;
    },

// When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
reject:function () {
        if (this.options.backtrack_lexer) {
            this._backtrack = true;
        } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n' + this.showPosition(), {
                text: "",
                token: null,
                line: this.yylineno
            });

        }
        return this;
    },

// retain first n characters of the match
less:function (n) {
        this.unput(this.match.slice(n));
    },

// displays already matched input, i.e. for error messages
pastInput:function () {
        var past = this.matched.substr(0, this.matched.length - this.match.length);
        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\n/g, "");
    },

// displays upcoming input, i.e. for error messages
upcomingInput:function () {
        var next = this.match;
        if (next.length < 20) {
            next += this._input.substr(0, 20-next.length);
        }
        return (next.substr(0,20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
    },

// displays the character position where the lexing error occurred, i.e. for error messages
showPosition:function () {
        var pre = this.pastInput();
        var c = new Array(pre.length + 1).join("-");
        return pre + this.upcomingInput() + "\n" + c + "^";
    },

// test the lexed token: return FALSE when not a match, otherwise return token
test_match:function (match, indexed_rule) {
        var token,
            lines,
            backup;

        if (this.options.backtrack_lexer) {
            // save context
            backup = {
                yylineno: this.yylineno,
                yylloc: {
                    first_line: this.yylloc.first_line,
                    last_line: this.last_line,
                    first_column: this.yylloc.first_column,
                    last_column: this.yylloc.last_column
                },
                yytext: this.yytext,
                match: this.match,
                matches: this.matches,
                matched: this.matched,
                yyleng: this.yyleng,
                offset: this.offset,
                _more: this._more,
                _input: this._input,
                yy: this.yy,
                conditionStack: this.conditionStack.slice(0),
                done: this.done
            };
            if (this.options.ranges) {
                backup.yylloc.range = this.yylloc.range.slice(0);
            }
        }

        lines = match[0].match(/(?:\r\n?|\n).*/g);
        if (lines) {
            this.yylineno += lines.length;
        }
        this.yylloc = {
            first_line: this.yylloc.last_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.last_column,
            last_column: lines ?
                         lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length :
                         this.yylloc.last_column + match[0].length
        };
        this.yytext += match[0];
        this.match += match[0];
        this.matches = match;
        this.yyleng = this.yytext.length;
        if (this.options.ranges) {
            this.yylloc.range = [this.offset, this.offset += this.yyleng];
        }
        this._more = false;
        this._backtrack = false;
        this._input = this._input.slice(match[0].length);
        this.matched += match[0];
        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
        if (this.done && this._input) {
            this.done = false;
        }
        if (token) {
            return token;
        } else if (this._backtrack) {
            // recover context
            for (var k in backup) {
                this[k] = backup[k];
            }
            return false; // rule action called reject() implying the next rule should be tested instead.
        }
        return false;
    },

// return next match in input
next:function () {
        if (this.done) {
            return this.EOF;
        }
        if (!this._input) {
            this.done = true;
        }

        var token,
            match,
            tempMatch,
            index;
        if (!this._more) {
            this.yytext = '';
            this.match = '';
        }
        var rules = this._currentRules();
        for (var i = 0; i < rules.length; i++) {
            tempMatch = this._input.match(this.rules[rules[i]]);
            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                match = tempMatch;
                index = i;
                if (this.options.backtrack_lexer) {
                    token = this.test_match(tempMatch, rules[i]);
                    if (token !== false) {
                        return token;
                    } else if (this._backtrack) {
                        match = false;
                        continue; // rule action called reject() implying a rule MISmatch.
                    } else {
                        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                        return false;
                    }
                } else if (!this.options.flex) {
                    break;
                }
            }
        }
        if (match) {
            token = this.test_match(match, rules[index]);
            if (token !== false) {
                return token;
            }
            // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
            return false;
        }
        if (this._input === "") {
            return this.EOF;
        } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
                text: "",
                token: null,
                line: this.yylineno
            });
        }
    },

// return next match that has a token
lex:function lex() {
        var r = this.next();
        if (r) {
            return r;
        } else {
            return this.lex();
        }
    },

// activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
begin:function begin(condition) {
        this.conditionStack.push(condition);
    },

// pop the previously active lexer condition state off the condition stack
popState:function popState() {
        var n = this.conditionStack.length - 1;
        if (n > 0) {
            return this.conditionStack.pop();
        } else {
            return this.conditionStack[0];
        }
    },

// produce the lexer rule set which is active for the currently active lexer condition state
_currentRules:function _currentRules() {
        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
        } else {
            return this.conditions["INITIAL"].rules;
        }
    },

// return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
topState:function topState(n) {
        n = this.conditionStack.length - 1 - Math.abs(n || 0);
        if (n >= 0) {
            return this.conditionStack[n];
        } else {
            return "INITIAL";
        }
    },

// alias for begin(condition)
pushState:function pushState(condition) {
        this.begin(condition);
    },

// return the number of states currently on the stack
stateStackSize:function stateStackSize() {
        return this.conditionStack.length;
    },
options: {},
performAction: function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {

var YYSTATE=YY_START;
switch($avoiding_name_collisions) {
case 0:/* skip whitespace */
break;
case 1:return 18
break;
case 2:return 6
break;
case 3:return 7
break;
case 4:return 8
break;
case 5:return 9
break;
case 6:return 10
break;
case 7:return 11
break;
case 8:return 13
break;
case 9:return 14
break;
case 10:return 15
break;
case 11:return 16
break;
case 12:return 17
break;
case 13:return 12
break;
case 14:return 5
break;
case 15:return 'INVALID'
break;
}
},
rules: [/^(?:\s+)/,/^(?:([\.0-9]+)\b)/,/^(?:\+)/,/^(?:-)/,/^(?:\*)/,/^(?:\/)/,/^(?:\^)/,/^(?:!)/,/^(?:\()/,/^(?:\))/,/^(?:e\b)/,/^(?:pi\b)/,/^(?:ans\b)/,/^(?:[a-z]+)/,/^(?:$)/,/^(?:.)/],
conditions: {"INITIAL":{"rules":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15],"inclusive":true}}
};
return lexer;
})();
parser.lexer = lexer;
function Parser () {
  this.yy = {};
}
Parser.prototype = parser;parser.Parser = Parser;
return new Parser;
})();window.Calculator = (function(parser) {
    // I18N: calculator error message
    var ERROR_TEXT = $._("Error");
    var CalculatorError = function(message) {
        this.message = message;
    };
    CalculatorError.prototype = new Error();
    CalculatorError.prototype.constructor = CalculatorError;

    parser.yy.parseError = function parseError(str, hash) {
        throw new CalculatorError(ERROR_TEXT);
    };

    var settings = window.localStorage == null ? {} : $.parseJSON(
            window.localStorage["calculator_settings:" + window.USERNAME] || "{}");
    if (settings.angleMode == null) {
        settings.angleMode = "DEG";
    }

    return _.bindAll({
        settings: settings,
        parser: parser,
        parse: _.bind(parser.parse, parser),

        evaluate: function(tree, ans) {
            var toRad = function(ang) {
                if (settings.angleMode === "DEG") {
                    return ang * Math.PI / 180;
                }
                return ang;
            };
            var fromRad = function(ang) {
                if (settings.angleMode === "DEG") {
                    return ang / Math.PI * 180;
                }
                return ang;
            };
            if (tree === "ans") {
                if (ans !== undefined) {
                    return ans;
                } else {
                    throw new CalculatorError($._("Invalid variable ans"));
                }
            } else if (tree === "pi") {
                return Math.PI;
            } else if (tree === "e") {
                return Math.E;
            } else if (_.isNumber(tree)) {
                return tree;
            } else if (_.isArray(tree)) {
                var fns = {
                    "+": function(a, b) { return a + b; },
                    "-": function(a, b) { return b === undefined ? -a : a - b; },
                    "*": function(a, b) { return a * b; },
                    "/": function(a, b) { return a / b; },
                    "^": function(a, b) { return Math.pow(a, b); },
                    "!": function f(a) { return a <= 1 ? 1 : a * f(a - 1); },
                    sqrt: function(a) { return Math.pow(a, 0.5); },
                    sin: function(a) { return Math.sin(toRad(a)); },
                    cos: function(a) { return Math.cos(toRad(a)); },
                    tan: function(a) {
                        var ans = Math.tan(toRad(a));
                        if (isNaN(ans) || Math.abs(ans) > Math.pow(2, 53)) {
                            throw new CalculatorError($._("undefined"));
                        }
                        return ans;
                    },
                    asin: function(a) {
                        var ans = fromRad(Math.asin(a));
                        if (isNaN(ans)) {
                            throw new CalculatorError($._("undefined"));
                        }
                        return ans;
                    },
                    acos: function(a) {
                        var ans = fromRad(Math.acos(a));
                        if (isNaN(ans)) {
                            throw new CalculatorError($._("undefined"));
                        }
                        return ans;
                    },
                    atan: function(a) {
                        var ans = fromRad(Math.atan(a));
                        if (isNaN(ans)) {
                            throw new CalculatorError($._("undefined"));
                        }
                        return ans;
                    },
                    ln: function(a) {
                        var ans = Math.log(a);
                        if (isNaN(ans) || !isFinite(ans)) {
                            throw new CalculatorError($._("undefined"));
                        }
                        return ans;
                    },
                    log: function(a) {
                        var ans = Math.log(a) / Math.LN10;
                        if (isNaN(ans) || !isFinite(ans)) {
                            throw new CalculatorError($._("undefined"));
                        }
                        return ans;
                    }
                };

                if (tree[0] in fns) {
                    var self = this;
                    return fns[tree[0]].apply(
                        this, _.map(tree.slice(1), function(t) {
                            return self.evaluate(t, ans); }));
                } else {
                    throw new CalculatorError(ERROR_TEXT);
                }
            } else {
                throw new CalculatorError(
                    $._("Invalid type %(type)s",
                        {type: Object.prototype.toString.call(tree)}));
            }
        },

        calculate: function(str, ans) {
            var tree = this.parse(str);
            return this.evaluate(tree, ans);
        },
        CalculatorError: CalculatorError
    }, "evaluate", "calculate");
})(Calculator);


  }).apply(root, arguments);
});
}(this));

(function(root) {
define("third_party/jquery.mobile.vmouse.js", [], function() {
  return (function() {
/*
* jQuery Mobile Framework : "mouse" plugin
* Copyright (c) jQuery Project
* Dual licensed under the MIT or GPL Version 2 licenses.
* http://jquery.org/license
*/

// This plugin is an experiment for abstracting away the touch and mouse
// events so that developers don't have to worry about which method of input
// the device their document is loaded on supports.
//
// The idea here is to allow the developer to register listeners for the
// basic mouse events, such as mousedown, mousemove, mouseup, and click,
// and the plugin will take care of registering the correct listeners
// behind the scenes to invoke the listener at the fastest possible time
// for that device, while still retaining the order of event firing in
// the traditional mouse environment, should multiple handlers be registered
// on the same element for different events.
//
// The current version exposes the following virtual events to jQuery bind methods:
// "vmouseover vmousedown vmousemove vmouseup vclick vmouseout vmousecancel"

(function( $, window, document, undefined ) {

var dataPropertyName = "virtualMouseBindings",
	touchTargetPropertyName = "virtualTouchID",
	virtualEventNames = "vmouseover vmousedown vmousemove vmouseup vclick vmouseout vmousecancel".split( " " ),
	touchEventProps = "clientX clientY pageX pageY screenX screenY".split( " " ),
	mouseHookProps = $.event.mouseHooks ? $.event.mouseHooks.props : [],
	mouseEventProps = $.event.props.concat( mouseHookProps ),
	activeDocHandlers = {},
	resetTimerID = 0,
	startX = 0,
	startY = 0,
	didScroll = false,
	clickBlockList = [],
	blockMouseTriggers = false,
	blockTouchTriggers = false,
	eventCaptureSupported = "addEventListener" in document,
	$document = $( document ),
	nextTouchID = 1,
	lastTouchID = 0;

$.vmouse = {
	moveDistanceThreshold: 10,
	clickDistanceThreshold: 10,
	resetTimerDuration: 1500
};

function getNativeEvent( event ) {

	while ( event && typeof event.originalEvent !== "undefined" ) {
		event = event.originalEvent;
	}
	return event;
}

function createVirtualEvent( event, eventType ) {

	var t = event.type,
		oe, props, ne, prop, ct, touch, i, j;

	event = $.Event(event);
	event.type = eventType;

	oe = event.originalEvent;
	props = $.event.props;

	// addresses separation of $.event.props in to $.event.mouseHook.props and Issue 3280
	// https://github.com/jquery/jquery-mobile/issues/3280
	if ( t.search(/mouse/) >-1 ) {
		props = mouseEventProps;
	}

	// copy original event properties over to the new event
	// this would happen if we could call $.event.fix instead of $.Event
	// but we don't have a way to force an event to be fixed multiple times
	if ( oe ) {
		for ( i = props.length, prop; i; ) {
			prop = props[ --i ];
			event[ prop ] = oe[ prop ];
		}
	}

	// make sure that if the mouse and click virtual events are generated
	// without a .which one is defined
	if ( t.search(/mouse(down|up)|click/) > -1 && !event.which ){
		event.which = 1;
	}

	if ( t.search(/^touch/) !== -1 ) {
		ne = getNativeEvent( oe );
		t = ne.touches;
		ct = ne.changedTouches;
		touch = ( t && t.length ) ? t[0] : ( (ct && ct.length) ? ct[ 0 ] : undefined );

		if ( touch ) {
			for ( j = 0, len = touchEventProps.length; j < len; j++){
				prop = touchEventProps[ j ];
				event[ prop ] = touch[ prop ];
			}
		}
	}

	return event;
}

function getVirtualBindingFlags( element ) {

	var flags = {},
		b, k;

	while ( element ) {

		b = $.data( element, dataPropertyName );

		for (  k in b ) {
			if ( b[ k ] ) {
				flags[ k ] = flags.hasVirtualBinding = true;
			}
		}
		element = element.parentNode;
	}
	return flags;
}

function getClosestElementWithVirtualBinding( element, eventType ) {
	var b;
	while ( element ) {

		b = $.data( element, dataPropertyName );

		if ( b && ( !eventType || b[ eventType ] ) ) {
			return element;
		}
		element = element.parentNode;
	}
	return null;
}

function enableTouchBindings() {
	blockTouchTriggers = false;
}

function disableTouchBindings() {
	blockTouchTriggers = true;
}

function enableMouseBindings() {
	lastTouchID = 0;
	clickBlockList.length = 0;
	blockMouseTriggers = false;

	// When mouse bindings are enabled, our
	// touch bindings are disabled.
	disableTouchBindings();
}

function disableMouseBindings() {
	// When mouse bindings are disabled, our
	// touch bindings are enabled.
	enableTouchBindings();
}

function startResetTimer() {
	clearResetTimer();
	resetTimerID = setTimeout(function(){
		resetTimerID = 0;
		enableMouseBindings();
	}, $.vmouse.resetTimerDuration );
}

function clearResetTimer() {
	if ( resetTimerID ){
		clearTimeout( resetTimerID );
		resetTimerID = 0;
	}
}

function triggerVirtualEvent( eventType, event, flags ) {
	var ve;

	if ( ( flags && flags[ eventType ] ) ||
				( !flags && getClosestElementWithVirtualBinding( event.target, eventType ) ) ) {

		ve = createVirtualEvent( event, eventType );

		$( event.target).trigger( ve );
	}

	return ve;
}

function mouseEventCallback( event ) {
	var touchID = $.data(event.target, touchTargetPropertyName);

	if ( !blockMouseTriggers && ( !lastTouchID || lastTouchID !== touchID ) ){
		var ve = triggerVirtualEvent( "v" + event.type, event );
		if ( ve ) {
			if ( ve.isDefaultPrevented() ) {
				event.preventDefault();
			}
			if ( ve.isPropagationStopped() ) {
				event.stopPropagation();
			}
			if ( ve.isImmediatePropagationStopped() ) {
				event.stopImmediatePropagation();
			}
		}
	}
}

function handleTouchStart( event ) {

	var touches = getNativeEvent( event ).touches,
		target, flags;

	if ( touches && touches.length === 1 ) {

		target = event.target;
		flags = getVirtualBindingFlags( target );

		if ( flags.hasVirtualBinding ) {

			lastTouchID = nextTouchID++;
			$.data( target, touchTargetPropertyName, lastTouchID );

			clearResetTimer();

			disableMouseBindings();
			didScroll = false;

			var t = getNativeEvent( event ).touches[ 0 ];
			startX = t.pageX;
			startY = t.pageY;

			triggerVirtualEvent( "vmouseover", event, flags );
			triggerVirtualEvent( "vmousedown", event, flags );
		}
	}
}

function handleScroll( event ) {
	if ( blockTouchTriggers ) {
		return;
	}

	if ( !didScroll ) {
		triggerVirtualEvent( "vmousecancel", event, getVirtualBindingFlags( event.target ) );
	}

	didScroll = true;
	startResetTimer();
}

function handleTouchMove( event ) {
	if ( blockTouchTriggers ) {
		return;
	}

	var t = getNativeEvent( event ).touches[ 0 ],
		didCancel = didScroll,
		moveThreshold = $.vmouse.moveDistanceThreshold;
		didScroll = didScroll ||
			( Math.abs(t.pageX - startX) > moveThreshold ||
				Math.abs(t.pageY - startY) > moveThreshold ),
		flags = getVirtualBindingFlags( event.target );

	if ( didScroll && !didCancel ) {
		triggerVirtualEvent( "vmousecancel", event, flags );
	}

	triggerVirtualEvent( "vmousemove", event, flags );
	startResetTimer();
}

function handleTouchEnd( event ) {
	if ( blockTouchTriggers ) {
		return;
	}

	disableTouchBindings();

	var flags = getVirtualBindingFlags( event.target ),
		t;
	triggerVirtualEvent( "vmouseup", event, flags );

	if ( !didScroll ) {
		var ve = triggerVirtualEvent( "vclick", event, flags );
		if ( ve && ve.isDefaultPrevented() ) {
			// The target of the mouse events that follow the touchend
			// event don't necessarily match the target used during the
			// touch. This means we need to rely on coordinates for blocking
			// any click that is generated.
			t = getNativeEvent( event ).changedTouches[ 0 ];
			clickBlockList.push({
				touchID: lastTouchID,
				x: t.clientX,
				y: t.clientY
			});

			// Prevent any mouse events that follow from triggering
			// virtual event notifications.
			blockMouseTriggers = true;
		}
	}
	triggerVirtualEvent( "vmouseout", event, flags);
	didScroll = false;

	startResetTimer();
}

function hasVirtualBindings( ele ) {
	var bindings = $.data( ele, dataPropertyName ),
		k;

	if ( bindings ) {
		for ( k in bindings ) {
			if ( bindings[ k ] ) {
				return true;
			}
		}
	}
	return false;
}

function dummyMouseHandler(){}

function getSpecialEventObject( eventType ) {
	var realType = eventType.substr( 1 );

	return {
		setup: function( data, namespace ) {
			// If this is the first virtual mouse binding for this element,
			// add a bindings object to its data.

			if ( !hasVirtualBindings( this ) ) {
				$.data( this, dataPropertyName, {});
			}

			// If setup is called, we know it is the first binding for this
			// eventType, so initialize the count for the eventType to zero.
			var bindings = $.data( this, dataPropertyName );
			bindings[ eventType ] = true;

			// If this is the first virtual mouse event for this type,
			// register a global handler on the document.

			activeDocHandlers[ eventType ] = ( activeDocHandlers[ eventType ] || 0 ) + 1;

			if ( activeDocHandlers[ eventType ] === 1 ) {
				$document.bind( realType, mouseEventCallback );
			}

			// Some browsers, like Opera Mini, won't dispatch mouse/click events
			// for elements unless they actually have handlers registered on them.
			// To get around this, we register dummy handlers on the elements.

			$( this ).bind( realType, dummyMouseHandler );

			// For now, if event capture is not supported, we rely on mouse handlers.
			if ( eventCaptureSupported ) {
				// If this is the first virtual mouse binding for the document,
				// register our touchstart handler on the document.

				activeDocHandlers[ "touchstart" ] = ( activeDocHandlers[ "touchstart" ] || 0) + 1;

				if (activeDocHandlers[ "touchstart" ] === 1) {
					$document.bind( "touchstart", handleTouchStart )
						.bind( "touchend", handleTouchEnd )

						// On touch platforms, touching the screen and then dragging your finger
						// causes the window content to scroll after some distance threshold is
						// exceeded. On these platforms, a scroll prevents a click event from being
						// dispatched, and on some platforms, even the touchend is suppressed. To
						// mimic the suppression of the click event, we need to watch for a scroll
						// event. Unfortunately, some platforms like iOS don't dispatch scroll
						// events until *AFTER* the user lifts their finger (touchend). This means
						// we need to watch both scroll and touchmove events to figure out whether
						// or not a scroll happenens before the touchend event is fired.

						.bind( "touchmove", handleTouchMove )
						.bind( "scroll", handleScroll );
				}
			}
		},

		teardown: function( data, namespace ) {
			// If this is the last virtual binding for this eventType,
			// remove its global handler from the document.

			--activeDocHandlers[ eventType ];

			if ( !activeDocHandlers[ eventType ] ) {
				$document.unbind( realType, mouseEventCallback );
			}

			if ( eventCaptureSupported ) {
				// If this is the last virtual mouse binding in existence,
				// remove our document touchstart listener.

				--activeDocHandlers[ "touchstart" ];

				if ( !activeDocHandlers[ "touchstart" ] ) {
					$document.unbind( "touchstart", handleTouchStart )
						.unbind( "touchmove", handleTouchMove )
						.unbind( "touchend", handleTouchEnd )
						.unbind( "scroll", handleScroll );
				}
			}

			var $this = $( this ),
				bindings = $.data( this, dataPropertyName );

			// teardown may be called when an element was
			// removed from the DOM. If this is the case,
			// jQuery core may have already stripped the element
			// of any data bindings so we need to check it before
			// using it.
			if ( bindings ) {
				bindings[ eventType ] = false;
			}

			// Unregister the dummy event handler.

			$this.unbind( realType, dummyMouseHandler );

			// If this is the last virtual mouse binding on the
			// element, remove the binding data from the element.

			if ( !hasVirtualBindings( this ) ) {
				$this.removeData( dataPropertyName );
			}
		}
	};
}

// Expose our custom events to the jQuery bind/unbind mechanism.

for ( var i = 0; i < virtualEventNames.length; i++ ){
	$.event.special[ virtualEventNames[ i ] ] = getSpecialEventObject( virtualEventNames[ i ] );
}

// Add a capture click handler to block clicks.
// Note that we require event capture support for this so if the device
// doesn't support it, we punt for now and rely solely on mouse events.
if ( eventCaptureSupported ) {
	document.addEventListener( "click", function( e ){
		var cnt = clickBlockList.length,
			target = e.target,
			x, y, ele, i, o, touchID;

		if ( cnt ) {
			x = e.clientX;
			y = e.clientY;
			threshold = $.vmouse.clickDistanceThreshold;

			// The idea here is to run through the clickBlockList to see if
			// the current click event is in the proximity of one of our
			// vclick events that had preventDefault() called on it. If we find
			// one, then we block the click.
			//
			// Why do we have to rely on proximity?
			//
			// Because the target of the touch event that triggered the vclick
			// can be different from the target of the click event synthesized
			// by the browser. The target of a mouse/click event that is syntehsized
			// from a touch event seems to be implementation specific. For example,
			// some browsers will fire mouse/click events for a link that is near
			// a touch event, even though the target of the touchstart/touchend event
			// says the user touched outside the link. Also, it seems that with most
			// browsers, the target of the mouse/click event is not calculated until the
			// time it is dispatched, so if you replace an element that you touched
			// with another element, the target of the mouse/click will be the new
			// element underneath that point.
			//
			// Aside from proximity, we also check to see if the target and any
			// of its ancestors were the ones that blocked a click. This is necessary
			// because of the strange mouse/click target calculation done in the
			// Android 2.1 browser, where if you click on an element, and there is a
			// mouse/click handler on one of its ancestors, the target will be the
			// innermost child of the touched element, even if that child is no where
			// near the point of touch.

			ele = target;

			while ( ele ) {
				for ( i = 0; i < cnt; i++ ) {
					o = clickBlockList[ i ];
					touchID = 0;

					if ( ( ele === target && Math.abs( o.x - x ) < threshold && Math.abs( o.y - y ) < threshold ) ||
								$.data( ele, touchTargetPropertyName ) === o.touchID ) {
						// XXX: We may want to consider removing matches from the block list
						//      instead of waiting for the reset timer to fire.
						e.preventDefault();
						e.stopPropagation();
						return;
					}
				}
				ele = ele.parentNode;
			}
		}
	}, true);
}
})( jQuery, window, document );


  }).apply(root, arguments);
});
}(this));

define('utils/scratchpad.js',['require','../third_party/jquery.mobile.vmouse.js'],function(require) {

require("../third_party/jquery.mobile.vmouse.js");

window.DrawingScratchpad = function(elem) {
    var pen = "M25.31,2.872l-3.384-2.127c-0.854-0.536-1.979-0.278-2.517,0.576l-1.334,2.123l6.474,4.066l1.335-2.122C26.42,4.533,26.164,3.407,25.31,2.872zM6.555,21.786l6.474,4.066L23.581,9.054l-6.477-4.067L6.555,21.786zM5.566,26.952l-0.143,3.819l3.379-1.787l3.14-1.658l-6.246-3.925L5.566,26.952z";
    var erase = "M24.778,21.419 19.276,15.917 24.777,10.415 21.949,7.585 16.447,13.087 10.945,7.585 8.117,10.415 13.618,15.917 8.116,21.419 10.946,24.248 16.447,18.746 21.948,24.248";
    var undo = "M12.981,9.073V6.817l-12.106,6.99l12.106,6.99v-2.422c3.285-0.002,9.052,0.28,9.052,2.269c0,2.78-6.023,4.263-6.023,4.263v2.132c0,0,13.53,0.463,13.53-9.823C29.54,9.134,17.952,8.831,12.981,9.073z";

    var rainbow = "0-#00ff00-#ff0000:50-#0000ff";

    var nextRainbowStroke = (function() {
        var freq = 0.05;
        var iter = 0;
        return function() {
            var red   = Math.sin(freq * iter + -3) * 127 + 128;
            var green = Math.sin(freq * iter + -1) * 127 + 128;
            var blue  = Math.sin(freq * iter + 1) * 127 + 128;
            iter++;
            return "rgb(" + red + "," + green + "," + blue + ")";
        };
    })();

    if (!elem) {
        throw new Error("No element provided to DrawingScratchpad");
    }

    var container = $(elem);

    var pad = Raphael(container[0], container.width(), container.height());

    this.resize = function() {
        pad.setSize(container.width(), container.height());
    };

    var palette = pad.set(), stroke = rainbow, colors = [rainbow, "#000000", "#3f3f3f", "#7f7f7f", "#bfbfbf", "#ff0000", "#ff7f00", "#ffff00", "#00ff00", "#00ffff", "#007fff", "#0000ff", "#7f00ff"];
    for (var i = 0; i < colors.length; i++) {
        (function(color) {
            var setcolor = function(e) {
                stroke = color;
                palette.animate({y: 7}, 100);
                this.animate({y: 15}, 100);
                penclick();
            };
            palette.push(pad.rect(90 + i * 27, 7, 24, 24).attr({
                fill: color,
                stroke: "#ccc"
                }).touchstart(setcolor).click(setcolor));
        })(colors[i]);
    }
    palette[0].attr({y: 15});

    var selected = pad.rect(2, 2, 30, 30).attr({
        r: 5,
        stroke: "",
        fill: "rgba(30, 157, 186, 0.5)"
    });

    var line_default = {
        "stroke-width": 2,
        "stroke-linecap": "round",
        "stroke-linejoin": "round"};

    var shapes = pad.set();
    var undoHistory = [[]];

    function saveState() {
        for (var i = 0, state = []; i < shapes.length; i++) {
            if (!shapes[i].removed) {
                if (shapes[i].type === "path") {
                    state.push({
                        path: shapes[i].attr("path").toString(),
                        stroke: shapes[i].attr("stroke"),
                        type: "path"
                    });
                }
            }
        }
        undoHistory.push(state);
    }

    function loadState(state) {
        shapes.remove();
        for (var i = 0; i < state.length; i++) {
            if (state[i].type === "path") {
                shapes.push(pad.path(state[i].path).attr(line_default).attr({
                    stroke: state[i].stroke,
                    "clip-rect": [0, 40, pad.width, pad.height - 40]
                }));
            }
        }
    }

    /*
    * Hi. I did this with VectorEdtor, so I guess I'll try to do the same here with scratchpad
    * If someone is there, reading this code, in the distant future, say, the year 2012 and you
    * are, as any sensible human would, be preparing for the mayan-predicted impending apocalypse,
    * (or not) it doesn't matter. You should totally email me at antimatter15@gmail.com because,
    * it's always an interesting feeling.
    */

    var tools = pad.set();

    tools.push(pad.path(pen).scale(0.8).translate(0, 0));
    tools.push(pad.path(erase).translate(30, 0));
    tools.push(pad.path(undo).scale(0.7).translate(60, 1));

    var tool = "draw";
    function penclick() {
        selected.animate({x: 2}, 100);
        tool = "draw";
    }
    pad.rect(2, 2, 30, 30)
        .attr({
            stroke: "",
            fill: "black",
            "fill-opacity": 0
        })
        .click(penclick).touchstart(penclick);
    function eraseclick() {
        selected.animate({x: 2 + 30}, 100);
        tool = "erase";
    }
    pad.rect(2 + 30, 2, 30, 30)
        .attr({
            stroke: "",
            fill: "black",
            "fill-opacity": 0
        })
        .click(eraseclick).touchstart(eraseclick);
    function undoclick() {
        if (undoHistory.length) {
            loadState(undoHistory.pop());
        }
    }
    pad.rect(2 + 30 * 2, 2, 30, 30)
        .attr({
            stroke: "",
            fill: "black",
            "fill-opacity": 0
        })
        .click(undoclick).touchstart(undoclick);

    tools.attr({fill: "#000", stroke: "none"});
    var path = null, pathstr = "", prevPen;
    var eraser = null;

    function mousedown(X, Y, e) {
        if (!X || !Y || !e) {
            return;
        }
        if (Y <= 40) {
            return;
        }

        if (eraser) {
            eraser.remove();
            eraser = null;
        }

        if (tool === "draw") {
            saveState();
            startPen(X, Y);
        } else if (tool === "erase") {
            eraser = pad.rect(X, Y, 0, 0).attr({
                "fill-opacity": 0.15,
                "stroke-opacity": 0.5,
                "fill": "#ff0000",  // oh noes! its red and gonna asplodes!
                "stroke": "#ff0000"
            });
            eraser.sx = X;
            eraser.sy = Y;
        }
    }

    function startPen(x, y) {
        var singleColorStroke = (stroke === rainbow) ?
            nextRainbowStroke() :
            stroke;
        path = pad.path("M" + x + "," + y).attr(line_default).attr({
            stroke: singleColorStroke,
            "clip-rect": [0, 40, pad.width, pad.height - 40]
        });
        pathstr = path.attr("path");
        shapes.push(path);
        prevPen = {x: x, y: y};
    }

    function rectsIntersect(r1, r2) {
        return r2.x < (r1.x + r1.width) &&
            (r2.x + r2.width) > r1.x &&
            r2.y < (r1.y + r1.height) &&
            (r2.y + r2.height) > r1.y;
    }


    function mouseup(x, y) {
        if (tool === "draw" && path) {
            pathstr += "L" + x + "," + y;
            prevPen = null;
            path.attr("path", pathstr);
        }
        path = null;
        if (tool === "erase" && eraser) {
            saveState();
            var actuallyErased = false;
            var ebox = eraser.getBBox();
            for (var i = 0; i < shapes.length; i++) {
                if (rectsIntersect(ebox, shapes[i].getBBox())) {
                    actuallyErased = true;
                    shapes[i].remove();
                }
            }
            if (!actuallyErased) {
                undoHistory.pop();
            }
            var e = eraser;
            eraser = null;
            e.animate({opacity: 0}, 100, function() {
                e.remove();
            });
        }

    }

    function mousemove(X, Y) {
        if (tool === "draw" && path) {
            pathstr += "Q" + prevPen.x + "," + prevPen.y + "," +
                (prevPen.x + X) / 2 + "," + (prevPen.y + Y) / 2;
            prevPen = {x: X, y: Y};
            path.attr("path", pathstr);
        } else if (tool === "erase" && eraser) {
            var x1 = Math.min(X, eraser.sx),
                x2 = Math.max(X, eraser.sx),
                y1 = Math.max(40, Math.min(Y, eraser.sy)),
                y2 = Math.max(40, Math.max(Y, eraser.sy));
            eraser.attr({
                x: x1,
                y: y1,
                width: x2 - x1,
                height: y2 - y1
            });
        }
    }

    var handleMousemove = function(e) {
        var offset = $(container).offset();
        mousemove(e.pageX - offset.left, e.pageY - offset.top);
        e.preventDefault();
    };
    $(container).on("vmousedown", function(e) {
        var offset = $(container).offset();
        mousedown(e.pageX - offset.left, e.pageY - offset.top, e);
        e.preventDefault();

        $(document).on("vmousemove", handleMousemove);
        $(document).one("vmouseup", function(e) {
            mouseup(e.pageX - offset.left, e.pageY - offset.top, e);
            e.preventDefault();
            $(document).off("vmousemove", handleMousemove);
        });
    });

    this.clear = function() {
        shapes.remove();
        undoHistory = [[]];
    };
};

});

/*
 * Number Utils
 * A number is a js-number, e.g. 5.12
 */
define('utils/knumber.js',['require'],function(require) {

var DEFAULT_TOLERANCE = 1e-9;
var EPSILON = Math.pow(2, -42);

var knumber = KhanUtil.knumber = {

    DEFAULT_TOLERANCE: DEFAULT_TOLERANCE,
    EPSILON: EPSILON,

    is: function(x) {
        return _.isNumber(x) && !_.isNaN(x);
    },

    equal: function(x, y, tolerance) {
        // Checking for undefined makes this function behave nicely
        // with vectors of different lengths that are _.zip'd together
        if (x == null || y == null) {
            return x === y;
        }
        if (tolerance == null) {
            tolerance = DEFAULT_TOLERANCE;
        }
        return Math.abs(x - y) < tolerance;
    },

    sign: function(x, tolerance) {
        return knumber.equal(x, 0, tolerance) ? 0 : Math.abs(x) / x;
    },

    // Round a number to a certain number of decimal places
    round: function(num, precision) {
        var factor = Math.pow(10, precision);
        return Math.round(num * factor) / factor;
    },

    // Round num to the nearest multiple of increment
    // i.e. roundTo(83, 5) -> 85
    roundTo: function(num, increment) {
        return Math.round(num / increment) * increment;
    },

    floorTo: function(num, increment) {
        return Math.floor(num / increment) * increment;
    },

    ceilTo: function(num, increment) {
        return Math.ceil(num / increment) * increment;
    },

    isInteger: function(num, tolerance) {
        return knumber.equal(Math.round(num), num, tolerance);
    },

    /**
     * toFraction
     *
     * Returns a [numerator, denominator] array rational representation
     * of `decimal`
     *
     * See http://en.wikipedia.org/wiki/Continued_fraction for implementation
     * details
     *
     * toFraction(4/8) => [1, 2]
     * toFraction(0.66) => [33, 50]
     * toFraction(0.66, 0.01) => [2/3]
     * toFraction(283 + 1/3) => [850, 3]
     */
    toFraction: function(decimal, tolerance, max_denominator) {
        max_denominator = max_denominator || 1000;
        tolerance = tolerance || EPSILON; // can't be 0

        // Initialize everything to compute successive terms of
        // continued-fraction approximations via recurrence relation
        var n = [1, 0], d = [0, 1];
        var a = Math.floor(decimal), t;
        var rem = decimal - a;

        while (d[0] <= max_denominator) {
            if (knumber.equal(n[0] / d[0], decimal, tolerance)) {
                return [n[0], d[0]];
            }
            n = [a*n[0] + n[1], n[0]];
            d = [a*d[0] + d[1], d[0]];
            a = Math.floor(1 / rem);
            rem = 1/rem - a;
        }

        // We failed to find a nice rational representation,
        // so return an irrational "fraction"
        return [decimal, 1];
    }
};

return knumber;

});

/*
 * Vector Utils 
 * A vector is an array of numbers e.g. [0, 3, 4].
 */
define('utils/kvector.js',['require','./knumber.js'],function(require) {

var knumber = require("./knumber.js");

function arraySum(array) {
    return _.reduce(array, function(memo, arg) { return memo + arg; }, 0);
}

function arrayProduct(array) {
    return _.reduce(array, function(memo, arg) { return memo * arg; }, 1);
}

var kvector = KhanUtil.kvector = {

    is: function(vec, length) {
        if (!_.isArray(vec)) {
            return false;
        }
        if (length !== undefined && vec.length !== length) {
            return false;
        }
        return _.all(vec, knumber.is);
    },

    // Normalize to a unit vector
    normalize: function(v) {
        return kvector.scale(v, 1 / kvector.length(v));
    },

    // Length/magnitude of a vector
    length: function(v) {
        return Math.sqrt(kvector.dot(v, v));
    },

    // Dot product of two vectors
    dot: function(a, b) {
        var vecs = _.toArray(arguments);
        var zipped = _.zip.apply(_, vecs);
        var multiplied = _.map(zipped, arrayProduct);
        return arraySum(multiplied);
    },

    /* vector-add multiple [x, y] coords/vectors
     *
     * kvector.add([1, 2], [3, 4]) -> [4, 6]
     */
    add: function() {
        var points = _.toArray(arguments);
        var zipped = _.zip.apply(_, points);
        return _.map(zipped, arraySum);
    },

    subtract: function(v1, v2) {
        return _.map(_.zip(v1, v2), function(dim) {
            return dim[0] - dim[1];
        });
    },

    negate: function(v) {
        return _.map(v, function(x) {
            return -x;
        });
    },

    // Scale a vector
    scale: function(v1, scalar) {
        return _.map(v1, function(x) {
            return x * scalar;
        });
    },

    equal: function(v1, v2, tolerance) {
        // _.zip will nicely deal with the lengths, going through
        // the length of the longest vector. knumber.equal then
        // returns false for any number compared to the undefined
        // passed in if one of the vectors is shorter.
        return _.all(_.zip(v1, v2), function(pair) {
            return knumber.equal(pair[0], pair[1], tolerance);
        });
    },

    codirectional: function(v1, v2, tolerance) {
        // The origin is trivially codirectional with all other vectors.
        // This gives nice semantics for codirectionality between points when
        // comparing their difference vectors.
        if (knumber.equal(kvector.length(v1), 0, tolerance) ||
                knumber.equal(kvector.length(v2), 0, tolerance)) {
            return true;
        }

        v1 = kvector.normalize(v1);
        v2 = kvector.normalize(v2);

        return kvector.equal(v1, v2, tolerance);
    },

    collinear: function(v1, v2, tolerance) {
        return kvector.codirectional(v1, v2, tolerance) ||
                kvector.codirectional(v1, kvector.negate(v2), tolerance);
    },

    // Convert a cartesian coordinate into a radian polar coordinate
    polarRadFromCart: function(v) {
        var radius = kvector.length(v);
        var theta = Math.atan2(v[1], v[0]);

        // Convert angle range from [-pi, pi] to [0, 2pi]
        if (theta < 0) {
            theta += 2 * Math.PI;
        }

        return [radius, theta];
    },

    // Converts a cartesian coordinate into a degree polar coordinate
    polarDegFromCart: function(v) {
        var polar = kvector.polarRadFromCart(v);
        return [polar[0], polar[1] * 180 / Math.PI];
    },

    /* Convert a polar coordinate into a cartesian coordinate
     *
     * Examples:
     * cartFromPolarRad(5, Math.PI)
     * cartFromPolarRad([5, Math.PI])
     */
    cartFromPolarRad: function(radius, theta) {
        if (_.isUndefined(theta)) {
            theta = radius[1];
            radius = radius[0];
        }

        return [radius * Math.cos(theta), radius * Math.sin(theta)];
    },

    /* Convert a polar coordinate into a cartesian coordinate
     *
     * Examples:
     * cartFromPolarDeg(5, 30)
     * cartFromPolarDeg([5, 30])
     */
    cartFromPolarDeg: function(radius, theta) {
        if (_.isUndefined(theta)) {
            theta = radius[1];
            radius = radius[0];
        }

        return kvector.cartFromPolarRad(radius, theta * Math.PI / 180);
    },

    // Rotate vector
    rotateRad: function(v, theta) {
        var polar = kvector.polarRadFromCart(v);
        var angle = polar[1] + theta;
        return kvector.cartFromPolarRad(polar[0], angle);
    },

    rotateDeg: function(v, theta) {
        var polar = kvector.polarDegFromCart(v);
        var angle = polar[1] + theta;
        return kvector.cartFromPolarDeg(polar[0], angle);
    },

    // Angle between two vectors
    angleRad: function(v1, v2) {
        return Math.acos(kvector.dot(v1, v2) /
            (kvector.length(v1) * kvector.length(v2)));
    },

    angleDeg: function(v1, v2) {
        return kvector.angleRad(v1, v2) * 180 / Math.PI;
    },

    // Vector projection of v1 onto v2
    projection: function(v1, v2) {
        var scalar = kvector.dot(v1, v2) / kvector.dot(v2, v2);
        return kvector.scale(v2, scalar);
    },

    // Round each number to a certain number of decimal places
    round: function(vec, precision) {
        return _.map(vec, function(elem, i) {
            return knumber.round(elem, precision[i] || precision);
        });
    },

    // Round each number to the nearest increment
    roundTo: function(vec, increment) {
        return _.map(vec, function(elem, i) {
            return knumber.roundTo(elem, increment[i] || increment);
        });
    },

    floorTo: function(vec, increment) {
        return _.map(vec, function(elem, i) {
            return knumber.floorTo(elem, increment[i] || increment);
        });
    },

    ceilTo: function(vec, increment) {
        return _.map(vec, function(elem, i) {
            return knumber.ceilTo(elem, increment[i] || increment);
        });
    }
};

return kvector;

});

/*
 * Point Utils
 * A point is an array of two numbers e.g. [0, 0].
 */
define('utils/kpoint.js',['require','./kvector.js','./knumber.js'],function(require) {

var kvector = require("./kvector.js");
var knumber = require("./knumber.js");

var kpoint = KhanUtil.kpoint = {

    // Rotate point (around origin unless a center is specified)
    rotateRad: function(point, theta, center) {
        if (center === undefined) {
            return kvector.rotateRad(point, theta);
        } else {
            return kvector.add(
                center,
                kvector.rotateRad(
                    kvector.subtract(point, center),
                    theta
                )
            );
        }
    },

    rotateDeg: function(point, theta, center) {
        if (center === undefined) {
            return kvector.rotateDeg(point, theta);
        } else {
            return kvector.add(
                center,
                kvector.rotateDeg(
                    kvector.subtract(point, center),
                    theta
                )
            );
        }
    },

    // Distance between two points
    distanceToPoint: function(point1, point2) {
        return kvector.length(kvector.subtract(point1, point2));
    },

    // Distance between point and line
    distanceToLine: function(point, line) {
        var lv = kvector.subtract(line[1], line[0]);
        var pv = kvector.subtract(point, line[0]);
        var projectedPv = kvector.projection(pv, lv);
        var distancePv = kvector.subtract(projectedPv, pv);
        return kvector.length(distancePv);
    },

    // Reflect point over line
    reflectOverLine: function(point, line) {
        var lv = kvector.subtract(line[1], line[0]);
        var pv = kvector.subtract(point, line[0]);
        var projectedPv = kvector.projection(pv, lv);
        var reflectedPv = kvector.subtract(kvector.scale(projectedPv, 2), pv);
        return kvector.add(line[0], reflectedPv);
    },

    /**
     * Compares two points, returning -1, 0, or 1, for use with
     * Array.prototype.sort
     *
     * Note: This technically doesn't satisfy the total-ordering
     * requirements of Array.prototype.sort unless equalityTolerance
     * is 0. In some cases very close points that compare within a
     * few equalityTolerances could appear in the wrong order.
     */
    compare: function(point1, point2, equalityTolerance) {
        if (point1.length !== point2.length) {
            return point1.length - point2.length;
        }
        for (var i = 0; i < point1.length; i++) {
            if (!knumber.equal(point1[i], point2[i], equalityTolerance)) {
                return point1[i] - point2[i];
            }
        }
        return 0;
    }
};

_.extend(kpoint, {
    // Check if a value is a point
    is: kvector.is,

    // Add and subtract vector(s)
    addVector: kvector.add,
    addVectors: kvector.add,
    subtractVector: kvector.subtract,
    equal: kvector.equal,

    // Convert from cartesian to polar and back
    polarRadFromCart: kvector.polarRadFromCart,
    polarDegFromCart: kvector.polarDegFromCart,
    cartFromPolarRad: kvector.cartFromPolarRad,
    cartFromPolarDeg: kvector.cartFromPolarDeg,

    // Rounding
    round: kvector.round,
    roundTo: kvector.roundTo,
    floorTo: kvector.floorTo,
    ceilTo: kvector.ceilTo
});

return kpoint;

});

/*
 * Ray Utils
 * A ray is an array of an endpoint and another point along the ray.
 * For example, [[0, 0], [1, 0]] is the ray starting at the origin and
 * traveling along the positive x-axis.
 */
define('utils/kray.js',['require','./kvector.js','./kpoint.js'],function(require) {

var kvector = require("./kvector.js");
var kpoint = require("./kpoint.js");

var kray = KhanUtil.kray = {

    equal: function(ray1, ray2, tolerance) {
        // Compare the directions of the rays
        var v1 = kvector.subtract(ray1[1],ray1[0]);
        var v2 = kvector.subtract(ray2[1],ray2[0]);

        var sameOrigin = kpoint.equal(ray1[0], ray2[0]);
        var codirectional = kvector.codirectional(v1, v2, tolerance);

        return sameOrigin && codirectional;
    }
};

return kray;

});

define('utils/algebra-intuition.js',['require'],function(require) {

KhanUtil.scale = {
    orig: {
        unknown: 1,
        leftCoef: 1,
        leftConst: 5,
        rightCoef: 0,
        rightConst: 6
    },
    unknown: 1,
    leftCoef: 1,
    leftConst: 5,
    rightCoef: 0,
    rightConst: 6,
    angle: 0,
    baseY: -6,
    image: "/images/avatars/mr-pink.png",
    equation: {
        eqLabel: {remove: function() {}},
        leftCoefLabel: {remove: function() {}},
        leftLabel: {remove: function() {}},
        rightLabel: {remove: function() {}},
        yPos: -10.5,

        init: function(options) {
            this.graphie = KhanUtil.scale.graphie;
            $.extend(this, options);

            this.graphie.raphael.image(KhanUtil.scale.image,
                this.graphie.scalePoint([-7.8, this.yPos + 1.2])[0],
                this.graphie.scalePoint([-7.8, this.yPos + 1.2])[1],
                40, 40).attr({
                    opacity: 1
                });
        },
        draw: function(x, n, a, b) {
            this.eqLabel.remove();
            this.leftCoefLabel.remove();
            this.leftLabel.remove();
            this.rightLabel.remove();

            if (a + x === b) {
                this.eqLabel = this.graphie.label([0, this.yPos],
                    "\\Huge{=}");
            } else {
                this.eqLabel = this.graphie.label([0, this.yPos],
                    "\\Huge{\\ne}");
            }
            if (n !== 1) {
                this.leftCoefLabel = this.graphie.label([-6.8, this.yPos],
                    "\\Huge{" + n + "(\\qquad\\quad)}");
            } else {
                this.leftCoefLabel = {remove: function() {}};
            }
            if (a !== 0) {
                this.leftLabel = this.graphie.label([-3.7, this.yPos],
                    "\\Huge{{} + " + a + "}");
            } else {
                this.leftLabel = {remove: function() {}};
            }
            this.rightLabel = this.graphie.label([3.5, this.yPos],
                "\\Huge{" + b + "}");
        }
    },

    addWeight: function(xOffset, yOffset, num, dish) {
        var weights = [];
        _(10).times(function(n) {
            var weight = {};
            /*
            var pos = [
                [-1.15, 0.05],
                [0.15, 0.05],
                [-0.5, 1.05],
                [-2.45, 0.05],
                [-1.8, 1.05],
                [-1.15, 2.05],
                [1.45, 0.05],
                [0.8, 1.05],
                [0.15, 2.05],
                [-0.5, 3.05]
            ][n];
            */
            var pos = [
                [-1, 0.0],
                [0, 0.0],
                [-0.5, 1.0],
                [-2, 0.0],
                [-1.5, 1.0],
                [-1, 2.0],
                [1, 0.0],
                [0.5, 1.0],
                [0, 2.0],
                [-0.5, 3.0]
            ][n];

            weight.kgMass = KhanUtil.scale.graphie.path([
                    [pos[0] + xOffset, pos[1] + yOffset],
                    [pos[0] + xOffset + 1, pos[1] + yOffset],
                    [pos[0] + xOffset + 1, pos[1] + yOffset + 1],
                    [pos[0] + xOffset, pos[1] + yOffset + 1], true], {
                strokeWidth: 1,
                stroke: "#994499",
                fill: KhanUtil.PURPLE
            });

            weight.lbl = KhanUtil.scale.graphie.raphael.text(
                KhanUtil.scale.graphie.scalePoint([pos[0] + xOffset + 0.5,
                            pos[1] + yOffset + 0.5])[0],
                KhanUtil.scale.graphie.scalePoint([pos[0] + xOffset + 0.5,
                            pos[1] + yOffset + 0.5])[1], "1");
            weight.lbl.attr({
                "font-size": 15,
                "font-weight": "bold",
                "font-family": "inherit",
                "stroke": "#fff",
                "fill": "#fff"
            });
            weights[n] = weight;
            dish.push(weight.kgMass);
            dish.push(weight.lbl);
            if (n >= num) {
                weight.kgMass.attr({opacity: 0, translation: "0 -40"});
                weight.lbl.attr({opacity: 0, translation: "0 -40"});
            }
            weight.remove = function(speed) {
                if (speed == null) {
                    speed = 300;
                }
                this.kgMass.animate({
                    "opacity": 0.0,
                    "translation": "0 -40"
                }, speed);
                this.lbl.animate({
                    "opacity": 0.0,
                    "translation": "0 -40"
                }, speed);
            };
            weight.add = function(speed) {
                if (speed == null) {
                    speed = 300;
                }
                this.kgMass.animate({
                    "opacity": 1.0,
                    "translation": "0 40"
                }, speed);
                this.lbl.animate({
                    "opacity": 1.0,
                    "translation": "0 40"
                }, speed);
            };
        });
        return weights;
    },

    balance: function(speed) {
        if (speed == null) {
            speed = 500;
        }
        var newAngle = 0;
        var currentAngle = this.angle;
        this.equation.draw(this.unknown, this.leftCoef,
            this.leftConst, this.rightConst);

        if (this.leftConst + this.unknown < this.rightConst) {
            newAngle = 8;
        } else if (this.leftConst + this.unknown > this.rightConst) {
            newAngle = -8;
        }
        $({r: this.angle}).animate({r: newAngle}, {
            duration: speed,
            step: function(now, fx) {
                var dist = 5.5 * Math.sin(now * Math.PI / 180) *
                        KhanUtil.currentGraph.scale[1];
                var leftPos = KhanUtil.scale.leftDishItems[0].
                        attr("translation").y;
                var rightPos = KhanUtil.scale.rightDishItems[0].
                        attr("translation").y;
                KhanUtil.scale.angle = now;
                KhanUtil.scale.beamItems.rotate(now, [0, 0]);
                KhanUtil.scale.leftDishItems.translate([0, -dist - leftPos]);
                KhanUtil.scale.rightDishItems.translate([0, dist - rightPos]);
            }
        });
        if (_.isFunction(this.onChange)) {
            this.onChange(this.leftCoef, this.leftConst,
                this.rightCoef, this.rightConst);
        }
    },

    subtractLeftWeight: function() {
        this.leftConst -= 1;
        this.leftWeight[this.leftConst].remove();
        this.balance();
    },

    addLeftWeight: function() {
        this.leftWeight[this.leftConst].add();
        this.leftConst += 1;
        this.balance();
    },

    setLeftWeight: function(weight) {
        while (this.leftConst !== weight) {
            if (this.leftConst < weight) {
                this.leftWeight[this.leftConst].add(0);
                this.leftConst += 1;
            } else {
                this.leftConst -= 1;
                this.leftWeight[this.leftConst].remove(0);
            }
        }
        this.balance(0);
    },

    subtractRightWeight: function() {
        this.rightConst -= 1;
        this.rightWeight[this.rightConst].remove();
        this.balance();
    },

    addRightWeight: function() {
        this.rightWeight[this.rightConst].add();
        this.rightConst += 1;
        this.balance();
    },

    setRightWeight: function(weight) {
        while (this.rightConst !== weight) {
            if (this.rightConst < weight) {
                this.rightWeight[this.rightConst].add(0);
                this.rightConst += 1;
            } else {
                this.rightConst -= 1;
                this.rightWeight[this.rightConst].remove(0);
            }
        }
        this.balance(0);
    },

    resetProblem: function() {
        while (this.leftConst !== this.orig.leftConst) {
            if (this.leftConst < this.orig.leftConst) {
                this.leftWeight[this.leftConst].add();
                this.leftConst += 1;
            } else {
                this.leftConst -= 1;
                this.leftWeight[this.leftConst].remove();
            }
        }
        while (this.rightConst !== this.orig.rightConst) {
            if (this.rightConst < this.orig.rightConst) {
                this.rightWeight[this.rightConst].add();
                this.rightConst += 1;
            } else {
                this.rightConst -= 1;
                this.rightWeight[this.rightConst].remove();
            }
        }
        this.balance();
    },

    init: function(options) {
        this.graphie = KhanUtil.currentGraph;
        $.extend(this, options);

        // Save the original problem
        this.orig.unknown = this.unknown;
        this.orig.leftCoef = this.leftCoef;
        this.orig.leftConst = this.leftConst;
        this.orig.rightCoef = this.rightCoef;
        this.orig.rightConst = this.rightConst;

        Khan.scratchpad.disable();
        this.graphie.init({
            range: [[-12, 12], [-12, 1.5]],
            scale: [20, 20]
        });

        this.leftWire1 = this.graphie.path(
            [[-9, this.baseY - 0.1], [-5.5, 0]], {
                stroke: KhanUtil.BLACK,
                strokeWidth: 0.5
            });
        this.leftWire2 = this.graphie.path(
            [[-2, this.baseY - 0.1], [-5.5, 0]], {
                stroke: KhanUtil.BLACK,
                strokeWidth: 0.5
            });

        this.rightWire1 = this.graphie.path(
            [[9, this.baseY - 0.1], [5.5, 0]], {
                stroke: KhanUtil.BLACK,
                strokeWidth: 0.5
            });
        this.rightWire2 = this.graphie.path(
            [[2, this.baseY - 0.1], [5.5, 0]], {
                stroke: KhanUtil.BLACK,
                strokeWidth: 0.5
            });

        this.leftDish = this.graphie.path(
            [[-9, this.baseY], [-2, this.baseY], [-2, this.baseY - 0.2], [-9, this.baseY - 0.2], true], {
                stroke: null,
                fill: KhanUtil.BLUE
            });
        this.rightDish = this.graphie.path(
            [[9, this.baseY], [2, this.baseY], [2, this.baseY - 0.2], [9, this.baseY - 0.2], true], {
                stroke: null,
                fill: KhanUtil.BLUE
            });

        this.leftDishItems = this.graphie.raphael.set();
        this.rightDishItems = this.graphie.raphael.set();
        this.leftDishItems.push(this.leftWire1);
        this.leftDishItems.push(this.leftWire2);
        this.leftDishItems.push(this.leftDish);
        this.rightDishItems.push(this.rightWire1);
        this.rightDishItems.push(this.rightWire2);
        this.rightDishItems.push(this.rightDish);

        this.leftWeight = this.addWeight(-4.5, this.baseY, this.leftConst, this.leftDishItems);
        this.rightWeight = this.addWeight(5.5, this.baseY, this.rightConst, this.rightDishItems);

        this.leftDishItems.push(this.graphie.raphael.image(this.image,
            this.graphie.scalePoint([-8.9, this.baseY + 2.40])[0],
            this.graphie.scalePoint([-8.9, this.baseY + 2.40])[1], 50, 50));

        this.beamItems = this.graphie.raphael.set();
        this.beam = this.graphie.path(
            [[-5.8, -0.1], [5.8, -0.1], [5.8, 0.1], [-5.8, 0.1], true], {
                stroke: null,
                fill: KhanUtil.BLUE
            });
        this.beamPointer = this.graphie.path(
            [[-0.1, 0], [0.1, 0], [0.1, 1], [-0.1, 1], true], {
                stroke: null,
                fill: KhanUtil.BLUE
            });
        this.beamItems.push(this.beam);
        this.beamItems.push(this.beamPointer);

        this.fulcrumBase = this.graphie.path(
            [[0, -7], [1.2, -8.5], [-1.2, -8.5], true], {
                stroke: null,
                fill: KhanUtil.BLUE
            });
        this.fulcrum = this.graphie.path(
            [[-0.2, -8], [0.2, -8], [0.2, 0], [-0.2, 0], true], {
                stroke: null,
                fill: KhanUtil.BLUE
            });

        this.fulcrumJoint1 = this.graphie.circle(
            [0, 0], 0.6, {
                stroke: null,
                fill: KhanUtil.BLUE
            });

        this.fulcrumJoint2 = this.graphie.circle(
            [0, 0], 0.4, {
                stroke: null,
                fill: '#fff'
            });

        this.equation.init();
        this.balance();
    }
};

});

define('utils/angles.js',['require'],function(require) {

$.extend(KhanUtil, {
    commonAngles: [
        {deg: 15, rad: "\\frac{\\pi}{12}"},
        {deg: 30, rad: "\\frac{\\pi}{6}"},
        {deg: 45, rad: "\\frac{\\pi}{4}"},
        {deg: 60, rad: "\\frac{\\pi}{3}"},
        {deg: 90, rad: "\\frac{\\pi}{2}"},
        {deg: 120, rad: "\\frac{2\\pi}{3}"},
        {deg: 135, rad: "\\frac{3\\pi}{4}"},
        {deg: 150, rad: "\\frac{5\\pi}{6}"},
        {deg: 180, rad: "\\pi"},
        {deg: 210, rad: "\\frac{7\\pi}{6}"},
        {deg: 225, rad: "\\frac{5\\pi}{4}"},
        {deg: 240, rad: "\\frac{4\\pi}{3}"},
        {deg: 270, rad: "\\frac{3\\pi}{2}"},
        {deg: 300, rad: "\\frac{5\\pi}{3}"},
        {deg: 315, rad: "\\frac{7\\pi}{4}"},
        {deg: 330, rad: "\\frac{11\\pi}{6}"},
        {deg: 360, rad: "2\\pi"}
    ],

    // Convert a degree value to a radian value
    toRadians: function(degrees) {
        return degrees * Math.PI / 180;
    },

    // Convert a radian value to a degree value
    toDegrees: function(radians) {
        return radians * 180 / Math.PI;
    }
});

});

/*!
 * Raphael 1.5.2 - JavaScript Vector Library
 *
 * Copyright (c) 2010 Dmitry Baranovskiy (http://raphaeljs.com)
 * Licensed under the MIT (http://raphaeljs.com/license.html) license.
 */
(function () {
    var setAttr;
    if ("".trim) {
        setAttr = function(node, att, value) {
            node.setAttribute(att, String(value).trim());
        };
    } else {
        setAttr = function(node, att, value) {
            node.setAttribute(att, String(value));
        };
    }
    function R() {
        if (R.is(arguments[0], array)) {
            var a = arguments[0],
                cnv = create[apply](R, a.splice(0, 3 + R.is(a[0], nu))),
                res = cnv.set();
            for (var i = 0, ii = a[length]; i < ii; i++) {
                var j = a[i] || {};
                elements[has](j.type) && res[push](cnv[j.type]().attr(j));
            }
            return res;
        }
        return create[apply](R, arguments);
    }
    R.version = "1.5.2";
    var separator = /[, ]+/,
        elements = {circle: 1, rect: 1, path: 1, ellipse: 1, text: 1, image: 1},
        formatrg = /\{(\d+)\}/g,
        proto = "prototype",
        has = "hasOwnProperty",
        doc = document,
        win = window,
        oldRaphael = {
            was: Object[proto][has].call(win, "Raphael"),
            is: win.Raphael
        },
        Paper = function () {
            this.customAttributes = {};
        },
        paperproto,
        appendChild = "appendChild",
        apply = "apply",
        concat = "concat",
        supportsTouch = "createTouch" in doc,
        E = "",
        S = " ",
        Str = String,
        split = "split",
        events = "click dblclick mousedown mousemove mouseout mouseover mouseup touchstart touchmove touchend orientationchange touchcancel gesturestart gesturechange gestureend"[split](S),
        touchMap = {
            mousedown: "touchstart",
            mousemove: "touchmove",
            mouseup: "touchend"
        },
        join = "join",
        length = "length",
        lowerCase = Str[proto].toLowerCase,
        math = Math,
        mmax = math.max,
        mmin = math.min,
        abs = math.abs,
        pow = math.pow,
        PI = math.PI,
        nu = "number",
        string = "string",
        array = "array",
        toString = "toString",
        fillString = "fill",
        objectToString = Object[proto][toString],
        paper = {},
        push = "push",
        ISURL = /^url\(['"]?([^\)]+?)['"]?\)$/i,
        colourRegExp = /^\s*((#[a-f\d]{6})|(#[a-f\d]{3})|rgba?\(\s*([\d\.]+%?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?)%?\s*\)|hsba?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?)%?\s*\)|hsla?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?)%?\s*\))\s*$/i,
        isnan = {"NaN": 1, "Infinity": 1, "-Infinity": 1},
        bezierrg = /^(?:cubic-)?bezier\(([^,]+),([^,]+),([^,]+),([^\)]+)\)/,
        round = math.round,
        toFloat = parseFloat,
        toInt = parseInt,
        ms = " progid:DXImageTransform.Microsoft",
        upperCase = Str[proto].toUpperCase,
        availableAttrs = {blur: 0, "clip-rect": "0 0 1e9 1e9", cursor: "default", cx: 0, cy: 0, fill: "#fff", "fill-opacity": 1, font: '10px "Arial"', "font-family": '"Arial"', "font-size": "10", "font-style": "normal", "font-weight": 400, gradient: 0, height: 0, href: "http://raphaeljs.com/", opacity: 1, path: "M0,0", r: 0, rotation: 0, rx: 0, ry: 0, scale: "1 1", src: "", stroke: "#000", "stroke-dasharray": "", "stroke-linecap": "butt", "stroke-linejoin": "butt", "stroke-miterlimit": 0, "stroke-opacity": 1, "stroke-width": 1, target: "_blank", "text-anchor": "middle", title: "Raphael", translation: "0 0", width: 0, x: 0, y: 0},
        availableAnimAttrs = {along: "along", blur: nu, "clip-rect": "csv", cx: nu, cy: nu, fill: "colour", "fill-opacity": nu, "font-size": nu, height: nu, opacity: nu, path: "path", r: nu, rotation: "csv", rx: nu, ry: nu, scale: "csv", stroke: "colour", "stroke-opacity": nu, "stroke-width": nu, translation: "csv", width: nu, x: nu, y: nu},
        rp = "replace",
        animKeyFrames= /^(from|to|\d+%?)$/,
        commaSpaces = /\s*,\s*/,
        hsrg = {hs: 1, rg: 1},
        p2s = /,?([achlmqrstvxz]),?/gi,
        pathCommand = /([achlmqstvz])[\s,]*((-?\d*\.?\d*(?:e[-+]?\d+)?\s*,?\s*)+)/ig,
        pathValues = /(-?\d*\.?\d*(?:e[-+]?\d+)?)\s*,?\s*/ig,
        radial_gradient = /^r(?:\(([^,]+?)\s*,\s*([^\)]+?)\))?/,
        sortByKey = function (a, b) {
            return a.key - b.key;
        };

    R.type = (win.SVGAngle || doc.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1") ? "SVG" : "VML");
    if (R.type == "VML") {
        var d = doc.createElement("div"),
            b;
        d.innerHTML = '<v:shape adj="1"/>';
        b = d.firstChild;
        b.style.behavior = "url(#default#VML)";
        if (!(b && typeof b.adj == "object")) {
            return R.type = null;
        }
        d = null;
    }
    R.svg = !(R.vml = R.type == "VML");
    Paper[proto] = R[proto];
    paperproto = Paper[proto];
    R._id = 0;
    R._oid = 0;
    R.fn = {};
    R.is = function (o, type) {
        type = lowerCase.call(type);
        if (type == "finite") {
            return !isnan[has](+o);
        }
        return  (type == "null" && o === null) ||
                (type == typeof o) ||
                (type == "object" && o === Object(o)) ||
                (type == "array" && Array.isArray && Array.isArray(o)) ||
                objectToString.call(o).slice(8, -1).toLowerCase() == type;
    };
    R.angle = function (x1, y1, x2, y2, x3, y3) {
        if (x3 == null) {
            var x = x1 - x2,
                y = y1 - y2;
            if (!x && !y) {
                return 0;
            }
            return ((x < 0) * 180 + math.atan(-y / -x) * 180 / PI + 360) % 360;
        } else {
            return R.angle(x1, y1, x3, y3) - R.angle(x2, y2, x3, y3);
        }
    };
    R.rad = function (deg) {
        return deg % 360 * PI / 180;
    };
    R.deg = function (rad) {
        return rad * 180 / PI % 360;
    };
    R.snapTo = function (values, value, tolerance) {
        tolerance = R.is(tolerance, "finite") ? tolerance : 10;
        if (R.is(values, array)) {
            var i = values.length;
            while (i--) if (abs(values[i] - value) <= tolerance) {
                return values[i];
            }
        } else {
            values = +values;
            var rem = value % values;
            if (rem < tolerance) {
                return value - rem;
            }
            if (rem > values - tolerance) {
                return value - rem + values;
            }
        }
        return value;
    };
    function createUUID() {
        // http://www.ietf.org/rfc/rfc4122.txt
        var s = [],
            i = 0;
        for (; i < 32; i++) {
            s[i] = (~~(math.random() * 16))[toString](16);
        }
        s[12] = 4;  // bits 12-15 of the time_hi_and_version field to 0010
        s[16] = ((s[16] & 3) | 8)[toString](16);  // bits 6-7 of the clock_seq_hi_and_reserved to 01
        return "r-" + s[join]("");
    }

    R.setWindow = function (newwin) {
        win = newwin;
        doc = win.document;
    };
    // colour utilities
    var toHex = function (color) {
        if (R.vml) {
            // http://dean.edwards.name/weblog/2009/10/convert-any-colour-value-to-hex-in-msie/
            var trim = /^\s+|\s+$/g;
            var bod;
            try {
                var docum = new ActiveXObject("htmlfile");
                docum.write("<body>");
                docum.close();
                bod = docum.body;
            } catch(e) {
                bod = createPopup().document.body;
            }
            var range = bod.createTextRange();
            toHex = cacher(function (color) {
                try {
                    bod.style.color = Str(color)[rp](trim, E);
                    var value = range.queryCommandValue("ForeColor");
                    value = ((value & 255) << 16) | (value & 65280) | ((value & 16711680) >>> 16);
                    return "#" + ("000000" + value[toString](16)).slice(-6);
                } catch(e) {
                    return "none";
                }
            });
        } else {
            var i = doc.createElement("i");
            i.title = "Rapha\xebl Colour Picker";
            i.style.display = "none";
            doc.body[appendChild](i);
            toHex = cacher(function (color) {
                i.style.color = color;
                return doc.defaultView.getComputedStyle(i, E).getPropertyValue("color");
            });
        }
        return toHex(color);
    },
    hsbtoString = function () {
        return "hsb(" + [this.h, this.s, this.b] + ")";
    },
    hsltoString = function () {
        return "hsl(" + [this.h, this.s, this.l] + ")";
    },
    rgbtoString = function () {
        return this.hex;
    };
    R.hsb2rgb = function (h, s, b, o) {
        if (R.is(h, "object") && "h" in h && "s" in h && "b" in h) {
            b = h.b;
            s = h.s;
            h = h.h;
            o = h.o;
        }
        return R.hsl2rgb(h, s, b / 2, o);
    };
    R.hsl2rgb = function (h, s, l, o) {
        if (R.is(h, "object") && "h" in h && "s" in h && "l" in h) {
            l = h.l;
            s = h.s;
            h = h.h;
        }
        if (h > 1 || s > 1 || l > 1) {
            h /= 360;
            s /= 100;
            l /= 100;
        }
        var rgb = {},
            channels = ["r", "g", "b"],
            t2, t1, t3, r, g, b;
        if (!s) {
            rgb = {
                r: l,
                g: l,
                b: l
            };
        } else {
            if (l < .5) {
                t2 = l * (1 + s);
            } else {
                t2 = l + s - l * s;
            }
            t1 = 2 * l - t2;
            for (var i = 0; i < 3; i++) {
                t3 = h + 1 / 3 * -(i - 1);
                t3 < 0 && t3++;
                t3 > 1 && t3--;
                if (t3 * 6 < 1) {
                    rgb[channels[i]] = t1 + (t2 - t1) * 6 * t3;
                } else if (t3 * 2 < 1) {
                    rgb[channels[i]] = t2;
                } else if (t3 * 3 < 2) {
                    rgb[channels[i]] = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
                } else {
                    rgb[channels[i]] = t1;
                }
            }
        }
        rgb.r *= 255;
        rgb.g *= 255;
        rgb.b *= 255;
        rgb.hex = "#" + (16777216 | rgb.b | (rgb.g << 8) | (rgb.r << 16)).toString(16).slice(1);
        R.is(o, "finite") && (rgb.opacity = o);
        rgb.toString = rgbtoString;
        return rgb;
    };
    R.rgb2hsb = function (red, green, blue) {
        if (green == null && R.is(red, "object") && "r" in red && "g" in red && "b" in red) {
            blue = red.b;
            green = red.g;
            red = red.r;
        }
        if (green == null && R.is(red, string)) {
            var clr = R.getRGB(red);
            red = clr.r;
            green = clr.g;
            blue = clr.b;
        }
        if (red > 1 || green > 1 || blue > 1) {
            red /= 255;
            green /= 255;
            blue /= 255;
        }
        var max = mmax(red, green, blue),
            min = mmin(red, green, blue),
            hue,
            saturation,
            brightness = max;
        if (min == max) {
            return {h: 0, s: 0, b: max, toString: hsbtoString};
        } else {
            var delta = (max - min);
            saturation = delta / max;
            if (red == max) {
                hue = (green - blue) / delta;
            } else if (green == max) {
                hue = 2 + ((blue - red) / delta);
            } else {
                hue = 4 + ((red - green) / delta);
            }
            hue /= 6;
            hue < 0 && hue++;
            hue > 1 && hue--;
        }
        return {h: hue, s: saturation, b: brightness, toString: hsbtoString};
    };
    R.rgb2hsl = function (red, green, blue) {
        if (green == null && R.is(red, "object") && "r" in red && "g" in red && "b" in red) {
            blue = red.b;
            green = red.g;
            red = red.r;
        }
        if (green == null && R.is(red, string)) {
            var clr = R.getRGB(red);
            red = clr.r;
            green = clr.g;
            blue = clr.b;
        }
        if (red > 1 || green > 1 || blue > 1) {
            red /= 255;
            green /= 255;
            blue /= 255;
        }
        var max = mmax(red, green, blue),
            min = mmin(red, green, blue),
            h,
            s,
            l = (max + min) / 2,
            hsl;
        if (min == max) {
            hsl =  {h: 0, s: 0, l: l};
        } else {
            var delta = max - min;
            s = l < .5 ? delta / (max + min) : delta / (2 - max - min);
            if (red == max) {
                h = (green - blue) / delta;
            } else if (green == max) {
                h = 2 + (blue - red) / delta;
            } else {
                h = 4 + (red - green) / delta;
            }
            h /= 6;
            h < 0 && h++;
            h > 1 && h--;
            hsl = {h: h, s: s, l: l};
        }
        hsl.toString = hsltoString;
        return hsl;
    };
    R._path2string = function () {
        return this.join(",")[rp](p2s, "$1");
    };
    function cacher(f, scope, postprocessor) {
        function newf() {
            var arg = Array[proto].slice.call(arguments, 0),
                args = arg[join]("\u25ba"),
                cache = newf.cache = newf.cache || {},
                count = newf.count = newf.count || [];
            if (cache[has](args)) {
                return postprocessor ? postprocessor(cache[args]) : cache[args];
            }
            count[length] >= 1e3 && delete cache[count.shift()];
            count[push](args);
            cache[args] = f[apply](scope, arg);
            return postprocessor ? postprocessor(cache[args]) : cache[args];
        }
        return newf;
    }

    R.getRGB = cacher(function (colour) {
        if (!colour || !!((colour = Str(colour)).indexOf("-") + 1)) {
            return {r: -1, g: -1, b: -1, hex: "none", error: 1};
        }
        if (colour == "none") {
            return {r: -1, g: -1, b: -1, hex: "none"};
        }
        !(hsrg[has](colour.toLowerCase().substring(0, 2)) || colour.charAt() == "#") && (colour = toHex(colour));
        var res,
            red,
            green,
            blue,
            opacity,
            t,
            values,
            rgb = colour.match(colourRegExp);
        if (rgb) {
            if (rgb[2]) {
                blue = toInt(rgb[2].substring(5), 16);
                green = toInt(rgb[2].substring(3, 5), 16);
                red = toInt(rgb[2].substring(1, 3), 16);
            }
            if (rgb[3]) {
                blue = toInt((t = rgb[3].charAt(3)) + t, 16);
                green = toInt((t = rgb[3].charAt(2)) + t, 16);
                red = toInt((t = rgb[3].charAt(1)) + t, 16);
            }
            if (rgb[4]) {
                values = rgb[4][split](commaSpaces);
                red = toFloat(values[0]);
                values[0].slice(-1) == "%" && (red *= 2.55);
                green = toFloat(values[1]);
                values[1].slice(-1) == "%" && (green *= 2.55);
                blue = toFloat(values[2]);
                values[2].slice(-1) == "%" && (blue *= 2.55);
                rgb[1].toLowerCase().slice(0, 4) == "rgba" && (opacity = toFloat(values[3]));
                values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
            }
            if (rgb[5]) {
                values = rgb[5][split](commaSpaces);
                red = toFloat(values[0]);
                values[0].slice(-1) == "%" && (red *= 2.55);
                green = toFloat(values[1]);
                values[1].slice(-1) == "%" && (green *= 2.55);
                blue = toFloat(values[2]);
                values[2].slice(-1) == "%" && (blue *= 2.55);
                (values[0].slice(-3) == "deg" || values[0].slice(-1) == "\xb0") && (red /= 360);
                rgb[1].toLowerCase().slice(0, 4) == "hsba" && (opacity = toFloat(values[3]));
                values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
                return R.hsb2rgb(red, green, blue, opacity);
            }
            if (rgb[6]) {
                values = rgb[6][split](commaSpaces);
                red = toFloat(values[0]);
                values[0].slice(-1) == "%" && (red *= 2.55);
                green = toFloat(values[1]);
                values[1].slice(-1) == "%" && (green *= 2.55);
                blue = toFloat(values[2]);
                values[2].slice(-1) == "%" && (blue *= 2.55);
                (values[0].slice(-3) == "deg" || values[0].slice(-1) == "\xb0") && (red /= 360);
                rgb[1].toLowerCase().slice(0, 4) == "hsla" && (opacity = toFloat(values[3]));
                values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
                return R.hsl2rgb(red, green, blue, opacity);
            }
            rgb = {r: red, g: green, b: blue};
            rgb.hex = "#" + (16777216 | blue | (green << 8) | (red << 16)).toString(16).slice(1);
            R.is(opacity, "finite") && (rgb.opacity = opacity);
            return rgb;
        }
        return {r: -1, g: -1, b: -1, hex: "none", error: 1};
    }, R);
    R.getColor = function (value) {
        var start = this.getColor.start = this.getColor.start || {h: 0, s: 1, b: value || .75},
            rgb = this.hsb2rgb(start.h, start.s, start.b);
        start.h += .075;
        if (start.h > 1) {
            start.h = 0;
            start.s -= .2;
            start.s <= 0 && (this.getColor.start = {h: 0, s: 1, b: start.b});
        }
        return rgb.hex;
    };
    R.getColor.reset = function () {
        delete this.start;
    };
    // path utilities
    R.parsePathString = cacher(function (pathString) {
        if (!pathString) {
            return null;
        }
        var paramCounts = {a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0},
            data = [];
        if (R.is(pathString, array) && R.is(pathString[0], array)) { // rough assumption
            data = pathClone(pathString);
        }
        if (!data[length]) {
            Str(pathString)[rp](pathCommand, function (a, b, c) {
                var params = [],
                    name = lowerCase.call(b);
                c[rp](pathValues, function (a, b) {
                    b && params[push](+b);
                });
                if (name == "m" && params[length] > 2) {
                    data[push]([b][concat](params.splice(0, 2)));
                    name = "l";
                    b = b == "m" ? "l" : "L";
                }
                while (params[length] >= paramCounts[name]) {
                    data[push]([b][concat](params.splice(0, paramCounts[name])));
                    if (!paramCounts[name]) {
                        break;
                    }
                }
            });
        }
        data[toString] = R._path2string;
        return data;
    });
    R.findDotsAtSegment = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
        var t1 = 1 - t,
            x = pow(t1, 3) * p1x + pow(t1, 2) * 3 * t * c1x + t1 * 3 * t * t * c2x + pow(t, 3) * p2x,
            y = pow(t1, 3) * p1y + pow(t1, 2) * 3 * t * c1y + t1 * 3 * t * t * c2y + pow(t, 3) * p2y,
            mx = p1x + 2 * t * (c1x - p1x) + t * t * (c2x - 2 * c1x + p1x),
            my = p1y + 2 * t * (c1y - p1y) + t * t * (c2y - 2 * c1y + p1y),
            nx = c1x + 2 * t * (c2x - c1x) + t * t * (p2x - 2 * c2x + c1x),
            ny = c1y + 2 * t * (c2y - c1y) + t * t * (p2y - 2 * c2y + c1y),
            ax = (1 - t) * p1x + t * c1x,
            ay = (1 - t) * p1y + t * c1y,
            cx = (1 - t) * c2x + t * p2x,
            cy = (1 - t) * c2y + t * p2y,
            alpha = (90 - math.atan((mx - nx) / (my - ny)) * 180 / PI);
        (mx > nx || my < ny) && (alpha += 180);
        return {x: x, y: y, m: {x: mx, y: my}, n: {x: nx, y: ny}, start: {x: ax, y: ay}, end: {x: cx, y: cy}, alpha: alpha};
    };
    var pathDimensions = cacher(function (path) {
        if (!path) {
            return {x: 0, y: 0, width: 0, height: 0};
        }
        path = path2curve(path);
        var x = 0,
            y = 0,
            X = [],
            Y = [],
            p;
        for (var i = 0, ii = path[length]; i < ii; i++) {
            p = path[i];
            if (p[0] == "M") {
                x = p[1];
                y = p[2];
                X[push](x);
                Y[push](y);
            } else {
                var dim = curveDim(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);
                X = X[concat](dim.min.x, dim.max.x);
                Y = Y[concat](dim.min.y, dim.max.y);
                x = p[5];
                y = p[6];
            }
        }
        var xmin = mmin[apply](0, X),
            ymin = mmin[apply](0, Y);
        return {
            x: xmin,
            y: ymin,
            width: mmax[apply](0, X) - xmin,
            height: mmax[apply](0, Y) - ymin
        };
    }),
        pathClone = function (pathArray) {
            var res = [];
            if (!R.is(pathArray, array) || !R.is(pathArray && pathArray[0], array)) { // rough assumption
                pathArray = R.parsePathString(pathArray);
            }
            for (var i = 0, ii = pathArray[length]; i < ii; i++) {
                res[i] = [];
                for (var j = 0, jj = pathArray[i][length]; j < jj; j++) {
                    res[i][j] = pathArray[i][j];
                }
            }
            res[toString] = R._path2string;
            return res;
        },
        pathToRelative = cacher(function (pathArray) {
            if (!R.is(pathArray, array) || !R.is(pathArray && pathArray[0], array)) { // rough assumption
                pathArray = R.parsePathString(pathArray);
            }
            var res = [],
                x = 0,
                y = 0,
                mx = 0,
                my = 0,
                start = 0;
            if (pathArray[0][0] == "M") {
                x = pathArray[0][1];
                y = pathArray[0][2];
                mx = x;
                my = y;
                start++;
                res[push](["M", x, y]);
            }
            for (var i = start, ii = pathArray[length]; i < ii; i++) {
                var r = res[i] = [],
                    pa = pathArray[i];
                if (pa[0] != lowerCase.call(pa[0])) {
                    r[0] = lowerCase.call(pa[0]);
                    switch (r[0]) {
                        case "a":
                            r[1] = pa[1];
                            r[2] = pa[2];
                            r[3] = pa[3];
                            r[4] = pa[4];
                            r[5] = pa[5];
                            r[6] = +(pa[6] - x).toFixed(3);
                            r[7] = +(pa[7] - y).toFixed(3);
                            break;
                        case "v":
                            r[1] = +(pa[1] - y).toFixed(3);
                            break;
                        case "m":
                            mx = pa[1];
                            my = pa[2];
                        default:
                            for (var j = 1, jj = pa[length]; j < jj; j++) {
                                r[j] = +(pa[j] - ((j % 2) ? x : y)).toFixed(3);
                            }
                    }
                } else {
                    r = res[i] = [];
                    if (pa[0] == "m") {
                        mx = pa[1] + x;
                        my = pa[2] + y;
                    }
                    for (var k = 0, kk = pa[length]; k < kk; k++) {
                        res[i][k] = pa[k];
                    }
                }
                var len = res[i][length];
                switch (res[i][0]) {
                    case "z":
                        x = mx;
                        y = my;
                        break;
                    case "h":
                        x += +res[i][len - 1];
                        break;
                    case "v":
                        y += +res[i][len - 1];
                        break;
                    default:
                        x += +res[i][len - 2];
                        y += +res[i][len - 1];
                }
            }
            res[toString] = R._path2string;
            return res;
        }, 0, pathClone),
        pathToAbsolute = cacher(function (pathArray) {
            if (!R.is(pathArray, array) || !R.is(pathArray && pathArray[0], array)) { // rough assumption
                pathArray = R.parsePathString(pathArray);
            }
            var res = [],
                x = 0,
                y = 0,
                mx = 0,
                my = 0,
                start = 0;
            if (pathArray[0][0] == "M") {
                x = +pathArray[0][1];
                y = +pathArray[0][2];
                mx = x;
                my = y;
                start++;
                res[0] = ["M", x, y];
            }
            for (var i = start, ii = pathArray[length]; i < ii; i++) {
                var r = res[i] = [],
                    pa = pathArray[i];
                if (pa[0] != upperCase.call(pa[0])) {
                    r[0] = upperCase.call(pa[0]);
                    switch (r[0]) {
                        case "A":
                            r[1] = pa[1];
                            r[2] = pa[2];
                            r[3] = pa[3];
                            r[4] = pa[4];
                            r[5] = pa[5];
                            r[6] = +(pa[6] + x);
                            r[7] = +(pa[7] + y);
                            break;
                        case "V":
                            r[1] = +pa[1] + y;
                            break;
                        case "H":
                            r[1] = +pa[1] + x;
                            break;
                        case "M":
                            mx = +pa[1] + x;
                            my = +pa[2] + y;
                        default:
                            for (var j = 1, jj = pa[length]; j < jj; j++) {
                                r[j] = +pa[j] + ((j % 2) ? x : y);
                            }
                    }
                } else {
                    for (var k = 0, kk = pa[length]; k < kk; k++) {
                        res[i][k] = pa[k];
                    }
                }
                switch (r[0]) {
                    case "Z":
                        x = mx;
                        y = my;
                        break;
                    case "H":
                        x = r[1];
                        break;
                    case "V":
                        y = r[1];
                        break;
                    case "M":
                        mx = res[i][res[i][length] - 2];
                        my = res[i][res[i][length] - 1];
                    default:
                        x = res[i][res[i][length] - 2];
                        y = res[i][res[i][length] - 1];
                }
            }
            res[toString] = R._path2string;
            return res;
        }, null, pathClone),
        l2c = function (x1, y1, x2, y2) {
            return [x1, y1, x2, y2, x2, y2];
        },
        q2c = function (x1, y1, ax, ay, x2, y2) {
            var _13 = 1 / 3,
                _23 = 2 / 3;
            return [
                    _13 * x1 + _23 * ax,
                    _13 * y1 + _23 * ay,
                    _13 * x2 + _23 * ax,
                    _13 * y2 + _23 * ay,
                    x2,
                    y2
                ];
        },
        a2c = function (x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {
            // for more information of where this math came from visit:
            // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
            var _120 = PI * 120 / 180,
                rad = PI / 180 * (+angle || 0),
                res = [],
                xy,
                rotate = cacher(function (x, y, rad) {
                    var X = x * math.cos(rad) - y * math.sin(rad),
                        Y = x * math.sin(rad) + y * math.cos(rad);
                    return {x: X, y: Y};
                });
            if (!recursive) {
                xy = rotate(x1, y1, -rad);
                x1 = xy.x;
                y1 = xy.y;
                xy = rotate(x2, y2, -rad);
                x2 = xy.x;
                y2 = xy.y;
                var cos = math.cos(PI / 180 * angle),
                    sin = math.sin(PI / 180 * angle),
                    x = (x1 - x2) / 2,
                    y = (y1 - y2) / 2;
                var h = (x * x) / (rx * rx) + (y * y) / (ry * ry);
                if (h > 1) {
                    h = math.sqrt(h);
                    rx = h * rx;
                    ry = h * ry;
                }
                var rx2 = rx * rx,
                    ry2 = ry * ry,
                    k = (large_arc_flag == sweep_flag ? -1 : 1) *
                        math.sqrt(abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x))),
                    cx = k * rx * y / ry + (x1 + x2) / 2,
                    cy = k * -ry * x / rx + (y1 + y2) / 2,
                    f1 = math.asin(((y1 - cy) / ry).toFixed(9)),
                    f2 = math.asin(((y2 - cy) / ry).toFixed(9));

                f1 = x1 < cx ? PI - f1 : f1;
                f2 = x2 < cx ? PI - f2 : f2;
                f1 < 0 && (f1 = PI * 2 + f1);
                f2 < 0 && (f2 = PI * 2 + f2);
                if (sweep_flag && f1 > f2) {
                    f1 = f1 - PI * 2;
                }
                if (!sweep_flag && f2 > f1) {
                    f2 = f2 - PI * 2;
                }
            } else {
                f1 = recursive[0];
                f2 = recursive[1];
                cx = recursive[2];
                cy = recursive[3];
            }
            var df = f2 - f1;
            if (abs(df) > _120) {
                var f2old = f2,
                    x2old = x2,
                    y2old = y2;
                f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
                x2 = cx + rx * math.cos(f2);
                y2 = cy + ry * math.sin(f2);
                res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);
            }
            df = f2 - f1;
            var c1 = math.cos(f1),
                s1 = math.sin(f1),
                c2 = math.cos(f2),
                s2 = math.sin(f2),
                t = math.tan(df / 4),
                hx = 4 / 3 * rx * t,
                hy = 4 / 3 * ry * t,
                m1 = [x1, y1],
                m2 = [x1 + hx * s1, y1 - hy * c1],
                m3 = [x2 + hx * s2, y2 - hy * c2],
                m4 = [x2, y2];
            m2[0] = 2 * m1[0] - m2[0];
            m2[1] = 2 * m1[1] - m2[1];
            if (recursive) {
                return [m2, m3, m4][concat](res);
            } else {
                res = [m2, m3, m4][concat](res)[join]()[split](",");
                var newres = [];
                for (var i = 0, ii = res[length]; i < ii; i++) {
                    newres[i] = i % 2 ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;
                }
                return newres;
            }
        },
        findDotAtSegment = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
            var t1 = 1 - t;
            return {
                x: pow(t1, 3) * p1x + pow(t1, 2) * 3 * t * c1x + t1 * 3 * t * t * c2x + pow(t, 3) * p2x,
                y: pow(t1, 3) * p1y + pow(t1, 2) * 3 * t * c1y + t1 * 3 * t * t * c2y + pow(t, 3) * p2y
            };
        },
        curveDim = cacher(function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {
            var a = (c2x - 2 * c1x + p1x) - (p2x - 2 * c2x + c1x),
                b = 2 * (c1x - p1x) - 2 * (c2x - c1x),
                c = p1x - c1x,
                t1 = (-b + math.sqrt(b * b - 4 * a * c)) / 2 / a,
                t2 = (-b - math.sqrt(b * b - 4 * a * c)) / 2 / a,
                y = [p1y, p2y],
                x = [p1x, p2x],
                dot;
            abs(t1) > "1e12" && (t1 = .5);
            abs(t2) > "1e12" && (t2 = .5);
            if (t1 > 0 && t1 < 1) {
                dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t1);
                x[push](dot.x);
                y[push](dot.y);
            }
            if (t2 > 0 && t2 < 1) {
                dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t2);
                x[push](dot.x);
                y[push](dot.y);
            }
            a = (c2y - 2 * c1y + p1y) - (p2y - 2 * c2y + c1y);
            b = 2 * (c1y - p1y) - 2 * (c2y - c1y);
            c = p1y - c1y;
            t1 = (-b + math.sqrt(b * b - 4 * a * c)) / 2 / a;
            t2 = (-b - math.sqrt(b * b - 4 * a * c)) / 2 / a;
            abs(t1) > "1e12" && (t1 = .5);
            abs(t2) > "1e12" && (t2 = .5);
            if (t1 > 0 && t1 < 1) {
                dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t1);
                x[push](dot.x);
                y[push](dot.y);
            }
            if (t2 > 0 && t2 < 1) {
                dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t2);
                x[push](dot.x);
                y[push](dot.y);
            }
            return {
                min: {x: mmin[apply](0, x), y: mmin[apply](0, y)},
                max: {x: mmax[apply](0, x), y: mmax[apply](0, y)}
            };
        }),
        path2curve = cacher(function (path, path2) {
            var p = pathToAbsolute(path),
                p2 = path2 && pathToAbsolute(path2),
                attrs = {x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null},
                attrs2 = {x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null},
                processPath = function (path, d) {
                    var nx, ny;
                    if (!path) {
                        return ["C", d.x, d.y, d.x, d.y, d.x, d.y];
                    }
                    !(path[0] in {T:1, Q:1}) && (d.qx = d.qy = null);
                    switch (path[0]) {
                        case "M":
                            d.X = path[1];
                            d.Y = path[2];
                            break;
                        case "A":
                            path = ["C"][concat](a2c[apply](0, [d.x, d.y][concat](path.slice(1))));
                            break;
                        case "S":
                            nx = d.x + (d.x - (d.bx || d.x));
                            ny = d.y + (d.y - (d.by || d.y));
                            path = ["C", nx, ny][concat](path.slice(1));
                            break;
                        case "T":
                            d.qx = d.x + (d.x - (d.qx || d.x));
                            d.qy = d.y + (d.y - (d.qy || d.y));
                            path = ["C"][concat](q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));
                            break;
                        case "Q":
                            d.qx = path[1];
                            d.qy = path[2];
                            path = ["C"][concat](q2c(d.x, d.y, path[1], path[2], path[3], path[4]));
                            break;
                        case "L":
                            path = ["C"][concat](l2c(d.x, d.y, path[1], path[2]));
                            break;
                        case "H":
                            path = ["C"][concat](l2c(d.x, d.y, path[1], d.y));
                            break;
                        case "V":
                            path = ["C"][concat](l2c(d.x, d.y, d.x, path[1]));
                            break;
                        case "Z":
                            path = ["C"][concat](l2c(d.x, d.y, d.X, d.Y));
                            break;
                    }
                    return path;
                },
                fixArc = function (pp, i) {
                    if (pp[i][length] > 7) {
                        pp[i].shift();
                        var pi = pp[i];
                        while (pi[length]) {
                            pp.splice(i++, 0, ["C"][concat](pi.splice(0, 6)));
                        }
                        pp.splice(i, 1);
                        ii = mmax(p[length], p2 && p2[length] || 0);
                    }
                },
                fixM = function (path1, path2, a1, a2, i) {
                    if (path1 && path2 && path1[i][0] == "M" && path2[i][0] != "M") {
                        path2.splice(i, 0, ["M", a2.x, a2.y]);
                        a1.bx = 0;
                        a1.by = 0;
                        a1.x = path1[i][1];
                        a1.y = path1[i][2];
                        ii = mmax(p[length], p2 && p2[length] || 0);
                    }
                };
            for (var i = 0, ii = mmax(p[length], p2 && p2[length] || 0); i < ii; i++) {
                p[i] = processPath(p[i], attrs);
                fixArc(p, i);
                p2 && (p2[i] = processPath(p2[i], attrs2));
                p2 && fixArc(p2, i);
                fixM(p, p2, attrs, attrs2, i);
                fixM(p2, p, attrs2, attrs, i);
                var seg = p[i],
                    seg2 = p2 && p2[i],
                    seglen = seg[length],
                    seg2len = p2 && seg2[length];
                attrs.x = seg[seglen - 2];
                attrs.y = seg[seglen - 1];
                attrs.bx = toFloat(seg[seglen - 4]) || attrs.x;
                attrs.by = toFloat(seg[seglen - 3]) || attrs.y;
                attrs2.bx = p2 && (toFloat(seg2[seg2len - 4]) || attrs2.x);
                attrs2.by = p2 && (toFloat(seg2[seg2len - 3]) || attrs2.y);
                attrs2.x = p2 && seg2[seg2len - 2];
                attrs2.y = p2 && seg2[seg2len - 1];
            }
            return p2 ? [p, p2] : p;
        }, null, pathClone),
        parseDots = cacher(function (gradient) {
            var dots = [];
            for (var i = 0, ii = gradient[length]; i < ii; i++) {
                var dot = {},
                    par = gradient[i].match(/^([^:]*):?([\d\.]*)/);
                dot.color = R.getRGB(par[1]);
                if (dot.color.error) {
                    return null;
                }
                dot.color = dot.color.hex;
                par[2] && (dot.offset = par[2] + "%");
                dots[push](dot);
            }
            for (i = 1, ii = dots[length] - 1; i < ii; i++) {
                if (!dots[i].offset) {
                    var start = toFloat(dots[i - 1].offset || 0),
                        end = 0;
                    for (var j = i + 1; j < ii; j++) {
                        if (dots[j].offset) {
                            end = dots[j].offset;
                            break;
                        }
                    }
                    if (!end) {
                        end = 100;
                        j = ii;
                    }
                    end = toFloat(end);
                    var d = (end - start) / (j - i + 1);
                    for (; i < j; i++) {
                        start += d;
                        dots[i].offset = start + "%";
                    }
                }
            }
            return dots;
        }),
        getContainer = function (x, y, w, h) {
            var container;
            if (R.is(x, string) || R.is(x, "object")) {
                container = R.is(x, string) ? doc.getElementById(x) : x;
                if (container.tagName) {
                    if (y == null) {
                        return {
                            container: container,
                            width: container.style.pixelWidth || container.offsetWidth,
                            height: container.style.pixelHeight || container.offsetHeight
                        };
                    } else {
                        return {container: container, width: y, height: w};
                    }
                }
            } else {
                return {container: 1, x: x, y: y, width: w, height: h};
            }
        },
        plugins = function (con, add) {
            var that = this;
            for (var prop in add) {
                if (add[has](prop) && !(prop in con)) {
                    switch (typeof add[prop]) {
                        case "function":
                            (function (f) {
                                con[prop] = con === that ? f : function () { return f[apply](that, arguments); };
                            })(add[prop]);
                        break;
                        case "object":
                            con[prop] = con[prop] || {};
                            plugins.call(this, con[prop], add[prop]);
                        break;
                        default:
                            con[prop] = add[prop];
                        break;
                    }
                }
            }
        },
        tear = function (el, paper) {
            el == paper.top && (paper.top = el.prev);
            el == paper.bottom && (paper.bottom = el.next);
            el.next && (el.next.prev = el.prev);
            el.prev && (el.prev.next = el.next);
        },
        tofront = function (el, paper) {
            if (paper.top === el) {
                return;
            }
            tear(el, paper);
            el.next = null;
            el.prev = paper.top;
            paper.top.next = el;
            paper.top = el;
        },
        toback = function (el, paper) {
            if (paper.bottom === el) {
                return;
            }
            tear(el, paper);
            el.next = paper.bottom;
            el.prev = null;
            paper.bottom.prev = el;
            paper.bottom = el;
        },
        insertafter = function (el, el2, paper) {
            tear(el, paper);
            el2 == paper.top && (paper.top = el);
            el2.next && (el2.next.prev = el);
            el.next = el2.next;
            el.prev = el2;
            el2.next = el;
        },
        insertbefore = function (el, el2, paper) {
            tear(el, paper);
            el2 == paper.bottom && (paper.bottom = el);
            el2.prev && (el2.prev.next = el);
            el.prev = el2.prev;
            el2.prev = el;
            el.next = el2;
        },
        removed = function (methodname) {
            return function () {
                throw new Error("Rapha\xebl: you are calling to method \u201c" + methodname + "\u201d of removed object");
            };
        };
    R.pathToRelative = pathToRelative;
    // SVG
    if (R.svg) {
        paperproto.svgns = "http://www.w3.org/2000/svg";
        paperproto.xlink = "http://www.w3.org/1999/xlink";
        round = function (num) {
            return +num + (~~num === num) * .5;
        };
        var $ = function (el, attr) {
            if (attr) {
                for (var key in attr) {
                    if (attr[has](key)) {
                        setAttr(el, key, Str(attr[key]));
                    }
                }
            } else {
                el = doc.createElementNS(paperproto.svgns, el);
                el.style.webkitTapHighlightColor = "rgba(0,0,0,0)";
                return el;
            }
        };
        R[toString] = function () {
            return  "Your browser supports SVG.\nYou are running Rapha\xebl " + this.version;
        };
        var thePath = function (pathString, SVG) {
            var el = $("path");
            SVG.canvas && SVG.canvas[appendChild](el);
            var p = new Element(el, SVG);
            p.type = "path";
            setFillAndStroke(p, {fill: "none", stroke: "#000", path: pathString});
            return p;
        };
        var addGradientFill = function (o, gradient, SVG) {
            var type = "linear",
                fx = .5, fy = .5,
                s = o.style;
            gradient = Str(gradient)[rp](radial_gradient, function (all, _fx, _fy) {
                type = "radial";
                if (_fx && _fy) {
                    fx = toFloat(_fx);
                    fy = toFloat(_fy);
                    var dir = ((fy > .5) * 2 - 1);
                    pow(fx - .5, 2) + pow(fy - .5, 2) > .25 &&
                        (fy = math.sqrt(.25 - pow(fx - .5, 2)) * dir + .5) &&
                        fy != .5 &&
                        (fy = fy.toFixed(5) - 1e-5 * dir);
                }
                return E;
            });
            gradient = gradient[split](/\s*\-\s*/);
            if (type == "linear") {
                var angle = gradient.shift();
                angle = -toFloat(angle);
                if (isNaN(angle)) {
                    return null;
                }
                var vector = [0, 0, math.cos(angle * PI / 180), math.sin(angle * PI / 180)],
                    max = 1 / (mmax(abs(vector[2]), abs(vector[3])) || 1);
                vector[2] *= max;
                vector[3] *= max;
                if (vector[2] < 0) {
                    vector[0] = -vector[2];
                    vector[2] = 0;
                }
                if (vector[3] < 0) {
                    vector[1] = -vector[3];
                    vector[3] = 0;
                }
            }
            var dots = parseDots(gradient);
            if (!dots) {
                return null;
            }
            var id = o.getAttribute(fillString);
            id = id.match(/^url\(#(.*)\)$/);
            id && SVG.defs.removeChild(doc.getElementById(id[1]));

            var el = $(type + "Gradient");
            el.id = createUUID();
            $(el, type == "radial" ? {fx: fx, fy: fy} : {x1: vector[0], y1: vector[1], x2: vector[2], y2: vector[3]});
            SVG.defs[appendChild](el);
            for (var i = 0, ii = dots[length]; i < ii; i++) {
                var stop = $("stop");
                $(stop, {
                    offset: dots[i].offset ? dots[i].offset : !i ? "0%" : "100%",
                    "stop-color": dots[i].color || "#fff"
                });
                el[appendChild](stop);
            }
            $(o, {
                fill: "url(#" + el.id + ")",
                opacity: 1,
                "fill-opacity": 1
            });
            s.fill = E;
            s.opacity = 1;
            s.fillOpacity = 1;
            return 1;
        };
        var updatePosition = function (o) {
            var bbox = o.getBBox();
            $(o.pattern, {patternTransform: R.format("translate({0},{1})", bbox.x, bbox.y)});
        };
        var setFillAndStroke = function (o, params) {
            var dasharray = {
                    "": [0],
                    "none": [0],
                    "-": [3, 1],
                    ".": [1, 1],
                    "-.": [3, 1, 1, 1],
                    "-..": [3, 1, 1, 1, 1, 1],
                    ". ": [1, 3],
                    "- ": [4, 3],
                    "--": [8, 3],
                    "- .": [4, 3, 1, 3],
                    "--.": [8, 3, 1, 3],
                    "--..": [8, 3, 1, 3, 1, 3]
                },
                node = o.node,
                attrs = o.attrs,
                rot = o.rotate(),
                addDashes = function (o, value) {
                    value = dasharray[lowerCase.call(value)];
                    if (value) {
                        var width = o.attrs["stroke-width"] || "1",
                            butt = {round: width, square: width, butt: 0}[o.attrs["stroke-linecap"] || params["stroke-linecap"]] || 0,
                            dashes = [];
                        var i = value[length];
                        while (i--) {
                            dashes[i] = value[i] * width + ((i % 2) ? 1 : -1) * butt;
                        }
                        $(node, {"stroke-dasharray": dashes[join](",")});
                    }
                };
            params[has]("rotation") && (rot = params.rotation);
            var rotxy = Str(rot)[split](separator);
            if (!(rotxy.length - 1)) {
                rotxy = null;
            } else {
                rotxy[1] = +rotxy[1];
                rotxy[2] = +rotxy[2];
            }
            toFloat(rot) && o.rotate(0, true);
            for (var att in params) {
                if (params[has](att)) {
                    if (!availableAttrs[has](att)) {
                        continue;
                    }
                    var value = params[att];
                    attrs[att] = value;
                    switch (att) {
                        case "blur":
                            o.blur(value);
                            break;
                        case "rotation":
                            o.rotate(value, true);
                            break;
                        case "href":
                        case "title":
                        case "target":
                            var pn = node.parentNode;
                            if (lowerCase.call(pn.tagName) != "a") {
                                var hl = $("a");
                                pn.insertBefore(hl, node);
                                hl[appendChild](node);
                                pn = hl;
                            }
                            if (att == "target" && value == "blank") {
                                pn.setAttributeNS(o.paper.xlink, "show", "new");
                            } else {
                                pn.setAttributeNS(o.paper.xlink, att, value);
                            }
                            break;
                        case "cursor":
                            node.style.cursor = value;
                            break;
                        case "clip-rect":
                            var rect = Str(value)[split](separator);
                            if (rect[length] == 4) {
                                o.clip && o.clip.parentNode.parentNode.removeChild(o.clip.parentNode);
                                var el = $("clipPath"),
                                    rc = $("rect");
                                el.id = createUUID();
                                $(rc, {
                                    x: rect[0],
                                    y: rect[1],
                                    width: rect[2],
                                    height: rect[3]
                                });
                                el[appendChild](rc);
                                o.paper.defs[appendChild](el);
                                $(node, {"clip-path": "url(#" + el.id + ")"});
                                o.clip = rc;
                            }
                            if (!value) {
                                var clip = doc.getElementById(node.getAttribute("clip-path")[rp](/(^url\(#|\)$)/g, E));
                                clip && clip.parentNode.removeChild(clip);
                                $(node, {"clip-path": E});
                                delete o.clip;
                            }
                        break;
                        case "path":
                            if (o.type == "path") {
                                $(node, {d: value ? attrs.path = pathToAbsolute(value) : "M0,0"});
                            }
                            break;
                        case "width":
                            setAttr(node, att, value);
                            if (attrs.fx) {
                                att = "x";
                                value = attrs.x;
                            } else {
                                break;
                            }
                        case "x":
                            if (attrs.fx) {
                                value = -attrs.x - (attrs.width || 0);
                            }
                        case "rx":
                            if (att == "rx" && o.type == "rect") {
                                break;
                            }
                        case "cx":
                            rotxy && (att == "x" || att == "cx") && (rotxy[1] += value - attrs[att]);
                            setAttr(node, att, value);
                            o.pattern && updatePosition(o);
                            break;
                        case "height":
                            setAttr(node, att, value);
                            if (attrs.fy) {
                                att = "y";
                                value = attrs.y;
                            } else {
                                break;
                            }
                        case "y":
                            if (attrs.fy) {
                                value = -attrs.y - (attrs.height || 0);
                            }
                        case "ry":
                            if (att == "ry" && o.type == "rect") {
                                break;
                            }
                        case "cy":
                            rotxy && (att == "y" || att == "cy") && (rotxy[2] += value - attrs[att]);
                            setAttr(node, att, value);
                            o.pattern && updatePosition(o);
                            break;
                        case "r":
                            if (o.type == "rect") {
                                $(node, {rx: value, ry: value});
                            } else {
                                setAttr(node, att, value);
                            }
                            break;
                        case "src":
                            if (o.type == "image") {
                                node.setAttributeNS(o.paper.xlink, "href", value);
                            }
                            break;
                        case "stroke-width":
                            node.style.strokeWidth = value;
                            // Need following line for Firefox
                            setAttr(node, att, value);
                            if (attrs["stroke-dasharray"]) {
                                addDashes(o, attrs["stroke-dasharray"]);
                            }
                            break;
                        case "stroke-dasharray":
                            addDashes(o, value);
                            break;
                        case "translation":
                            var xy = Str(value)[split](separator);
                            xy[0] = +xy[0] || 0;
                            xy[1] = +xy[1] || 0;
                            if (rotxy) {
                                rotxy[1] += xy[0];
                                rotxy[2] += xy[1];
                            }
                            translate.call(o, xy[0], xy[1]);
                            break;
                        case "scale":
                            xy = Str(value)[split](separator);
                            o.scale(+xy[0] || 1, +xy[1] || +xy[0] || 1, isNaN(toFloat(xy[2])) ? null : +xy[2], isNaN(toFloat(xy[3])) ? null : +xy[3]);
                            break;
                        case fillString:
                            var isURL = Str(value).match(ISURL);
                            if (isURL) {
                                el = $("pattern");
                                var ig = $("image");
                                el.id = createUUID();
                                $(el, {x: 0, y: 0, patternUnits: "userSpaceOnUse", height: 1, width: 1});
                                $(ig, {x: 0, y: 0});
                                ig.setAttributeNS(o.paper.xlink, "href", isURL[1]);
                                el[appendChild](ig);

                                var img = doc.createElement("img");
                                img.style.cssText = "position:absolute;left:-9999em;top-9999em";
                                img.onload = function () {
                                    $(el, {width: this.offsetWidth, height: this.offsetHeight});
                                    $(ig, {width: this.offsetWidth, height: this.offsetHeight});
                                    doc.body.removeChild(this);
                                    o.paper.safari();
                                };
                                doc.body[appendChild](img);
                                img.src = isURL[1];
                                o.paper.defs[appendChild](el);
                                node.style.fill = "url(#" + el.id + ")";
                                $(node, {fill: "url(#" + el.id + ")"});
                                o.pattern = el;
                                o.pattern && updatePosition(o);
                                break;
                            }
                            var clr = R.getRGB(value);
                            if (!clr.error) {
                                delete params.gradient;
                                delete attrs.gradient;
                                !R.is(attrs.opacity, "undefined") &&
                                    R.is(params.opacity, "undefined") &&
                                    $(node, {opacity: attrs.opacity});
                                !R.is(attrs["fill-opacity"], "undefined") &&
                                    R.is(params["fill-opacity"], "undefined") &&
                                    $(node, {"fill-opacity": attrs["fill-opacity"]});
                            } else if ((({circle: 1, ellipse: 1})[has](o.type) || Str(value).charAt() != "r") && addGradientFill(node, value, o.paper)) {
                                attrs.gradient = value;
                                attrs.fill = "none";
                                break;
                            }
                            clr[has]("opacity") && $(node, {"fill-opacity": clr.opacity > 1 ? clr.opacity / 100 : clr.opacity});
                        case "stroke":
                            clr = R.getRGB(value);
                            setAttr(node, att, clr.hex);
                            att == "stroke" && clr[has]("opacity") && $(node, {"stroke-opacity": clr.opacity > 1 ? clr.opacity / 100 : clr.opacity});
                            break;
                        case "gradient":
                            (({circle: 1, ellipse: 1})[has](o.type) || Str(value).charAt() != "r") && addGradientFill(node, value, o.paper);
                            break;
                        case "opacity":
                            if (attrs.gradient && !attrs[has]("stroke-opacity")) {
                                $(node, {"stroke-opacity": value > 1 ? value / 100 : value});
                            }
                            // fall
                        case "fill-opacity":
                            if (attrs.gradient) {
                                var gradient = doc.getElementById(node.getAttribute(fillString)[rp](/^url\(#|\)$/g, E));
                                if (gradient) {
                                    var stops = gradient.getElementsByTagName("stop");
                                    setAttr(stops[stops[length] - 1], "stop-opacity", value);
                                }
                                break;
                            }
                        default:
                            att == "font-size" && (value = toInt(value, 10) + "px");
                            var cssrule = att[rp](/(\-.)/g, function (w) {
                                return upperCase.call(w.substring(1));
                            });
                            node.style[cssrule] = value;
                            // Need following line for Firefox
                            setAttr(node, att, value);
                            break;
                    }
                }
            }

            tuneText(o, params);
            if (rotxy) {
                o.rotate(rotxy.join(S));
            } else {
                toFloat(rot) && o.rotate(rot, true);
            }
        };
        var leading = 1.2,
        tuneText = function (el, params) {
            if (el.type != "text" || !(params[has]("text") || params[has]("font") || params[has]("font-size") || params[has]("x") || params[has]("y"))) {
                return;
            }
            var a = el.attrs,
                node = el.node,
                fontSize = node.firstChild ? toInt(doc.defaultView.getComputedStyle(node.firstChild, E).getPropertyValue("font-size"), 10) : 10;

            if (params[has]("text")) {
                a.text = params.text;
                while (node.firstChild) {
                    node.removeChild(node.firstChild);
                }
                var texts = Str(params.text)[split]("\n");
                for (var i = 0, ii = texts[length]; i < ii; i++) if (texts[i]) {
                    var tspan = $("tspan");
                    i && $(tspan, {dy: fontSize * leading, x: a.x});
                    tspan[appendChild](doc.createTextNode(texts[i]));
                    node[appendChild](tspan);
                }
            } else {
                texts = node.getElementsByTagName("tspan");
                for (i = 0, ii = texts[length]; i < ii; i++) {
                    i && $(texts[i], {dy: fontSize * leading, x: a.x});
                }
            }
            $(node, {y: a.y});
            var bb = el.getBBox(),
                dif = a.y - (bb.y + bb.height / 2);
            dif && R.is(dif, "finite") && $(node, {y: a.y + dif});
        },
        Element = function (node, svg) {
            var X = 0,
                Y = 0;
            this[0] = node;
            this.id = R._oid++;
            this.node = node;
            node.raphael = this;
            this.paper = svg;
            this.attrs = this.attrs || {};
            this.transformations = []; // rotate, translate, scale
            this._ = {
                tx: 0,
                ty: 0,
                rt: {deg: 0, cx: 0, cy: 0},
                sx: 1,
                sy: 1
            };
            !svg.bottom && (svg.bottom = this);
            this.prev = svg.top;
            svg.top && (svg.top.next = this);
            svg.top = this;
            this.next = null;
        };
        var elproto = Element[proto];
        Element[proto].rotate = function (deg, cx, cy) {
            if (this.removed) {
                return this;
            }
            if (deg == null) {
                if (this._.rt.cx) {
                    return [this._.rt.deg, this._.rt.cx, this._.rt.cy][join](S);
                }
                return this._.rt.deg;
            }
            var bbox = this.getBBox();
            deg = Str(deg)[split](separator);
            if (deg[length] - 1) {
                cx = toFloat(deg[1]);
                cy = toFloat(deg[2]);
            }
            deg = toFloat(deg[0]);
            if (cx != null && cx !== false) {
                this._.rt.deg = deg;
            } else {
                this._.rt.deg += deg;
            }
            (cy == null) && (cx = null);
            this._.rt.cx = cx;
            this._.rt.cy = cy;
            cx = cx == null ? bbox.x + bbox.width / 2 : cx;
            cy = cy == null ? bbox.y + bbox.height / 2 : cy;
            if (this._.rt.deg) {
                this.transformations[0] = R.format("rotate({0} {1} {2})", this._.rt.deg, cx, cy);
                this.clip && $(this.clip, {transform: R.format("rotate({0} {1} {2})", -this._.rt.deg, cx, cy)});
            } else {
                this.transformations[0] = E;
                this.clip && $(this.clip, {transform: E});
            }
            $(this.node, {transform: this.transformations[join](S)});
            return this;
        };
        Element[proto].hide = function () {
            !this.removed && (this.node.style.display = "none");
            return this;
        };
        Element[proto].show = function () {
            !this.removed && (this.node.style.display = "");
            return this;
        };
        Element[proto].remove = function () {
            if (this.removed) {
                return;
            }
            tear(this, this.paper);
            this.node.parentNode.removeChild(this.node);
            for (var i in this) {
                delete this[i];
            }
            this.removed = true;
        };
        Element[proto].getBBox = function () {
            if (this.removed) {
                return this;
            }
            if (this.type == "path") {
                return pathDimensions(this.attrs.path);
            }
            if (this.node.style.display == "none") {
                this.show();
                var hide = true;
            }
            var bbox = {};
            try {
                bbox = this.node.getBBox();
            } catch(e) {
                // Firefox 3.0.x plays badly here
            } finally {
                bbox = bbox || {};
            }
            if (this.type == "text") {
                bbox = {x: bbox.x, y: Infinity, width: 0, height: 0};
                for (var i = 0, ii = this.node.getNumberOfChars(); i < ii; i++) {
                    var bb = this.node.getExtentOfChar(i);
                    (bb.y < bbox.y) && (bbox.y = bb.y);
                    (bb.y + bb.height - bbox.y > bbox.height) && (bbox.height = bb.y + bb.height - bbox.y);
                    (bb.x + bb.width - bbox.x > bbox.width) && (bbox.width = bb.x + bb.width - bbox.x);
                }
            }
            hide && this.hide();
            return bbox;
        };
        Element[proto].attr = function (name, value) {
            if (this.removed) {
                return this;
            }
            if (name == null) {
                var res = {};
                for (var i in this.attrs) if (this.attrs[has](i)) {
                    res[i] = this.attrs[i];
                }
                this._.rt.deg && (res.rotation = this.rotate());
                (this._.sx != 1 || this._.sy != 1) && (res.scale = this.scale());
                res.gradient && res.fill == "none" && (res.fill = res.gradient) && delete res.gradient;
                return res;
            }
            if (value == null && R.is(name, string)) {
                if (name == "translation") {
                    return translate.call(this);
                }
                if (name == "rotation") {
                    return this.rotate();
                }
                if (name == "scale") {
                    return this.scale();
                }
                if (name == fillString && this.attrs.fill == "none" && this.attrs.gradient) {
                    return this.attrs.gradient;
                }
                return this.attrs[name];
            }
            if (value == null && R.is(name, array)) {
                var values = {};
                for (var j = 0, jj = name.length; j < jj; j++) {
                    values[name[j]] = this.attr(name[j]);
                }
                return values;
            }
            if (value != null) {
                var params = {};
                params[name] = value;
            } else if (name != null && R.is(name, "object")) {
                params = name;
            }
            for (var key in this.paper.customAttributes) if (this.paper.customAttributes[has](key) && params[has](key) && R.is(this.paper.customAttributes[key], "function")) {
                var par = this.paper.customAttributes[key].apply(this, [][concat](params[key]));
                this.attrs[key] = params[key];
                for (var subkey in par) if (par[has](subkey)) {
                    params[subkey] = par[subkey];
                }
            }
            setFillAndStroke(this, params);
            return this;
        };
        Element[proto].toFront = function () {
            if (this.removed) {
                return this;
            }
            this.node.parentNode[appendChild](this.node);
            var svg = this.paper;
            svg.top != this && tofront(this, svg);
            return this;
        };
        Element[proto].toBack = function () {
            if (this.removed) {
                return this;
            }
            if (this.node.parentNode.firstChild != this.node) {
                this.node.parentNode.insertBefore(this.node, this.node.parentNode.firstChild);
                toback(this, this.paper);
                var svg = this.paper;
            }
            return this;
        };
        Element[proto].insertAfter = function (element) {
            if (this.removed) {
                return this;
            }
            var node = element.node || element[element.length - 1].node;
            if (node.nextSibling) {
                node.parentNode.insertBefore(this.node, node.nextSibling);
            } else {
                node.parentNode[appendChild](this.node);
            }
            insertafter(this, element, this.paper);
            return this;
        };
        Element[proto].insertBefore = function (element) {
            if (this.removed) {
                return this;
            }
            var node = element.node || element[0].node;
            node.parentNode.insertBefore(this.node, node);
            insertbefore(this, element, this.paper);
            return this;
        };
        Element[proto].blur = function (size) {
            // Experimental. No Safari support. Use it on your own risk.
            var t = this;
            if (+size !== 0) {
                var fltr = $("filter"),
                    blur = $("feGaussianBlur");
                t.attrs.blur = size;
                fltr.id = createUUID();
                $(blur, {stdDeviation: +size || 1.5});
                fltr.appendChild(blur);
                t.paper.defs.appendChild(fltr);
                t._blur = fltr;
                $(t.node, {filter: "url(#" + fltr.id + ")"});
            } else {
                if (t._blur) {
                    t._blur.parentNode.removeChild(t._blur);
                    delete t._blur;
                    delete t.attrs.blur;
                }
                t.node.removeAttribute("filter");
            }
        };
        var theCircle = function (svg, x, y, r) {
            var el = $("circle");
            svg.canvas && svg.canvas[appendChild](el);
            var res = new Element(el, svg);
            res.attrs = {cx: x, cy: y, r: r, fill: "none", stroke: "#000"};
            res.type = "circle";
            $(el, res.attrs);
            return res;
        },
        theRect = function (svg, x, y, w, h, r) {
            var el = $("rect");
            svg.canvas && svg.canvas[appendChild](el);
            var res = new Element(el, svg);
            res.attrs = {x: x, y: y, width: w, height: h, r: r || 0, rx: r || 0, ry: r || 0, fill: "none", stroke: "#000"};
            res.type = "rect";
            $(el, res.attrs);
            return res;
        },
        theEllipse = function (svg, x, y, rx, ry) {
            var el = $("ellipse");
            svg.canvas && svg.canvas[appendChild](el);
            var res = new Element(el, svg);
            res.attrs = {cx: x, cy: y, rx: rx, ry: ry, fill: "none", stroke: "#000"};
            res.type = "ellipse";
            $(el, res.attrs);
            return res;
        },
        theImage = function (svg, src, x, y, w, h) {
            var el = $("image");
            $(el, {x: x, y: y, width: w, height: h, preserveAspectRatio: "none"});
            el.setAttributeNS(svg.xlink, "href", src);
            svg.canvas && svg.canvas[appendChild](el);
            var res = new Element(el, svg);
            res.attrs = {x: x, y: y, width: w, height: h, src: src};
            res.type = "image";
            return res;
        },
        theText = function (svg, x, y, text) {
            var el = $("text");
            $(el, {x: x, y: y, "text-anchor": "middle"});
            svg.canvas && svg.canvas[appendChild](el);
            var res = new Element(el, svg);
            res.attrs = {x: x, y: y, "text-anchor": "middle", text: text, font: availableAttrs.font, stroke: "none", fill: "#000"};
            res.type = "text";
            setFillAndStroke(res, res.attrs);
            return res;
        },
        setSize = function (width, height) {
            this.width = width || this.width;
            this.height = height || this.height;
            setAttr(this.canvas, "width", this.width);
            setAttr(this.canvas, "height", this.height);
            return this;
        },
        create = function () {
            var con = getContainer[apply](0, arguments),
                container = con && con.container,
                x = con.x,
                y = con.y,
                width = con.width,
                height = con.height;
            if (!container) {
                throw new Error("SVG container not found.");
            }
            var cnvs = $("svg");
            x = x || 0;
            y = y || 0;
            width = width || 512;
            height = height || 342;
            $(cnvs, {
                xmlns: "http://www.w3.org/2000/svg",
                version: 1.1,
                width: width,
                height: height
            });
            if (container == 1) {
                cnvs.style.cssText = "position:absolute;left:" + x + "px;top:" + y + "px";
                doc.body[appendChild](cnvs);
            } else {
                if (container.firstChild) {
                    container.insertBefore(cnvs, container.firstChild);
                } else {
                    container[appendChild](cnvs);
                }
            }
            container = new Paper;
            container.width = width;
            container.height = height;
            container.canvas = cnvs;
            plugins.call(container, container, R.fn);
            container.clear();
            return container;
        };
        paperproto.clear = function () {
            var c = this.canvas;
            while (c.firstChild) {
                c.removeChild(c.firstChild);
            }
            this.bottom = this.top = null;
            (this.desc = $("desc"))[appendChild](doc.createTextNode("Created with Rapha\xebl"));
            c[appendChild](this.desc);
            c[appendChild](this.defs = $("defs"));
        };
        paperproto.remove = function () {
            this.canvas.parentNode && this.canvas.parentNode.removeChild(this.canvas);
            for (var i in this) {
                this[i] = removed(i);
            }
        };
    }

    // VML
    if (R.vml) {
        var map = {M: "m", L: "l", C: "c", Z: "x", m: "t", l: "r", c: "v", z: "x"},
            bites = /([clmz]),?([^clmz]*)/gi,
            blurregexp = / progid:\S+Blur\([^\)]+\)/g,
            val = /-?[^,\s-]+/g,
            coordsize = 1e3 + S + 1e3,
            zoom = 10,
            pathlike = {path: 1, rect: 1},
            path2vml = function (path) {
                var total =  /[ahqstv]/ig,
                    command = pathToAbsolute;
                Str(path).match(total) && (command = path2curve);
                total = /[clmz]/g;
                if (command == pathToAbsolute && !Str(path).match(total)) {
                    var res = Str(path)[rp](bites, function (all, command, args) {
                        var vals = [],
                            isMove = lowerCase.call(command) == "m",
                            res = map[command];
                        args[rp](val, function (value) {
                            if (isMove && vals[length] == 2) {
                                res += vals + map[command == "m" ? "l" : "L"];
                                vals = [];
                            }
                            vals[push](round(value * zoom));
                        });
                        return res + vals;
                    });
                    return res;
                }
                var pa = command(path), p, r;
                res = [];
                for (var i = 0, ii = pa[length]; i < ii; i++) {
                    p = pa[i];
                    r = lowerCase.call(pa[i][0]);
                    r == "z" && (r = "x");
                    for (var j = 1, jj = p[length]; j < jj; j++) {
                        r += round(p[j] * zoom) + (j != jj - 1 ? "," : E);
                    }
                    res[push](r);
                }
                return res[join](S);
            };

        R[toString] = function () {
            return  "Your browser doesn\u2019t support SVG. Falling down to VML.\nYou are running Rapha\xebl " + this.version;
        };
        thePath = function (pathString, vml) {
            var g = createNode("group");
            g.style.cssText = "position:absolute;left:0;top:0;width:" + vml.width + "px;height:" + vml.height + "px";
            g.coordsize = vml.coordsize;
            g.coordorigin = vml.coordorigin;
            var el = createNode("shape"), ol = el.style;
            ol.width = vml.width + "px";
            ol.height = vml.height + "px";
            el.coordsize = coordsize;
            el.coordorigin = vml.coordorigin;
            g[appendChild](el);
            var p = new Element(el, g, vml),
                attr = {fill: "none", stroke: "#000"};
            pathString && (attr.path = pathString);
            p.type = "path";
            p.path = [];
            p.Path = E;
            setFillAndStroke(p, attr);
            vml.canvas[appendChild](g);
            return p;
        };
        setFillAndStroke = function (o, params) {
            o.attrs = o.attrs || {};
            var node = o.node,
                a = o.attrs,
                s = node.style,
                xy,
                newpath = (params.x != a.x || params.y != a.y || params.width != a.width || params.height != a.height || params.r != a.r) && o.type == "rect",
                res = o;

            for (var par in params) if (params[has](par)) {
                a[par] = params[par];
            }
            if (newpath) {
                a.path = rectPath(a.x, a.y, a.width, a.height, a.r);
                o.X = a.x;
                o.Y = a.y;
                o.W = a.width;
                o.H = a.height;
            }
            params.href && (node.href = params.href);
            params.title && (node.title = params.title);
            params.target && (node.target = params.target);
            params.cursor && (s.cursor = params.cursor);
            "blur" in params && o.blur(params.blur);
            if (params.path && o.type == "path" || newpath) {
                node.path = path2vml(a.path);
            }
            if (params.rotation != null) {
                o.rotate(params.rotation, true);
            }
            if (params.translation) {
                xy = Str(params.translation)[split](separator);
                translate.call(o, xy[0], xy[1]);
                if (o._.rt.cx != null) {
                    o._.rt.cx +=+ xy[0];
                    o._.rt.cy +=+ xy[1];
                    o.setBox(o.attrs, xy[0], xy[1]);
                }
            }
            if (params.scale) {
                xy = Str(params.scale)[split](separator);
                o.scale(+xy[0] || 1, +xy[1] || +xy[0] || 1, +xy[2] || null, +xy[3] || null);
            }
            if ("clip-rect" in params) {
                var rect = Str(params["clip-rect"])[split](separator);
                if (rect[length] == 4) {
                    rect[2] = +rect[2] + (+rect[0]);
                    rect[3] = +rect[3] + (+rect[1]);
                    var div = node.clipRect || doc.createElement("div"),
                        dstyle = div.style,
                        group = node.parentNode;
                    dstyle.clip = R.format("rect({1}px {2}px {3}px {0}px)", rect);
                    if (!node.clipRect) {
                        dstyle.position = "absolute";
                        dstyle.top = 0;
                        dstyle.left = 0;
                        dstyle.width = o.paper.width + "px";
                        dstyle.height = o.paper.height + "px";
                        group.parentNode.insertBefore(div, group);
                        div[appendChild](group);
                        node.clipRect = div;
                    }
                }
                if (!params["clip-rect"]) {
                    node.clipRect && (node.clipRect.style.clip = E);
                }
            }
            if (o.type == "image" && params.src) {
                node.src = params.src;
            }
            if (o.type == "image" && params.opacity) {
                node.filterOpacity = ms + ".Alpha(opacity=" + (params.opacity * 100) + ")";
                s.filter = (node.filterMatrix || E) + (node.filterOpacity || E);
            }
            params.font && (s.font = params.font);
            params["font-family"] && (s.fontFamily = '"' + params["font-family"][split](",")[0][rp](/^['"]+|['"]+$/g, E) + '"');
            params["font-size"] && (s.fontSize = params["font-size"]);
            params["font-weight"] && (s.fontWeight = params["font-weight"]);
            params["font-style"] && (s.fontStyle = params["font-style"]);
            if (params.opacity != null ||
                params["stroke-width"] != null ||
                params.fill != null ||
                params.stroke != null ||
                params["stroke-width"] != null ||
                params["stroke-opacity"] != null ||
                params["fill-opacity"] != null ||
                params["stroke-dasharray"] != null ||
                params["stroke-miterlimit"] != null ||
                params["stroke-linejoin"] != null ||
                params["stroke-linecap"] != null) {
                node = o.shape || node;
                var fill = (node.getElementsByTagName(fillString) && node.getElementsByTagName(fillString)[0]),
                    newfill = false;
                !fill && (newfill = fill = createNode(fillString));
                if ("fill-opacity" in params || "opacity" in params) {
                    var opacity = ((+a["fill-opacity"] + 1 || 2) - 1) * ((+a.opacity + 1 || 2) - 1) * ((+R.getRGB(params.fill).o + 1 || 2) - 1);
                    opacity = mmin(mmax(opacity, 0), 1);
                    fill.opacity = opacity;
                }
                params.fill && (fill.on = true);
                if (fill.on == null || params.fill == "none") {
                    fill.on = false;
                }
                if (fill.on && params.fill) {
                    var isURL = params.fill.match(ISURL);
                    if (isURL) {
                        fill.src = isURL[1];
                        fill.type = "tile";
                    } else {
                        fill.color = R.getRGB(params.fill).hex;
                        fill.src = E;
                        fill.type = "solid";
                        if (R.getRGB(params.fill).error && (res.type in {circle: 1, ellipse: 1} || Str(params.fill).charAt() != "r") && addGradientFill(res, params.fill)) {
                            a.fill = "none";
                            a.gradient = params.fill;
                        }
                    }
                }
                newfill && node[appendChild](fill);
                var stroke = (node.getElementsByTagName("stroke") && node.getElementsByTagName("stroke")[0]),
                newstroke = false;
                !stroke && (newstroke = stroke = createNode("stroke"));
                if ((params.stroke && params.stroke != "none") ||
                    params["stroke-width"] ||
                    params["stroke-opacity"] != null ||
                    params["stroke-dasharray"] ||
                    params["stroke-miterlimit"] ||
                    params["stroke-linejoin"] ||
                    params["stroke-linecap"]) {
                    stroke.on = true;
                }
                (params.stroke == "none" || stroke.on == null || params.stroke == 0 || params["stroke-width"] == 0) && (stroke.on = false);
                var strokeColor = R.getRGB(params.stroke);
                stroke.on && params.stroke && (stroke.color = strokeColor.hex);
                opacity = ((+a["stroke-opacity"] + 1 || 2) - 1) * ((+a.opacity + 1 || 2) - 1) * ((+strokeColor.o + 1 || 2) - 1);
                var width = (toFloat(params["stroke-width"]) || 1) * .75;
                opacity = mmin(mmax(opacity, 0), 1);
                params["stroke-width"] == null && (width = a["stroke-width"]);
                params["stroke-width"] && (stroke.weight = width);
                width && width < 1 && (opacity *= width) && (stroke.weight = 1);
                stroke.opacity = opacity;

                params["stroke-linejoin"] && (stroke.joinstyle = params["stroke-linejoin"] || "miter");
                stroke.miterlimit = params["stroke-miterlimit"] || 8;
                params["stroke-linecap"] && (stroke.endcap = params["stroke-linecap"] == "butt" ? "flat" : params["stroke-linecap"] == "square" ? "square" : "round");
                if (params["stroke-dasharray"]) {
                    var dasharray = {
                        "-": "shortdash",
                        ".": "shortdot",
                        "-.": "shortdashdot",
                        "-..": "shortdashdotdot",
                        ". ": "dot",
                        "- ": "dash",
                        "--": "longdash",
                        "- .": "dashdot",
                        "--.": "longdashdot",
                        "--..": "longdashdotdot"
                    };
                    stroke.dashstyle = dasharray[has](params["stroke-dasharray"]) ? dasharray[params["stroke-dasharray"]] : E;
                }
                newstroke && node[appendChild](stroke);
            }
            if (res.type == "text") {
                s = res.paper.span.style;
                a.font && (s.font = a.font);
                a["font-family"] && (s.fontFamily = a["font-family"]);
                a["font-size"] && (s.fontSize = a["font-size"]);
                a["font-weight"] && (s.fontWeight = a["font-weight"]);
                a["font-style"] && (s.fontStyle = a["font-style"]);
                res.node.string && (res.paper.span.innerHTML = Str(res.node.string)[rp](/</g, "&#60;")[rp](/&/g, "&#38;")[rp](/\n/g, "<br>"));
                res.W = a.w = res.paper.span.offsetWidth;
                res.H = a.h = res.paper.span.offsetHeight;
                res.X = a.x;
                res.Y = a.y + round(res.H / 2);

                // text-anchor emulationm
                switch (a["text-anchor"]) {
                    case "start":
                        res.node.style["v-text-align"] = "left";
                        res.bbx = round(res.W / 2);
                    break;
                    case "end":
                        res.node.style["v-text-align"] = "right";
                        res.bbx = -round(res.W / 2);
                    break;
                    default:
                        res.node.style["v-text-align"] = "center";
                    break;
                }
            }
        };
        addGradientFill = function (o, gradient) {
            o.attrs = o.attrs || {};
            var attrs = o.attrs,
                fill,
                type = "linear",
                fxfy = ".5 .5";
            o.attrs.gradient = gradient;
            gradient = Str(gradient)[rp](radial_gradient, function (all, fx, fy) {
                type = "radial";
                if (fx && fy) {
                    fx = toFloat(fx);
                    fy = toFloat(fy);
                    pow(fx - .5, 2) + pow(fy - .5, 2) > .25 && (fy = math.sqrt(.25 - pow(fx - .5, 2)) * ((fy > .5) * 2 - 1) + .5);
                    fxfy = fx + S + fy;
                }
                return E;
            });
            gradient = gradient[split](/\s*\-\s*/);
            if (type == "linear") {
                var angle = gradient.shift();
                angle = -toFloat(angle);
                if (isNaN(angle)) {
                    return null;
                }
            }
            var dots = parseDots(gradient);
            if (!dots) {
                return null;
            }
            o = o.shape || o.node;
            fill = o.getElementsByTagName(fillString)[0] || createNode(fillString);
            !fill.parentNode && o.appendChild(fill);
            if (dots[length]) {
                fill.on = true;
                fill.method = "none";
                fill.color = dots[0].color;
                fill.color2 = dots[dots[length] - 1].color;
                var clrs = [];
                for (var i = 0, ii = dots[length]; i < ii; i++) {
                    dots[i].offset && clrs[push](dots[i].offset + S + dots[i].color);
                }
                fill.colors && (fill.colors.value = clrs[length] ? clrs[join]() : "0% " + fill.color);
                if (type == "radial") {
                    fill.type = "gradientradial";
                    fill.focus = "100%";
                    fill.focussize = fxfy;
                    fill.focusposition = fxfy;
                } else {
                    fill.type = "gradient";
                    fill.angle = (270 - angle) % 360;
                }
            }
            return 1;
        };
        Element = function (node, group, vml) {
            var Rotation = 0,
                RotX = 0,
                RotY = 0,
                Scale = 1;
            this[0] = node;
            this.id = R._oid++;
            this.node = node;
            node.raphael = this;
            this.X = 0;
            this.Y = 0;
            this.attrs = {};
            this.Group = group;
            this.paper = vml;
            this._ = {
                tx: 0,
                ty: 0,
                rt: {deg:0},
                sx: 1,
                sy: 1
            };
            !vml.bottom && (vml.bottom = this);
            this.prev = vml.top;
            vml.top && (vml.top.next = this);
            vml.top = this;
            this.next = null;
        };
        elproto = Element[proto];
        elproto.rotate = function (deg, cx, cy) {
            if (this.removed) {
                return this;
            }
            if (deg == null) {
                if (this._.rt.cx) {
                    return [this._.rt.deg, this._.rt.cx, this._.rt.cy][join](S);
                }
                return this._.rt.deg;
            }
            deg = Str(deg)[split](separator);
            if (deg[length] - 1) {
                cx = toFloat(deg[1]);
                cy = toFloat(deg[2]);
            }
            deg = toFloat(deg[0]);
            if (cx != null) {
                this._.rt.deg = deg;
            } else {
                this._.rt.deg += deg;
            }
            cy == null && (cx = null);
            this._.rt.cx = cx;
            this._.rt.cy = cy;
            this.setBox(this.attrs, cx, cy);
            this.Group.style.rotation = this._.rt.deg;
            // gradient fix for rotation. TODO
            // var fill = (this.shape || this.node).getElementsByTagName(fillString);
            // fill = fill[0] || {};
            // var b = ((360 - this._.rt.deg) - 270) % 360;
            // !R.is(fill.angle, "undefined") && (fill.angle = b);
            return this;
        };
        elproto.setBox = function (params, cx, cy) {
            if (this.removed) {
                return this;
            }
            var gs = this.Group.style,
                os = (this.shape && this.shape.style) || this.node.style;
            params = params || {};
            for (var i in params) if (params[has](i)) {
                this.attrs[i] = params[i];
            }
            cx = cx || this._.rt.cx;
            cy = cy || this._.rt.cy;
            var attr = this.attrs,
                x,
                y,
                w,
                h;
            switch (this.type) {
                case "circle":
                    x = attr.cx - attr.r;
                    y = attr.cy - attr.r;
                    w = h = attr.r * 2;
                    break;
                case "ellipse":
                    x = attr.cx - attr.rx;
                    y = attr.cy - attr.ry;
                    w = attr.rx * 2;
                    h = attr.ry * 2;
                    break;
                case "image":
                    x = +attr.x;
                    y = +attr.y;
                    w = attr.width || 0;
                    h = attr.height || 0;
                    break;
                case "text":
                    this.textpath.v = ["m", round(attr.x), ", ", round(attr.y - 2), "l", round(attr.x) + 1, ", ", round(attr.y - 2)][join](E);
                    x = attr.x - round(this.W / 2);
                    y = attr.y - this.H / 2;
                    w = this.W;
                    h = this.H;
                    break;
                case "rect":
                case "path":
                    if (!this.attrs.path) {
                        x = 0;
                        y = 0;
                        w = this.paper.width;
                        h = this.paper.height;
                    } else {
                        var dim = pathDimensions(this.attrs.path);
                        x = dim.x;
                        y = dim.y;
                        w = dim.width;
                        h = dim.height;
                    }
                    break;
                default:
                    x = 0;
                    y = 0;
                    w = this.paper.width;
                    h = this.paper.height;
                    break;
            }
            cx = (cx == null) ? x + w / 2 : cx;
            cy = (cy == null) ? y + h / 2 : cy;
            var left = cx - this.paper.width / 2,
                top = cy - this.paper.height / 2, t;
            gs.left != (t = left + "px") && (gs.left = t);
            gs.top != (t = top + "px") && (gs.top = t);
            this.X = pathlike[has](this.type) ? -left : x;
            this.Y = pathlike[has](this.type) ? -top : y;
            this.W = w;
            this.H = h;
            if (pathlike[has](this.type)) {
                os.left != (t = -left * zoom + "px") && (os.left = t);
                os.top != (t = -top * zoom + "px") && (os.top = t);
            } else if (this.type == "text") {
                os.left != (t = -left + "px") && (os.left = t);
                os.top != (t = -top + "px") && (os.top = t);
            } else {
                gs.width != (t = this.paper.width + "px") && (gs.width = t);
                gs.height != (t = this.paper.height + "px") && (gs.height = t);
                os.left != (t = x - left + "px") && (os.left = t);
                os.top != (t = y - top + "px") && (os.top = t);
                os.width != (t = w + "px") && (os.width = t);
                os.height != (t = h + "px") && (os.height = t);
            }
        };
        elproto.hide = function () {
            !this.removed && (this.Group.style.display = "none");
            return this;
        };
        elproto.show = function () {
            !this.removed && (this.Group.style.display = "block");
            return this;
        };
        elproto.getBBox = function () {
            if (this.removed) {
                return this;
            }
            if (pathlike[has](this.type)) {
                return pathDimensions(this.attrs.path);
            }
            return {
                x: this.X + (this.bbx || 0),
                y: this.Y,
                width: this.W,
                height: this.H
            };
        };
        elproto.remove = function () {
            if (this.removed) {
                return;
            }
            tear(this, this.paper);
            this.node.parentNode.removeChild(this.node);
            this.Group.parentNode.removeChild(this.Group);
            this.shape && this.shape.parentNode.removeChild(this.shape);
            for (var i in this) {
                delete this[i];
            }
            this.removed = true;
        };
        elproto.attr = function (name, value) {
            if (this.removed) {
                return this;
            }
            if (name == null) {
                var res = {};
                for (var i in this.attrs) if (this.attrs[has](i)) {
                    res[i] = this.attrs[i];
                }
                this._.rt.deg && (res.rotation = this.rotate());
                (this._.sx != 1 || this._.sy != 1) && (res.scale = this.scale());
                res.gradient && res.fill == "none" && (res.fill = res.gradient) && delete res.gradient;
                return res;
            }
            if (value == null && R.is(name, "string")) {
                if (name == "translation") {
                    return translate.call(this);
                }
                if (name == "rotation") {
                    return this.rotate();
                }
                if (name == "scale") {
                    return this.scale();
                }
                if (name == fillString && this.attrs.fill == "none" && this.attrs.gradient) {
                    return this.attrs.gradient;
                }
                return this.attrs[name];
            }
            if (this.attrs && value == null && R.is(name, array)) {
                var ii, values = {};
                for (i = 0, ii = name[length]; i < ii; i++) {
                    values[name[i]] = this.attr(name[i]);
                }
                return values;
            }
            var params;
            if (value != null) {
                params = {};
                params[name] = value;
            }
            value == null && R.is(name, "object") && (params = name);
            if (params) {
                for (var key in this.paper.customAttributes) if (this.paper.customAttributes[has](key) && params[has](key) && R.is(this.paper.customAttributes[key], "function")) {
                    var par = this.paper.customAttributes[key].apply(this, [][concat](params[key]));
                    this.attrs[key] = params[key];
                    for (var subkey in par) if (par[has](subkey)) {
                        params[subkey] = par[subkey];
                    }
                }
                if (params.text && this.type == "text") {
                    this.node.string = params.text;
                }
                setFillAndStroke(this, params);
                if (params.gradient && (({circle: 1, ellipse: 1})[has](this.type) || Str(params.gradient).charAt() != "r")) {
                    addGradientFill(this, params.gradient);
                }
                (!pathlike[has](this.type) || this._.rt.deg) && this.setBox(this.attrs);
            }
            return this;
        };
        elproto.toFront = function () {
            !this.removed && this.Group.parentNode[appendChild](this.Group);
            this.paper.top != this && tofront(this, this.paper);
            return this;
        };
        elproto.toBack = function () {
            if (this.removed) {
                return this;
            }
            if (this.Group.parentNode.firstChild != this.Group) {
                this.Group.parentNode.insertBefore(this.Group, this.Group.parentNode.firstChild);
                toback(this, this.paper);
            }
            return this;
        };
        elproto.insertAfter = function (element) {
            if (this.removed) {
                return this;
            }
            if (element.constructor == Set) {
                element = element[element.length - 1];
            }
            if (element.Group.nextSibling) {
                element.Group.parentNode.insertBefore(this.Group, element.Group.nextSibling);
            } else {
                element.Group.parentNode[appendChild](this.Group);
            }
            insertafter(this, element, this.paper);
            return this;
        };
        elproto.insertBefore = function (element) {
            if (this.removed) {
                return this;
            }
            if (element.constructor == Set) {
                element = element[0];
            }
            element.Group.parentNode.insertBefore(this.Group, element.Group);
            insertbefore(this, element, this.paper);
            return this;
        };
        elproto.blur = function (size) {
            var s = this.node.runtimeStyle,
                f = s.filter;
            f = f.replace(blurregexp, E);
            if (+size !== 0) {
                this.attrs.blur = size;
                s.filter = f + S + ms + ".Blur(pixelradius=" + (+size || 1.5) + ")";
                s.margin = R.format("-{0}px 0 0 -{0}px", round(+size || 1.5));
            } else {
                s.filter = f;
                s.margin = 0;
                delete this.attrs.blur;
            }
        };

        theCircle = function (vml, x, y, r) {
            var g = createNode("group"),
                o = createNode("oval"),
                ol = o.style;
            g.style.cssText = "position:absolute;left:0;top:0;width:" + vml.width + "px;height:" + vml.height + "px";
            g.coordsize = coordsize;
            g.coordorigin = vml.coordorigin;
            g[appendChild](o);
            var res = new Element(o, g, vml);
            res.type = "circle";
            setFillAndStroke(res, {stroke: "#000", fill: "none"});
            res.attrs.cx = x;
            res.attrs.cy = y;
            res.attrs.r = r;
            res.setBox({x: x - r, y: y - r, width: r * 2, height: r * 2});
            vml.canvas[appendChild](g);
            return res;
        };
        function rectPath(x, y, w, h, r) {
            if (r) {
                return R.format("M{0},{1}l{2},0a{3},{3},0,0,1,{3},{3}l0,{5}a{3},{3},0,0,1,{4},{3}l{6},0a{3},{3},0,0,1,{4},{4}l0,{7}a{3},{3},0,0,1,{3},{4}z", x + r, y, w - r * 2, r, -r, h - r * 2, r * 2 - w, r * 2 - h);
            } else {
                return R.format("M{0},{1}l{2},0,0,{3},{4},0z", x, y, w, h, -w);
            }
        }
        theRect = function (vml, x, y, w, h, r) {
            var path = rectPath(x, y, w, h, r),
                res = vml.path(path),
                a = res.attrs;
            res.X = a.x = x;
            res.Y = a.y = y;
            res.W = a.width = w;
            res.H = a.height = h;
            a.r = r;
            a.path = path;
            res.type = "rect";
            return res;
        };
        theEllipse = function (vml, x, y, rx, ry) {
            var g = createNode("group"),
                o = createNode("oval"),
                ol = o.style;
            g.style.cssText = "position:absolute;left:0;top:0;width:" + vml.width + "px;height:" + vml.height + "px";
            g.coordsize = coordsize;
            g.coordorigin = vml.coordorigin;
            g[appendChild](o);
            var res = new Element(o, g, vml);
            res.type = "ellipse";
            setFillAndStroke(res, {stroke: "#000"});
            res.attrs.cx = x;
            res.attrs.cy = y;
            res.attrs.rx = rx;
            res.attrs.ry = ry;
            res.setBox({x: x - rx, y: y - ry, width: rx * 2, height: ry * 2});
            vml.canvas[appendChild](g);
            return res;
        };
        theImage = function (vml, src, x, y, w, h) {
            var g = createNode("group"),
                o = createNode("image");
            g.style.cssText = "position:absolute;left:0;top:0;width:" + vml.width + "px;height:" + vml.height + "px";
            g.coordsize = coordsize;
            g.coordorigin = vml.coordorigin;
            o.src = src;
            g[appendChild](o);
            var res = new Element(o, g, vml);
            res.type = "image";
            res.attrs.src = src;
            res.attrs.x = x;
            res.attrs.y = y;
            res.attrs.w = w;
            res.attrs.h = h;
            res.setBox({x: x, y: y, width: w, height: h});
            vml.canvas[appendChild](g);
            return res;
        };
        theText = function (vml, x, y, text) {
            var g = createNode("group"),
                el = createNode("shape"),
                ol = el.style,
                path = createNode("path"),
                ps = path.style,
                o = createNode("textpath");
            g.style.cssText = "position:absolute;left:0;top:0;width:" + vml.width + "px;height:" + vml.height + "px";
            g.coordsize = coordsize;
            g.coordorigin = vml.coordorigin;
            path.v = R.format("m{0},{1}l{2},{1}", round(x * 10), round(y * 10), round(x * 10) + 1);
            path.textpathok = true;
            ol.width = vml.width;
            ol.height = vml.height;
            o.string = Str(text);
            o.on = true;
            el[appendChild](o);
            el[appendChild](path);
            g[appendChild](el);
            var res = new Element(o, g, vml);
            res.shape = el;
            res.textpath = path;
            res.type = "text";
            res.attrs.text = text;
            res.attrs.x = x;
            res.attrs.y = y;
            res.attrs.w = 1;
            res.attrs.h = 1;
            setFillAndStroke(res, {font: availableAttrs.font, stroke: "none", fill: "#000"});
            res.setBox();
            vml.canvas[appendChild](g);
            return res;
        };
        setSize = function (width, height) {
            var cs = this.canvas.style;
            width == +width && (width += "px");
            height == +height && (height += "px");
            cs.width = width;
            cs.height = height;
            cs.clip = "rect(0 " + width + " " + height + " 0)";
            return this;
        };
        var createNode;
        doc.createStyleSheet().addRule(".rvml", "behavior:url(#default#VML)");
        try {
            !doc.namespaces.rvml && doc.namespaces.add("rvml", "urn:schemas-microsoft-com:vml");
            createNode = function (tagName) {
                return doc.createElement('<rvml:' + tagName + ' class="rvml">');
            };
        } catch (e) {
            createNode = function (tagName) {
                return doc.createElement('<' + tagName + ' xmlns="urn:schemas-microsoft.com:vml" class="rvml">');
            };
        }
        create = function () {
            var con = getContainer[apply](0, arguments),
                container = con.container,
                height = con.height,
                s,
                width = con.width,
                x = con.x,
                y = con.y;
            if (!container) {
                throw new Error("VML container not found.");
            }
            var res = new Paper,
                c = res.canvas = doc.createElement("div"),
                cs = c.style;
            x = x || 0;
            y = y || 0;
            width = width || 512;
            height = height || 342;
            width == +width && (width += "px");
            height == +height && (height += "px");
            res.width = 1e3;
            res.height = 1e3;
            res.coordsize = zoom * 1e3 + S + zoom * 1e3;
            res.coordorigin = "0 0";
            res.span = doc.createElement("span");
            res.span.style.cssText = "position:absolute;left:-9999em;top:-9999em;padding:0;margin:0;line-height:1;display:inline;";
            c[appendChild](res.span);
            cs.cssText = R.format("top:0;left:0;width:{0};height:{1};display:inline-block;position:relative;clip:rect(0 {0} {1} 0);overflow:hidden", width, height);
            if (container == 1) {
                doc.body[appendChild](c);
                cs.left = x + "px";
                cs.top = y + "px";
                cs.position = "absolute";
            } else {
                if (container.firstChild) {
                    container.insertBefore(c, container.firstChild);
                } else {
                    container[appendChild](c);
                }
            }
            plugins.call(res, res, R.fn);
            return res;
        };
        paperproto.clear = function () {
            this.canvas.innerHTML = E;
            this.span = doc.createElement("span");
            this.span.style.cssText = "position:absolute;left:-9999em;top:-9999em;padding:0;margin:0;line-height:1;display:inline;";
            this.canvas[appendChild](this.span);
            this.bottom = this.top = null;
        };
        paperproto.remove = function () {
            this.canvas.parentNode.removeChild(this.canvas);
            for (var i in this) {
                this[i] = removed(i);
            }
            return true;
        };
    }

    // rest
    // WebKit rendering bug workaround method
    var version = navigator.userAgent.match(/Version\/(.*?)\s/);
    if ((navigator.vendor == "Apple Computer, Inc.") && (version && version[1] < 4 || navigator.platform.slice(0, 2) == "iP")) {
        paperproto.safari = function () {
            var rect = this.rect(-99, -99, this.width + 99, this.height + 99).attr({stroke: "none"});
            win.setTimeout(function () {rect.remove();});
        };
    } else {
        paperproto.safari = function () {};
    }

    // Events
    var preventDefault = function () {
        this.returnValue = false;
    },
    preventTouch = function () {
        return this.originalEvent.preventDefault();
    },
    stopPropagation = function () {
        this.cancelBubble = true;
    },
    stopTouch = function () {
        return this.originalEvent.stopPropagation();
    },
    addEvent = (function () {
        if (doc.addEventListener) {
            return function (obj, type, fn, element) {
                var realName = supportsTouch && touchMap[type] ? touchMap[type] : type;
                var f = function (e) {
                    if (supportsTouch && touchMap[has](type)) {
                        for (var i = 0, ii = e.targetTouches && e.targetTouches.length; i < ii; i++) {
                            if (e.targetTouches[i].target == obj) {
                                var olde = e;
                                e = e.targetTouches[i];
                                e.originalEvent = olde;
                                e.preventDefault = preventTouch;
                                e.stopPropagation = stopTouch;
                                break;
                            }
                        }
                    }
                    return fn.call(element, e);
                };
                obj.addEventListener(realName, f, false);
                return function () {
                    obj.removeEventListener(realName, f, false);
                    return true;
                };
            };
        } else if (doc.attachEvent) {
            return function (obj, type, fn, element) {
                var f = function (e) {
                    e = e || win.event;
                    e.preventDefault = e.preventDefault || preventDefault;
                    e.stopPropagation = e.stopPropagation || stopPropagation;
                    return fn.call(element, e);
                };
                obj.attachEvent("on" + type, f);
                var detacher = function () {
                    obj.detachEvent("on" + type, f);
                    return true;
                };
                return detacher;
            };
        }
    })(),
    drag = [],
    dragMove = function (e) {
        var x = e.clientX,
            y = e.clientY,
            scrollY = doc.documentElement.scrollTop || doc.body.scrollTop,
            scrollX = doc.documentElement.scrollLeft || doc.body.scrollLeft,
            dragi,
            j = drag.length;
        while (j--) {
            dragi = drag[j];
            if (supportsTouch) {
                var i = e.touches.length,
                    touch;
                while (i--) {
                    touch = e.touches[i];
                    if (touch.identifier == dragi.el._drag.id) {
                        x = touch.clientX;
                        y = touch.clientY;
                        (e.originalEvent ? e.originalEvent : e).preventDefault();
                        break;
                    }
                }
            } else {
                e.preventDefault();
            }
            x += scrollX;
            y += scrollY;
            dragi.move && dragi.move.call(dragi.move_scope || dragi.el, x - dragi.el._drag.x, y - dragi.el._drag.y, x, y, e);
        }
    },
    dragUp = function (e) {
        R.unmousemove(dragMove).unmouseup(dragUp);
        var i = drag.length,
            dragi;
        while (i--) {
            dragi = drag[i];
            dragi.el._drag = {};
            dragi.end && dragi.end.call(dragi.end_scope || dragi.start_scope || dragi.move_scope || dragi.el, e);
        }
        drag = [];
    };
    for (var i = events[length]; i--;) {
        (function (eventName) {
            R[eventName] = Element[proto][eventName] = function (fn, scope) {
                if (R.is(fn, "function")) {
                    this.events = this.events || [];
                    this.events.push({name: eventName, f: fn, unbind: addEvent(this.shape || this.node || doc, eventName, fn, scope || this)});
                }
                return this;
            };
            R["un" + eventName] = Element[proto]["un" + eventName] = function (fn) {
                var events = this.events,
                    l = events[length];
                while (l--) if (events[l].name == eventName && events[l].f == fn) {
                    events[l].unbind();
                    events.splice(l, 1);
                    !events.length && delete this.events;
                    return this;
                }
                return this;
            };
        })(events[i]);
    }
    elproto.hover = function (f_in, f_out, scope_in, scope_out) {
        return this.mouseover(f_in, scope_in).mouseout(f_out, scope_out || scope_in);
    };
    elproto.unhover = function (f_in, f_out) {
        return this.unmouseover(f_in).unmouseout(f_out);
    };
    elproto.drag = function (onmove, onstart, onend, move_scope, start_scope, end_scope) {
        this._drag = {};
        this.mousedown(function (e) {
            (e.originalEvent || e).preventDefault();
            var scrollY = doc.documentElement.scrollTop || doc.body.scrollTop,
                scrollX = doc.documentElement.scrollLeft || doc.body.scrollLeft;
            this._drag.x = e.clientX + scrollX;
            this._drag.y = e.clientY + scrollY;
            this._drag.id = e.identifier;
            onstart && onstart.call(start_scope || move_scope || this, e.clientX + scrollX, e.clientY + scrollY, e);
            !drag.length && R.mousemove(dragMove).mouseup(dragUp);
            drag.push({el: this, move: onmove, end: onend, move_scope: move_scope, start_scope: start_scope, end_scope: end_scope});
        });
        return this;
    };
    elproto.undrag = function (onmove, onstart, onend) {
        var i = drag.length;
        while (i--) {
            drag[i].el == this && (drag[i].move == onmove && drag[i].end == onend) && drag.splice(i++, 1);
        }
        !drag.length && R.unmousemove(dragMove).unmouseup(dragUp);
    };
    paperproto.circle = function (x, y, r) {
        return theCircle(this, x || 0, y || 0, r || 0);
    };
    paperproto.rect = function (x, y, w, h, r) {
        return theRect(this, x || 0, y || 0, w || 0, h || 0, r || 0);
    };
    paperproto.ellipse = function (x, y, rx, ry) {
        return theEllipse(this, x || 0, y || 0, rx || 0, ry || 0);
    };
    paperproto.path = function (pathString) {
        pathString && !R.is(pathString, string) && !R.is(pathString[0], array) && (pathString += E);
        return thePath(R.format[apply](R, arguments), this);
    };
    paperproto.image = function (src, x, y, w, h) {
        return theImage(this, src || "about:blank", x || 0, y || 0, w || 0, h || 0);
    };
    paperproto.text = function (x, y, text) {
        return theText(this, x || 0, y || 0, Str(text));
    };
    paperproto.set = function (itemsArray) {
        arguments[length] > 1 && (itemsArray = Array[proto].splice.call(arguments, 0, arguments[length]));
        return new Set(itemsArray);
    };
    paperproto.setSize = setSize;
    paperproto.top = paperproto.bottom = null;
    paperproto.raphael = R;
    function x_y() {
        return this.x + S + this.y;
    }
    elproto.resetScale = function () {
        if (this.removed) {
            return this;
        }
        this._.sx = 1;
        this._.sy = 1;
        this.attrs.scale = "1 1";
    };
    elproto.scale = function (x, y, cx, cy) {
        if (this.removed) {
            return this;
        }
        if (x == null && y == null) {
            return {
                x: this._.sx,
                y: this._.sy,
                toString: x_y
            };
        }
        y = y || x;
        !+y && (y = x);
        var dx,
            dy,
            dcx,
            dcy,
            a = this.attrs;
        if (x != 0) {
            var bb = this.getBBox(),
                rcx = bb.x + bb.width / 2,
                rcy = bb.y + bb.height / 2,
                kx = abs(x / this._.sx),
                ky = abs(y / this._.sy);
            cx = (+cx || cx == 0) ? cx : rcx;
            cy = (+cy || cy == 0) ? cy : rcy;
            var posx = this._.sx > 0,
                posy = this._.sy > 0,
                dirx = ~~(x / abs(x)),
                diry = ~~(y / abs(y)),
                dkx = kx * dirx,
                dky = ky * diry,
                s = this.node.style,
                ncx = cx + abs(rcx - cx) * dkx * (rcx > cx == posx ? 1 : -1),
                ncy = cy + abs(rcy - cy) * dky * (rcy > cy == posy ? 1 : -1),
                fr = (x * dirx > y * diry ? ky : kx);
            switch (this.type) {
                case "rect":
                case "image":
                    var neww = a.width * kx,
                        newh = a.height * ky;
                    this.attr({
                        height: newh,
                        r: a.r * fr,
                        width: neww,
                        x: ncx - neww / 2,
                        y: ncy - newh / 2
                    });
                    break;
                case "circle":
                case "ellipse":
                    this.attr({
                        rx: a.rx * kx,
                        ry: a.ry * ky,
                        r: a.r * fr,
                        cx: ncx,
                        cy: ncy
                    });
                    break;
                case "text":
                    this.attr({
                        x: ncx,
                        y: ncy
                    });
                    break;
                case "path":
                    var path = pathToRelative(a.path),
                        skip = true,
                        fx = posx ? dkx : kx,
                        fy = posy ? dky : ky;
                    for (var i = 0, ii = path[length]; i < ii; i++) {
                        var p = path[i],
                            P0 = upperCase.call(p[0]);
                        if (P0 == "M" && skip) {
                            continue;
                        } else {
                            skip = false;
                        }
                        if (P0 == "A") {
                            p[path[i][length] - 2] *= fx;
                            p[path[i][length] - 1] *= fy;
                            p[1] *= kx;
                            p[2] *= ky;
                            p[5] = +(dirx + diry ? !!+p[5] : !+p[5]);
                        } else if (P0 == "H") {
                            for (var j = 1, jj = p[length]; j < jj; j++) {
                                p[j] *= fx;
                            }
                        } else if (P0 == "V") {
                            for (j = 1, jj = p[length]; j < jj; j++) {
                                p[j] *= fy;
                            }
                         } else {
                            for (j = 1, jj = p[length]; j < jj; j++) {
                                p[j] *= (j % 2) ? fx : fy;
                            }
                        }
                    }
                    var dim2 = pathDimensions(path);
                    dx = ncx - dim2.x - dim2.width / 2;
                    dy = ncy - dim2.y - dim2.height / 2;
                    path[0][1] += dx;
                    path[0][2] += dy;
                    this.attr({path: path});
                break;
            }
            if (this.type in {text: 1, image:1} && (dirx != 1 || diry != 1)) {
                if (this.transformations) {
                    this.transformations[2] = "scale("[concat](dirx, ",", diry, ")");
                    setAttr(this.node, "transform", this.transformations[join](S));
                    dx = (dirx == -1) ? -a.x - (neww || 0) : a.x;
                    dy = (diry == -1) ? -a.y - (newh || 0) : a.y;
                    this.attr({x: dx, y: dy});
                    a.fx = dirx - 1;
                    a.fy = diry - 1;
                } else {
                    this.node.filterMatrix = ms + ".Matrix(M11="[concat](dirx,
                        ", M12=0, M21=0, M22=", diry,
                        ", Dx=0, Dy=0, sizingmethod='auto expand', filtertype='bilinear')");
                    s.filter = (this.node.filterMatrix || E) + (this.node.filterOpacity || E);
                }
            } else {
                if (this.transformations) {
                    this.transformations[2] = E;
                    setAttr(this.node, "transform", this.transformations[join](S));
                    a.fx = 0;
                    a.fy = 0;
                } else {
                    this.node.filterMatrix = E;
                    s.filter = (this.node.filterMatrix || E) + (this.node.filterOpacity || E);
                }
            }
            a.scale = [x, y, cx, cy][join](S);
            this._.sx = x;
            this._.sy = y;
        }
        return this;
    };
    elproto.clone = function () {
        if (this.removed) {
            return null;
        }
        var attr = this.attr();
        delete attr.scale;
        delete attr.translation;
        return this.paper[this.type]().attr(attr);
    };
    var curveslengths = {},
    getPointAtSegmentLength = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length) {
        // Is this a straight line?
        // Added for huge speed improvements
        if ( p1x === c1x && p1y === c1y && c2x === p2x && c2y == p2y ) {
            var dx = p2x - p1x, dy = p2y - p1y;
            var totalLength = Math.sqrt( dx * dx + dy * dy );

            if ( length == null ) {
                return totalLength;
            } else {
                var fract = length / totalLength;
                return {
                    start: { x: p1x, y: p1y },
                    m: { x: p1x, y: p1y },
                    n: { x: p2x, y: p2y },
                    end: { x: p2x, y: p2y },
                    x: p1x + fract * dx,
                    y: p1y + fract * dy,
                    alpha: (90 - math.atan(dx / dy) * 180 / PI)
                };
            }
        }

        var len = 0,
            precision = 100,
            name = [p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y].join(),
            cache = curveslengths[name],
            old, dot;
        !cache && (curveslengths[name] = cache = {data: []});
        cache.timer && clearTimeout(cache.timer);
        cache.timer = setTimeout(function () {delete curveslengths[name];}, 2000);
        if (length != null) {
            var total = getPointAtSegmentLength(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y);
            precision = ~~total * 10;
        }
        for (var i = 0; i < precision + 1; i++) {
            if (cache.data[length] > i) {
                dot = cache.data[i * precision];
            } else {
                dot = R.findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, i / precision);
                cache.data[i] = dot;
            }
            i && (len += pow(pow(old.x - dot.x, 2) + pow(old.y - dot.y, 2), .5));
            if (length != null && len >= length) {
                return dot;
            }
            old = dot;
        }
        if (length == null) {
            return len;
        }
    },
    getLengthFactory = function (istotal, subpath) {
        return function (path, length, onlystart) {
            path = path2curve(path);
            var x, y, p, l, sp = "", subpaths = {}, point,
                len = 0;
            for (var i = 0, ii = path.length; i < ii; i++) {
                p = path[i];
                if (p[0] == "M") {
                    x = +p[1];
                    y = +p[2];
                } else {
                    l = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);
                    if (len + l > length) {
                        if (subpath && !subpaths.start) {
                            point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);
                            sp += ["C", point.start.x, point.start.y, point.m.x, point.m.y, point.x, point.y];
                            if (onlystart) {return sp;}
                            subpaths.start = sp;
                            sp = ["M", point.x, point.y + "C", point.n.x, point.n.y, point.end.x, point.end.y, p[5], p[6]][join]();
                            len += l;
                            x = +p[5];
                            y = +p[6];
                            continue;
                        }
                        if (!istotal && !subpath) {
                            point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);
                            return {x: point.x, y: point.y, alpha: point.alpha};
                        }
                    }
                    len += l;
                    x = +p[5];
                    y = +p[6];
                }
                sp += p;
            }
            subpaths.end = sp;
            point = istotal ? len : subpath ? subpaths : R.findDotsAtSegment(x, y, p[1], p[2], p[3], p[4], p[5], p[6], 1);
            point.alpha && (point = {x: point.x, y: point.y, alpha: point.alpha});
            return point;
        };
    };
    var getTotalLength = getLengthFactory(1),
        getPointAtLength = getLengthFactory(),
        getSubpathsAtLength = getLengthFactory(0, 1);
    elproto.getTotalLength = function () {
        if (this.type != "path") {return;}
        if (this.node.getTotalLength) {
            return this.node.getTotalLength();
        }
        return getTotalLength(this.attrs.path);
    };
    elproto.getPointAtLength = function (length) {
        if (this.type != "path") {return;}
        return getPointAtLength(this.attrs.path, length);
    };
    elproto.getSubpath = function (from, to) {
        if (this.type != "path") {return;}
        if (abs(this.getTotalLength() - to) < "1e-6") {
            return getSubpathsAtLength(this.attrs.path, from).end;
        }
        var a = getSubpathsAtLength(this.attrs.path, to, 1);
        return from ? getSubpathsAtLength(a, from).end : a;
    };

    // animation easing formulas
    R.easing_formulas = {
        linear: function (n) {
            return n;
        },
        "<": function (n) {
            return pow(n, 3);
        },
        ">": function (n) {
            return pow(n - 1, 3) + 1;
        },
        "<>": function (n) {
            n = n * 2;
            if (n < 1) {
                return pow(n, 3) / 2;
            }
            n -= 2;
            return (pow(n, 3) + 2) / 2;
        },
        backIn: function (n) {
            var s = 1.70158;
            return n * n * ((s + 1) * n - s);
        },
        backOut: function (n) {
            n = n - 1;
            var s = 1.70158;
            return n * n * ((s + 1) * n + s) + 1;
        },
        elastic: function (n) {
            if (n == 0 || n == 1) {
                return n;
            }
            var p = .3,
                s = p / 4;
            return pow(2, -10 * n) * math.sin((n - s) * (2 * PI) / p) + 1;
        },
        bounce: function (n) {
            var s = 7.5625,
                p = 2.75,
                l;
            if (n < (1 / p)) {
                l = s * n * n;
            } else {
                if (n < (2 / p)) {
                    n -= (1.5 / p);
                    l = s * n * n + .75;
                } else {
                    if (n < (2.5 / p)) {
                        n -= (2.25 / p);
                        l = s * n * n + .9375;
                    } else {
                        n -= (2.625 / p);
                        l = s * n * n + .984375;
                    }
                }
            }
            return l;
        }
    };

    var animationElements = [],
        animation = function () {
            var Now = +new Date;
            for (var l = 0; l < animationElements[length]; l++) {
                var e = animationElements[l];
                if (e.stop || e.el.removed) {
                    continue;
                }
                var time = Now - e.start,
                    ms = e.ms,
                    easing = e.easing,
                    from = e.from,
                    diff = e.diff,
                    to = e.to,
                    t = e.t,
                    that = e.el,
                    set = {},
                    now;
                if (time < ms) {
                    var pos = easing(time / ms);
                    for (var attr in from) if (from[has](attr)) {
                        switch (availableAnimAttrs[attr]) {
                            case "along":
                                now = pos * ms * diff[attr];
                                to.back && (now = to.len - now);
                                var point = getPointAtLength(to[attr], now);
                                that.translate(diff.sx - diff.x || 0, diff.sy - diff.y || 0);
                                diff.x = point.x;
                                diff.y = point.y;
                                that.translate(point.x - diff.sx, point.y - diff.sy);
                                to.rot && that.rotate(diff.r + point.alpha, point.x, point.y);
                                break;
                            case nu:
                                now = +from[attr] + pos * ms * diff[attr];
                                break;
                            case "colour":
                                now = "rgb(" + [
                                    upto255(round(from[attr].r + pos * ms * diff[attr].r)),
                                    upto255(round(from[attr].g + pos * ms * diff[attr].g)),
                                    upto255(round(from[attr].b + pos * ms * diff[attr].b))
                                ][join](",") + ")";
                                break;
                            case "path":
                                now = [];
                                for (var i = 0, ii = from[attr][length]; i < ii; i++) {
                                    now[i] = [from[attr][i][0]];
                                    for (var j = 1, jj = from[attr][i][length]; j < jj; j++) {
                                        now[i][j] = +from[attr][i][j] + pos * ms * diff[attr][i][j];
                                    }
                                    now[i] = now[i][join](S);
                                }
                                now = now[join](S);
                                break;
                            case "csv":
                                switch (attr) {
                                    case "translation":
                                        var x = pos * ms * diff[attr][0] - t.x,
                                            y = pos * ms * diff[attr][1] - t.y;
                                        t.x += x;
                                        t.y += y;
                                        now = x + S + y;
                                    break;
                                    case "rotation":
                                        now = +from[attr][0] + pos * ms * diff[attr][0];
                                        from[attr][1] && (now += "," + from[attr][1] + "," + from[attr][2]);
                                    break;
                                    case "scale":
                                        now = [+from[attr][0] + pos * ms * diff[attr][0], +from[attr][1] + pos * ms * diff[attr][1], (2 in to[attr] ? to[attr][2] : E), (3 in to[attr] ? to[attr][3] : E)][join](S);
                                    break;
                                    case "clip-rect":
                                        now = [];
                                        i = 4;
                                        while (i--) {
                                            now[i] = +from[attr][i] + pos * ms * diff[attr][i];
                                        }
                                    break;
                                }
                                break;
                            default:
                              var from2 = [].concat(from[attr]);
                                now = [];
                                i = that.paper.customAttributes[attr].length;
                                while (i--) {
                                    now[i] = +from2[i] + pos * ms * diff[attr][i];
                                }
                                break;
                        }
                        set[attr] = now;
                    }
                    that.attr(set);
                    that._run && that._run.call(that);
                } else {
                    if (to.along) {
                        point = getPointAtLength(to.along, to.len * !to.back);
                        that.translate(diff.sx - (diff.x || 0) + point.x - diff.sx, diff.sy - (diff.y || 0) + point.y - diff.sy);
                        to.rot && that.rotate(diff.r + point.alpha, point.x, point.y);
                    }
                    (t.x || t.y) && that.translate(-t.x, -t.y);
                    to.scale && (to.scale += E);
                    that.attr(to);
                    animationElements.splice(l--, 1);
                }
            }
            R.svg && that && that.paper && that.paper.safari();
            animationElements[length] && setTimeout(animation);
        },
        keyframesRun = function (attr, element, time, prev, prevcallback) {
            var dif = time - prev;
            element.timeouts.push(setTimeout(function () {
                R.is(prevcallback, "function") && prevcallback.call(element);
                element.animate(attr, dif, attr.easing);
            }, prev));
        },
        upto255 = function (color) {
            return mmax(mmin(color, 255), 0);
        },
        translate = function (x, y) {
            if (x == null) {
                return {x: this._.tx, y: this._.ty, toString: x_y};
            }
            this._.tx += +x;
            this._.ty += +y;
            switch (this.type) {
                case "circle":
                case "ellipse":
                    this.attr({cx: +x + this.attrs.cx, cy: +y + this.attrs.cy});
                    break;
                case "rect":
                case "image":
                case "text":
                    this.attr({x: +x + this.attrs.x, y: +y + this.attrs.y});
                    break;
                case "path":
                    var path = pathToRelative(this.attrs.path);
                    path[0][1] += +x;
                    path[0][2] += +y;
                    this.attr({path: path});
                break;
            }
            return this;
        };
    elproto.animateWith = function (element, params, ms, easing, callback) {
        for (var i = 0, ii = animationElements.length; i < ii; i++) {
            if (animationElements[i].el.id == element.id) {
                params.start = animationElements[i].start;
            }
        }
        return this.animate(params, ms, easing, callback);
    };
    elproto.animateAlong = along();
    elproto.animateAlongBack = along(1);
    function along(isBack) {
        return function (path, ms, rotate, callback) {
            var params = {back: isBack};
            R.is(rotate, "function") ? (callback = rotate) : (params.rot = rotate);
            path && path.constructor == Element && (path = path.attrs.path);
            path && (params.along = path);
            return this.animate(params, ms, callback);
        };
    }
    function CubicBezierAtTime(t, p1x, p1y, p2x, p2y, duration) {
        var cx = 3 * p1x,
            bx = 3 * (p2x - p1x) - cx,
            ax = 1 - cx - bx,
            cy = 3 * p1y,
            by = 3 * (p2y - p1y) - cy,
            ay = 1 - cy - by;
        function sampleCurveX(t) {
            return ((ax * t + bx) * t + cx) * t;
        }
        function solve(x, epsilon) {
            var t = solveCurveX(x, epsilon);
            return ((ay * t + by) * t + cy) * t;
        }
        function solveCurveX(x, epsilon) {
            var t0, t1, t2, x2, d2, i;
            for(t2 = x, i = 0; i < 8; i++) {
                x2 = sampleCurveX(t2) - x;
                if (abs(x2) < epsilon) {
                    return t2;
                }
                d2 = (3 * ax * t2 + 2 * bx) * t2 + cx;
                if (abs(d2) < 1e-6) {
                    break;
                }
                t2 = t2 - x2 / d2;
            }
            t0 = 0;
            t1 = 1;
            t2 = x;
            if (t2 < t0) {
                return t0;
            }
            if (t2 > t1) {
                return t1;
            }
            while (t0 < t1) {
                x2 = sampleCurveX(t2);
                if (abs(x2 - x) < epsilon) {
                    return t2;
                }
                if (x > x2) {
                    t0 = t2;
                } else {
                    t1 = t2;
                }
                t2 = (t1 - t0) / 2 + t0;
            }
            return t2;
        }
        return solve(t, 1 / (200 * duration));
    }
    elproto.onAnimation = function (f) {
        this._run = f || 0;
        return this;
    };
    elproto.animate = function (params, ms, easing, callback) {
        var element = this;
        element.timeouts = element.timeouts || [];
        if (R.is(easing, "function") || !easing) {
            callback = easing || null;
        }
        if (element.removed) {
            callback && callback.call(element);
            return element;
        }
        var from = {},
            to = {},
            animateable = false,
            diff = {};
        for (var attr in params) if (params[has](attr)) {
            if (availableAnimAttrs[has](attr) || element.paper.customAttributes[has](attr)) {
                animateable = true;
                from[attr] = element.attr(attr);
                (from[attr] == null) && (from[attr] = availableAttrs[attr]);
                to[attr] = params[attr];
                switch (availableAnimAttrs[attr]) {
                    case "along":
                        var len = getTotalLength(params[attr]);
                        var point = getPointAtLength(params[attr], len * !!params.back);
                        var bb = element.getBBox();
                        diff[attr] = len / ms;
                        diff.tx = bb.x;
                        diff.ty = bb.y;
                        diff.sx = point.x;
                        diff.sy = point.y;
                        to.rot = params.rot;
                        to.back = params.back;
                        to.len = len;
                        params.rot && (diff.r = toFloat(element.rotate()) || 0);
                        break;
                    case nu:
                        diff[attr] = (to[attr] - from[attr]) / ms;
                        break;
                    case "colour":
                        from[attr] = R.getRGB(from[attr]);
                        var toColour = R.getRGB(to[attr]);
                        diff[attr] = {
                            r: (toColour.r - from[attr].r) / ms,
                            g: (toColour.g - from[attr].g) / ms,
                            b: (toColour.b - from[attr].b) / ms
                        };
                        break;
                    case "path":
                        var pathes = path2curve(from[attr], to[attr]);
                        from[attr] = pathes[0];
                        var toPath = pathes[1];
                        diff[attr] = [];
                        for (var i = 0, ii = from[attr][length]; i < ii; i++) {
                            diff[attr][i] = [0];
                            for (var j = 1, jj = from[attr][i][length]; j < jj; j++) {
                                diff[attr][i][j] = (toPath[i][j] - from[attr][i][j]) / ms;
                            }
                        }
                        break;
                    case "csv":
                        var values = Str(params[attr])[split](separator),
                            from2 = Str(from[attr])[split](separator);
                        switch (attr) {
                            case "translation":
                                from[attr] = [0, 0];
                                diff[attr] = [values[0] / ms, values[1] / ms];
                            break;
                            case "rotation":
                                from[attr] = (from2[1] == values[1] && from2[2] == values[2]) ? from2 : [0, values[1], values[2]];
                                diff[attr] = [(values[0] - from[attr][0]) / ms, 0, 0];
                            break;
                            case "scale":
                                params[attr] = values;
                                from[attr] = Str(from[attr])[split](separator);
                                diff[attr] = [(values[0] - from[attr][0]) / ms, (values[1] - from[attr][1]) / ms, 0, 0];
                            break;
                            case "clip-rect":
                                from[attr] = Str(from[attr])[split](separator);
                                diff[attr] = [];
                                i = 4;
                                while (i--) {
                                    diff[attr][i] = (values[i] - from[attr][i]) / ms;
                                }
                            break;
                        }
                        to[attr] = values;
                        break;
                    default:
                        values = [].concat(params[attr]);
                        from2 = [].concat(from[attr]);
                        diff[attr] = [];
                        i = element.paper.customAttributes[attr][length];
                        while (i--) {
                            diff[attr][i] = ((values[i] || 0) - (from2[i] || 0)) / ms;
                        }
                        break;
                }
            }
        }
        if (!animateable) {
            var attrs = [],
                lastcall;
            for (var key in params) if (params[has](key) && animKeyFrames.test(key)) {
                attr = {value: params[key]};
                key == "from" && (key = 0);
                key == "to" && (key = 100);
                attr.key = toInt(key, 10);
                attrs.push(attr);
            }
            attrs.sort(sortByKey);
            if (attrs[0].key) {
                attrs.unshift({key: 0, value: element.attrs});
            }
            for (i = 0, ii = attrs[length]; i < ii; i++) {
                keyframesRun(attrs[i].value, element, ms / 100 * attrs[i].key, ms / 100 * (attrs[i - 1] && attrs[i - 1].key || 0), attrs[i - 1] && attrs[i - 1].value.callback);
            }
            lastcall = attrs[attrs[length] - 1].value.callback;
            if (lastcall) {
                element.timeouts.push(setTimeout(function () {lastcall.call(element);}, ms));
            }
        } else {
            var easyeasy = R.easing_formulas[easing];
            if (!easyeasy) {
                easyeasy = Str(easing).match(bezierrg);
                if (easyeasy && easyeasy[length] == 5) {
                    var curve = easyeasy;
                    easyeasy = function (t) {
                        return CubicBezierAtTime(t, +curve[1], +curve[2], +curve[3], +curve[4], ms);
                    };
                } else {
                    easyeasy = function (t) {
                        return t;
                    };
                }
            }
            animationElements.push({
                start: params.start || +new Date,
                ms: ms,
                easing: easyeasy,
                from: from,
                diff: diff,
                to: to,
                el: element,
                t: {x: 0, y: 0}
            });
            R.is(callback, "function") && (element._ac = setTimeout(function () {
                callback.call(element);
            }, ms));
            animationElements[length] == 1 && setTimeout(animation);
        }
        return this;
    };
    elproto.stop = function () {
        for (var i = 0; i < animationElements.length; i++) {
            animationElements[i].el.id == this.id && animationElements.splice(i--, 1);
        }
        for (i = 0, ii = this.timeouts && this.timeouts.length; i < ii; i++) {
            clearTimeout(this.timeouts[i]);
        }
        this.timeouts = [];
        clearTimeout(this._ac);
        delete this._ac;
        return this;
    };
    elproto.translate = function (x, y) {
        return this.attr({translation: x + " " + y});
    };
    elproto[toString] = function () {
        return "Rapha\xebl\u2019s object";
    };
    R.ae = animationElements;

    // Set
    var Set = function (items) {
        this.items = [];
        this[length] = 0;
        this.type = "set";
        if (items) {
            for (var i = 0, ii = items[length]; i < ii; i++) {
                if (items[i] && (items[i].constructor == Element || items[i].constructor == Set)) {
                    this[this.items[length]] = this.items[this.items[length]] = items[i];
                    this[length]++;
                }
            }
        }
    };
    Set[proto][push] = function () {
        var item,
            len;
        for (var i = 0, ii = arguments[length]; i < ii; i++) {
            item = arguments[i];
            if (item && (item.constructor == Element || item.constructor == Set)) {
                len = this.items[length];
                this[len] = this.items[len] = item;
                this[length]++;
            }
        }
        return this;
    };
    Set[proto].pop = function () {
        delete this[this[length]--];
        return this.items.pop();
    };
    for (var method in elproto) if (elproto[has](method)) {
        Set[proto][method] = (function (methodname) {
            return function () {
                for (var i = 0, ii = this.items[length]; i < ii; i++) {
                    this.items[i][methodname][apply](this.items[i], arguments);
                }
                return this;
            };
        })(method);
    }
    Set[proto].attr = function (name, value) {
        if (name && R.is(name, array) && R.is(name[0], "object")) {
            for (var j = 0, jj = name[length]; j < jj; j++) {
                this.items[j].attr(name[j]);
            }
        } else {
            for (var i = 0, ii = this.items[length]; i < ii; i++) {
                this.items[i].attr(name, value);
            }
        }
        return this;
    };
    Set[proto].animate = function (params, ms, easing, callback) {
        (R.is(easing, "function") || !easing) && (callback = easing || null);
        var len = this.items[length],
            i = len,
            item,
            set = this,
            collector;
        callback && (collector = function () {
            !--len && callback.call(set);
        });
        easing = R.is(easing, string) ? easing : collector;
        item = this.items[--i].animate(params, ms, easing, collector);
        while (i--) {
            this.items[i] && !this.items[i].removed && this.items[i].animateWith(item, params, ms, easing, collector);
        }
        return this;
    };
    Set[proto].insertAfter = function (el) {
        var i = this.items[length];
        while (i--) {
            this.items[i].insertAfter(el);
        }
        return this;
    };
    Set[proto].getBBox = function () {
        var x = [],
            y = [],
            w = [],
            h = [];
        for (var i = this.items[length]; i--;) {
            var box = this.items[i].getBBox();
            x[push](box.x);
            y[push](box.y);
            w[push](box.x + box.width);
            h[push](box.y + box.height);
        }
        x = mmin[apply](0, x);
        y = mmin[apply](0, y);
        return {
            x: x,
            y: y,
            width: mmax[apply](0, w) - x,
            height: mmax[apply](0, h) - y
        };
    };
    Set[proto].clone = function (s) {
        s = new Set;
        for (var i = 0, ii = this.items[length]; i < ii; i++) {
            s[push](this.items[i].clone());
        }
        return s;
    };

    R.registerFont = function (font) {
        if (!font.face) {
            return font;
        }
        this.fonts = this.fonts || {};
        var fontcopy = {
                w: font.w,
                face: {},
                glyphs: {}
            },
            family = font.face["font-family"];
        for (var prop in font.face) if (font.face[has](prop)) {
            fontcopy.face[prop] = font.face[prop];
        }
        if (this.fonts[family]) {
            this.fonts[family][push](fontcopy);
        } else {
            this.fonts[family] = [fontcopy];
        }
        if (!font.svg) {
            fontcopy.face["units-per-em"] = toInt(font.face["units-per-em"], 10);
            for (var glyph in font.glyphs) if (font.glyphs[has](glyph)) {
                var path = font.glyphs[glyph];
                fontcopy.glyphs[glyph] = {
                    w: path.w,
                    k: {},
                    d: path.d && "M" + path.d[rp](/[mlcxtrv]/g, function (command) {
                            return {l: "L", c: "C", x: "z", t: "m", r: "l", v: "c"}[command] || "M";
                        }) + "z"
                };
                if (path.k) {
                    for (var k in path.k) if (path[has](k)) {
                        fontcopy.glyphs[glyph].k[k] = path.k[k];
                    }
                }
            }
        }
        return font;
    };
    paperproto.getFont = function (family, weight, style, stretch) {
        stretch = stretch || "normal";
        style = style || "normal";
        weight = +weight || {normal: 400, bold: 700, lighter: 300, bolder: 800}[weight] || 400;
        if (!R.fonts) {
            return;
        }
        var font = R.fonts[family];
        if (!font) {
            var name = new RegExp("(^|\\s)" + family[rp](/[^\w\d\s+!~.:_-]/g, E) + "(\\s|$)", "i");
            for (var fontName in R.fonts) if (R.fonts[has](fontName)) {
                if (name.test(fontName)) {
                    font = R.fonts[fontName];
                    break;
                }
            }
        }
        var thefont;
        if (font) {
            for (var i = 0, ii = font[length]; i < ii; i++) {
                thefont = font[i];
                if (thefont.face["font-weight"] == weight && (thefont.face["font-style"] == style || !thefont.face["font-style"]) && thefont.face["font-stretch"] == stretch) {
                    break;
                }
            }
        }
        return thefont;
    };
    paperproto.print = function (x, y, string, font, size, origin, letter_spacing) {
        origin = origin || "middle"; // baseline|middle
        letter_spacing = mmax(mmin(letter_spacing || 0, 1), -1);
        var out = this.set(),
            letters = Str(string)[split](E),
            shift = 0,
            path = E,
            scale;
        R.is(font, string) && (font = this.getFont(font));
        if (font) {
            scale = (size || 16) / font.face["units-per-em"];
            var bb = font.face.bbox.split(separator),
                top = +bb[0],
                height = +bb[1] + (origin == "baseline" ? bb[3] - bb[1] + (+font.face.descent) : (bb[3] - bb[1]) / 2);
            for (var i = 0, ii = letters[length]; i < ii; i++) {
                var prev = i && font.glyphs[letters[i - 1]] || {},
                    curr = font.glyphs[letters[i]];
                shift += i ? (prev.w || font.w) + (prev.k && prev.k[letters[i]] || 0) + (font.w * letter_spacing) : 0;
                curr && curr.d && out[push](this.path(curr.d).attr({fill: "#000", stroke: "none", translation: [shift, 0]}));
            }
            out.scale(scale, scale, top, height).translate(x - top, y - height);
        }
        return out;
    };

    R.format = function (token, params) {
        var args = R.is(params, array) ? [0][concat](params) : arguments;
        token && R.is(token, string) && args[length] - 1 && (token = token[rp](formatrg, function (str, i) {
            return args[++i] == null ? E : args[i];
        }));
        return token || E;
    };
    R.ninja = function () {
        oldRaphael.was ? (win.Raphael = oldRaphael.is) : delete Raphael;
        return R;
    };
    R.el = elproto;
    R.st = Set[proto];

    oldRaphael.was ? (win.Raphael = R) : (Raphael = R);
})();

define("third_party/raphael.js", function(){});

define('utils/math.js',['require','../third_party/raphael.js','./knumber.js'],function(require) {

// Minify Raphael ourselves because IE8 has a problem with the 1.5.2 minified release
// http://groups.google.com/group/raphaeljs/browse_thread/thread/c34c75ad8d431544
require("../third_party/raphael.js");
var knumber = require("./knumber.js");

$.extend(KhanUtil, {

    // Simplify formulas before display
    cleanMath: function(expr) {
        return typeof expr === "string" ?
            expr.replace(/\+\s*-/g, "- ")
                .replace(/-\s*-/g, "+ ")
                .replace(/\^1/g, "") :
            expr;
    },

    // A simple random number picker
    // Returns a random int in [0, num)
    rand: function(num) {
        return Math.floor(num * KhanUtil.random());
    },

    /* Returns an array of the digits of a nonnegative integer in reverse
     * order: digits(376) = [6, 7, 3] */
    digits: function(n) {
        if (n === 0) {
            return [0];
        }

        var list = [];

        while (n > 0) {
            list.push(n % 10);
            n = Math.floor(n / 10);
        }

        return list;
    },

    // Similar to above digits, but in original order (not reversed)
    integerToDigits: function(n) {
        return KhanUtil.digits(n).reverse();
    },

    // Convert a decimal number into an array of digits (reversed)
    decimalDigits: function(n) {
        var str = "" + Math.abs(n);
        str = str.replace(".", "");

        var list = [];
        for (var i = str.length; i > 0; i--) {
            list.push(str.charAt(i-1));
        }

        return list;
    },

    // Find number of digits after the decimal place
    decimalPlaces: function(n) {
        var str = "" + Math.abs(n);
        str = str.split(".");

        if (str.length === 1) {
            return 0;
        } else {
            return str[1].length;
        }
    },

    digitsToInteger: function(digits) {
        var place = Math.floor(Math.pow(10, digits.length - 1));
        var number = 0;

        $.each(digits, function(index, digit) {
            number += digit * place;
            place /= 10;
        });

        return number;
    },

    padDigitsToNum: function(digits, num) {
        digits = digits.slice(0);
        while (digits.length < num) {
            digits.push(0);
        }
        return digits;
    },

    placesLeftOfDecimal: [$._("one"), $._("ten"), $._("hundred"),
        $._("thousand")],
    placesRightOfDecimal: [$._("one"), $._("tenth"), $._("hundredth"),
        $._("thousandth"),$._("ten thousandth")],

    powerToPlace: function(power) {
        if (power < 0) {
            return KhanUtil.placesRightOfDecimal[-1 * power];
        } else {
            return KhanUtil.placesLeftOfDecimal[power];
        }
    },


    //Adds 0.001 because of floating points uncertainty so it errs on the side of going further away from 0
    roundTowardsZero: function(x) {
        if (x < 0) {
            return Math.ceil(x - 0.001);
        }
        return Math.floor(x + 0.001);
    },

    factorial: function(x) {
        if (x <= 1) {
            return x;
        } else {
            return x * KhanUtil.factorial(x - 1);
        }
    },

    getGCD: function(a, b) {
        if (arguments.length > 2) {
            var rest = [].slice.call(arguments, 1);
            return KhanUtil.getGCD(a, KhanUtil.getGCD.apply(KhanUtil, rest));
        } else {
            var mod;

            a = Math.abs(a);
            b = Math.abs(b);

            while (b) {
                mod = a % b;
                a = b;
                b = mod;
            }

            return a;
        }
    },

    getLCM: function(a, b) {
        if (arguments.length > 2) {
            var rest = [].slice.call(arguments, 1);
            return KhanUtil.getLCM(a, KhanUtil.getLCM.apply(KhanUtil, rest));
        } else {
            return Math.abs(a * b) / KhanUtil.getGCD(a, b);
        }
    },

    primes: [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43,
        47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97],

    denominators: [2, 3, 4, 5, 6, 8, 10, 12, 100],
    smallDenominators: [2, 3, 4, 5, 6, 8, 10, 12],

    getPrime: function() {
        return KhanUtil.primes[KhanUtil.rand(KhanUtil.primes.length)];
    },

    isPrime: function(n) {
        if (n <= 1) {
            return false;
        } else if (n < 101) {
            return !!$.grep(KhanUtil.primes, function(p, i) {
                return Math.abs(p - n) <= 0.5;
            }).length;
        } else {
            if (n <= 1 || n > 2 && n % 2 === 0) {
                return false;
            } else {
                for (var i = 3, sqrt = Math.sqrt(n); i <= sqrt; i += 2) {
                    if (n % i === 0) {
                        return false;
                    }
                }
            }

            return true;
        }

    },

    isOdd: function(n) {
        return n % 2 === 1;
    },

    isEven: function(n) {
        return n % 2 === 0;
    },

    getOddComposite: function(min, max) {
        if (min === undefined) {
            min = 0;
        }

        if (max === undefined) {
            max = 100;
        }

        var oddComposites = [9, 15, 21, 25, 27, 33, 35, 39, 45, 49, 51, 55];
        oddComposites = oddComposites.concat([57, 63, 65, 69, 75, 77, 81, 85, 87, 91, 93, 95, 99]);

        var result = -1;
        while (result < min || result > max) {
            result = oddComposites[KhanUtil.rand(oddComposites.length)];
        }
        return result;
    },

    getEvenComposite: function(min, max) {
        if (min === undefined) {
            min = 0;
        }

        if (max === undefined) {
            max = 100;
        }

        var evenComposites = [4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26];
        evenComposites = evenComposites.concat([28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48]);
        evenComposites = evenComposites.concat([50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72]);
        evenComposites = evenComposites.concat([74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98]);

        var result = -1;
        while (result < min || result > max) {
            result = evenComposites[KhanUtil.rand(evenComposites.length)];
        }
        return result;
    },

    getComposite: function() {
        if (KhanUtil.randRange(0, 1)) {
            return KhanUtil.getEvenComposite();
        } else {
            return KhanUtil.getOddComposite();
        }
    },

    getPrimeFactorization: function(number) {
        if (number === 1) {
            return [];
        } else if (KhanUtil.isPrime(number)) {
            return [number];
        }

        var maxf = Math.sqrt(number);
        for (var f = 2; f <= maxf; f++) {
            if (number % f === 0) {
                return $.merge(KhanUtil.getPrimeFactorization(f), KhanUtil.getPrimeFactorization(number / f));
            }
        }
    },

    getFactors: function(number) {
        var factors = [],
            ins = function(n) {
                if (_(factors).indexOf(n) === -1) {
                    factors.push(n);
                }
            };

        var maxf2 = number;
        for (var f = 1; f * f <= maxf2; f++) {
            if (number % f === 0) {
                ins(f);
                ins(number / f);
            }
        }
        return KhanUtil.sortNumbers(factors);
    },

    // Get a random factor of a composite number which is not 1 or that number
    getNontrivialFactor: function(number) {
        var factors = KhanUtil.getFactors(number);
        return factors[KhanUtil.randRange(1, factors.length - 2)];
    },

    getMultiples: function(number, upperLimit) {
        var multiples = [];
        for (var i = 1; i * number <= upperLimit; i++) {
            multiples.push(i * number);
        }
        return multiples;
    },

    // splitRadical(24) gives [2, 6] to mean 2 sqrt(6)
    splitRadical: function(n) {
        if (n === 0) {
            return [0, 1];
        }

        var coefficient = 1;
        var radical = n;

        for (var i = 2; i * i <= n; i++) {
            while (radical % (i * i) === 0) {
                radical /= i * i;
                coefficient *= i;
            }
        }

        return [coefficient, radical];
    },

    // splitCube(24) gives [2, 3] to mean 2 cube_root(3)
    splitCube: function(n) {
        if (n === 0) {
            return [0, 1];
        }

        var coefficient = 1;
        var radical = n;

        for (var i = 2; i * i * i <= n; i++) {
            while (radical % (i * i * i) === 0) {
                radical /= i * i * i;
                coefficient *= i;
            }
        }

        return [coefficient, radical];
    },

    // randRange(min, max) - Get a random integer between min and max, inclusive
    // randRange(min, max, count) - Get count random integers
    // randRange(min, max, rows, cols) - Get a rows x cols matrix of random integers
    // randRange(min, max, x, y, z) - You get the point...
    randRange: function(min, max) {
        var dimensions = [].slice.call(arguments, 2);

        if (dimensions.length === 0) {
            return Math.floor(KhanUtil.rand(max - min + 1)) + min;
        } else {
            var args = [min, max].concat(dimensions.slice(1));
            return $.map(new Array(dimensions[0]), function() {
                return [KhanUtil.randRange.apply(null, args)];
            });
        }
    },

    // Get an array of unique random numbers between min and max
    randRangeUnique: function(min, max, count) {
        if (count == null) {
            return KhanUtil.randRange(min, max);
        } else {
            var toReturn = [];
            for (var i = min; i <= max; i++) {
                toReturn.push(i);
            }

            return KhanUtil.shuffle(toReturn, count);
        }
    },

    // Get an array of unique random numbers between min and max,
    // that ensures that none of the integers in the array are 0.
    randRangeUniqueNonZero: function(min, max, count) {
        if (count == null) {
            return KhanUtil.randRangeNonZero(min, max);
        } else {
            var toReturn = [];
            for (var i = min; i <= max; i++) {
                if (i === 0) {
                    continue;
                }
                toReturn.push(i);
            }

            return KhanUtil.shuffle(toReturn, count);
        }
    },

    // Get a random integer between min and max with a perc chance of hitting
    // target (which is assumed to be in the range, but it doesn't have to be).
    randRangeWeighted: function(min, max, target, perc) {
        if (KhanUtil.random() < perc || (target === min && target === max)) {
            return target;
        } else {
            return KhanUtil.randRangeExclude(min, max, [target]);
        }
    },

    // Get a random integer between min and max that is never any of the values
    // in the excludes array.
    randRangeExclude: function(min, max, excludes) {
        var result;

        do {
            result = KhanUtil.randRange(min, max);
        } while (_(excludes).indexOf(result) !== -1);

        return result;
    },

    // Get a random integer between min and max with a perc chance of hitting
    // target (which is assumed to be in the range, but it doesn't have to be).
    // It never returns any of the values in the excludes array.
    randRangeWeightedExclude: function(min, max, target, perc, excludes) {
        var result;

        do {
            result = KhanUtil.randRangeWeighted(min, max, target, perc);
        } while (_(excludes).indexOf(result) !== -1);

        return result;
    },

    // From limits_1
    randRangeNonZero: function(min, max) {
        return KhanUtil.randRangeExclude(min, max, [0]);
    },

    // Returns a random member of the given array
    // If a count is passed, it gives an array of random members of the given array
    randFromArray: function(arr, count) {
        if (count == null) {
            return arr[KhanUtil.rand(arr.length)];
        } else {
            return $.map(new Array(count), function() {
                return KhanUtil.randFromArray(arr);
            });
        }
    },

    // Returns a random member of the given array that is never any of the values
    // in the excludes array.
    randFromArrayExclude: function(arr, excludes) {
        var cleanArr = [];
        for (var i = 0; i < arr.length; i++) {
            if (_(excludes).indexOf(arr[i]) === -1) {
                cleanArr.push(arr[i]);
            }
        }
        return KhanUtil.randFromArray(cleanArr);
    },

    // Round a number to the nearest increment
    // E.g., if increment = 30 and num = 40, return 30. if increment = 30 and num = 45, return 60.
    roundToNearest: function(increment, num) {
        return Math.round(num / increment) * increment;
    },

    // Round a number to a certain number of decimal places
    roundTo: function(precision, num) {
        var factor = Math.pow(10, precision).toFixed(5);
        return Math.round((num * factor).toFixed(5)) / factor;
    },

    /**
     * Return a string of num rounded to a fixed precision decimal places,
     * with an approx symbol if num had to be rounded, and trailing 0s
     */
    toFixedApprox: function(num, precision) {
        // TODO(jack): Make this locale-dependent like
        // KhanUtil.localeToFixed
        var fixedStr = num.toFixed(precision);
        if (knumber.equal(+fixedStr, num)) {
            return fixedStr;
        } else {
            return "\\approx " + fixedStr;
        }
    },

    /**
     * Return a string of num rounded to precision decimal places, with an
     * approx symbol if num had to be rounded, but no trailing 0s if it was
     * not rounded.
     */
    roundToApprox: function(num, precision) {
        var fixed = KhanUtil.roundTo(precision, num);
        if (knumber.equal(fixed, num)) {
            return String(fixed);
        } else {
            return KhanUtil.toFixedApprox(num, precision);
        }
    },

    floorTo: function(precision, num) {
        var factor = Math.pow(10, precision).toFixed(5);
        return Math.floor((num * factor).toFixed(5)) / factor;
    },

    ceilTo: function(precision, num) {
        var factor = Math.pow(10, precision).toFixed(5);
        return Math.ceil((num * factor).toFixed(5)) / factor;
    },

    // toFraction(4/8) => [1, 2]
    // toFraction(0.666) => [333, 500]
    // toFraction(0.666, 0.001) => [2, 3]
    //
    // tolerance can't be bigger than 1, sorry
    toFraction: function(decimal, tolerance) {
        if (tolerance == null) {
            tolerance = Math.pow(2, -46);
        }

        if (decimal < 0 || decimal > 1) {
            var fract = decimal % 1;
            fract += (fract < 0 ? 1 : 0);

            var nd = KhanUtil.toFraction(fract, tolerance);
            nd[0] += Math.round(decimal - fract) * nd[1];
            return nd;
        } else if (Math.abs(Math.round(Number(decimal)) - decimal) <= tolerance) {
            return [Math.round(decimal), 1];
        } else {
            var loN = 0, loD = 1, hiN = 1, hiD = 1, midN = 1, midD = 2;

            while (1) {
                if (Math.abs(Number(midN / midD) - decimal) <= tolerance) {
                    return [midN, midD];
                } else if (midN / midD < decimal) {
                    loN = midN;
                    loD = midD;
                } else {
                    hiN = midN;
                    hiD = midD;
                }

                midN = loN + hiN;
                midD = loD + hiD;
            }
        }
    },

    // Returns the format (string) of a given numeric string
    // Note: purposively more inclusive than answer-types' predicate.forms
    // That is, it is not necessarily true that interpreted input are numeric
    getNumericFormat: function(text) {
        text = $.trim(text);
        text = text.replace(/\u2212/, "-").replace(/([+-])\s+/g, "$1");
        if (text.match(/^[+-]?\d+$/)) {
            return "integer";
        } else if (text.match(/^[+-]?\d+\s+\d+\s*\/\s*\d+$/)) {
            return "mixed";
        }
        var fraction = text.match(/^[+-]?(\d+)\s*\/\s*(\d+)$/);
        if (fraction) {
            return parseFloat(fraction[1]) > parseFloat(fraction[2]) ?
                    "improper" : "proper";
        } else if (text.replace(/[,. ]/g, "").match(/^\d+$/)) {
            return "decimal";
        } else if (text.match(/(pi?|\u03c0|t(?:au)?|\u03c4|pau)/)) {
            return "pi";
        } else {
            return null;
        }
    },


    // Returns a string of the number in a specified format
    toNumericString: function(number, format) {
        if (number == null) {
            return "";
        } else if (number === 0) {
            return "0"; // otherwise it might end up as 0% or 0pi
        }

        if (format === "percent") {
            return number * 100 + "%";
        }

        if (format === "pi") {
            var fraction = knumber.toFraction(number / Math.PI);
            var numerator = Math.abs(fraction[0]), denominator = fraction[1];
            if (knumber.isInteger(numerator)) {
                var sign = number < 0 ? "-" : "";
                var pi = "\u03C0";
                return sign + (numerator === 1 ? "" : numerator) + pi +
                    (denominator === 1 ? "" : "/" + denominator);
            }
        }

        if (_(["proper", "improper", "mixed", "fraction"]).contains(format)) {
            var fraction = knumber.toFraction(number);
            var numerator = Math.abs(fraction[0]), denominator = fraction[1];
            var sign = number < 0 ? "-" : "";
            if (denominator === 1) {
                return sign + numerator; // for integers, irrational, d > 1000
            } else if (format === "mixed") {
                var modulus = numerator % denominator;
                var integer = (numerator - modulus) / denominator;
                return sign + (integer ? integer + " " : "") +
                        modulus + "/" + denominator;
            } // otherwise proper, improper, or fraction
            return sign + numerator + "/" + denominator;
        }

        // otherwise (decimal, float, long long)
        return String(number);
    },

    // Shuffle an array using a Fischer-Yates shuffle
    // If count is passed, returns an random sublist of that size
    shuffle: function(array, count) {
        array = [].slice.call(array, 0);
        var beginning = typeof count === "undefined" || count > array.length ? 0 : array.length - count;

        for (var top = array.length; top > beginning; top--) {
            var newEnd = Math.floor(KhanUtil.random() * top),
                tmp = array[newEnd];

            array[newEnd] = array[top - 1];
            array[top - 1] = tmp;
        }

        return array.slice(beginning);
    },

    sortNumbers: function(array) {
        return array.slice(0).sort(function(a, b) {
            return a - b;
        });
    },

    // From limits_1
    truncate_to_max: function(num, digits) {
        return parseFloat(num.toFixed(digits));
    },

    // Checks if a number or string representation thereof is an integer
    isInt: function(num) {
        return parseFloat(num) === parseInt(num, 10) && !isNaN(num);
    },


    /**
     * Add LaTeX color markup to a given value.
     */
    colorMarkup: function(val, color) {
        return "\\color{" + color + "}{" + val + "}";
    },

    /**
     * Like _.contains except using _.isEqual to verify if item is present.
     * (Works for lists of non-primitive values.)
     */
    contains: function(list, item) {
        return _.any(list, function(elem) {
            if (_.isEqual(item, elem)) {
                return true;
            }
            return false;
        });
    },

    BLUE: "#6495ED",
    ORANGE: "#FFA500",
    PINK: "#FF00AF",
    GREEN: "#28AE7B",
    PURPLE: "#9D38BD",
    RED: "#DF0030",
    GRAY: "gray",
    BLACK: "black",
    LIGHT_BLUE: "#9AB8ED",
    LIGHT_ORANGE: "#EDD19B",
    LIGHT_PINK: "#ED9BD3",
    LIGHT_GREEN: "#9BEDCE",
    LIGHT_PURPLE: "#DA9BED",
    LIGHT_RED: "#ED9AAC",
    LIGHT_GRAY: "#ED9B9B",
    LIGHT_BLACK: "#ED9B9B",
    // Don't actually use _BACKGROUND! Make things transparent instead. The
    // background color used in exercises is subject to change at the whim
    // of fickle designers.
    _BACKGROUND: "#FDFDFD"  // TODO(eater): Get rid of this altogether.
});

// For consistent coloring throughout Perseus
$.extend(KhanUtil, {
    INTERACTING: KhanUtil.PINK,
    INTERACTIVE: KhanUtil.ORANGE,
    DYNAMIC: KhanUtil.BLUE
});

});

define('utils/expressions.js',['require'],function(require) {

$.extend(KhanUtil, {

    expr: function(expr, compute) {
        if (typeof expr === "object") {
            var op = expr[0],
                args = expr.slice(1),
                table = compute ? KhanUtil.computeOperators : KhanUtil.formatOperators;

            return table[op].apply(this, args);
        } else {
            return compute ? expr : expr.toString();
        }
    },

    exprType: function(expr) {

        if (typeof expr === "object") {
            if (expr[0] === "color") {
                return KhanUtil.exprType(expr[2]);
            }

            return expr[0];

        } else {

            return typeof(expr);

        }
    },

    // Do I start with a minus sign?
    exprIsNegated: function(expr) {
        switch (KhanUtil.exprType(expr)) {
            case "color":
            return KhanUtil.exprIsNegated(expr[2]);

            case "/":
            return KhanUtil.exprIsNegated(expr[1]);

            case "+":
            case "-":
            return true;

            case "number":
            return expr < 0;

            case "string":
            return expr.charAt(0) === "-";

            default:
            // case "*":
            return false;
        }
    },

    // Mostly, is it okay to add a coefficient to me without adding parens?
    exprIsShort: function(expr) {
        switch (KhanUtil.exprType(expr)) {
            case "color":
            return KhanUtil.exprIsShort(expr[2]);

            case "+":
            case "-":
            case "*":
            case "/":
            case "frac":
            return false;

            case "^":
            return KhanUtil.exprType(expr[1]) !== "number" || expr[1] < 0;

            case "number":
            case "sqrt":
            return true;

            default:
            return expr.length <= 1;
        }
    },

    exprParenthesize: function(expr) {
        return KhanUtil.exprIsShort(expr) ?
            KhanUtil.expr(expr) :
            "(" + KhanUtil.expr(expr) + ")";
    },

    formatOperators: {
        "color": function(color, arg) {

            // Arguments should look like ["blue", [...]]
            return "\\color{" + color + "}{" + KhanUtil.expr(arg) + "}";
        },

        "+": function() {
            var args = [].slice.call(arguments, 0);
            var terms = $.grep(args, function(term, i) {
                return term != null;
            });

            // Remove terms that evaluate to 0
            terms = _.filter(terms, function(term) {
                return "" + KhanUtil.expr(term) !== "0";
            });

            terms = $.map(terms, function(term, i) {
                var parenthesize;
                switch (KhanUtil.exprType(term)) {
                    case "+":
                    parenthesize = true;
                    break;

                    case "-":
                    parenthesize = (term.length > 2);
                    break;

                    default:
                    // case "*":
                    // case "/":
                    // case "^":
                    parenthesize = false;
                }

                term = KhanUtil.expr(term);

                if (parenthesize) {
                    term = "(" + term + ")";
                }

                if (term.charAt(0) !== "-" || parenthesize) {
                    term = "+" + term;
                }

                return term;
            });

            var joined = terms.join("");

            if (joined.charAt(0) === "+") {
                return joined.slice(1);
            } else {
                return joined;
            }
        },

        "-": function() {
            if (arguments.length === 1) {
                return KhanUtil.expr(["*", -1, arguments[0]]);
            } else {
                var args = [].slice.call(arguments, 0);
                var terms = $.map(args, function(term, i) {
                    var negate = KhanUtil.exprIsNegated(term);
                    var parenthesize;
                    switch (KhanUtil.exprType(term)) {
                        case "+":
                        case "-":
                        parenthesize = true;
                        break;

                        default:
                        // case "*":
                        // case "/":
                        // case "^":
                        parenthesize = false;
                    }

                    term = KhanUtil.expr(term);

                    if ((negate && i > 0) || parenthesize) {
                        term = "(" + term + ")";
                    }

                    return term;
                });

                var joined = terms.join("-");

                return joined;
            }
        },

        "*": function() {
            var rest = Array.prototype.slice.call(arguments, 1);
            rest.unshift("*");

            // If we're multiplying by 1, ignore it, unless we have ["*", 1] and
            // should return 1
            if (arguments[0] === 0) {
                return 0;
            } else if (arguments[0] === 1 && rest.length > 1) {
                return KhanUtil.expr(rest);
            } else if (arguments[0] === -1 && rest.length > 1) {
                var form = KhanUtil.expr(rest);
                if (KhanUtil.exprIsNegated(rest[1])) {
                    return "-(" + form + ")";
                } else {
                    return "-" + form;
                }
            }

            if (arguments.length > 1) {
                var args = [].slice.call(arguments, 0);
                var parenthesizeRest = KhanUtil.exprType(arguments[0]) === "number" &&
                    KhanUtil.exprType(arguments[1]) === "number";
                var factors = $.map(args, function(factor, i) {
                    var parenthesize;
                    switch (KhanUtil.exprType(factor)) {
                        case "number":
                        if (i > 0) {
                            parenthesize = true;
                        }
                        break;

                        default:
                        parenthesize = !KhanUtil.exprIsShort(factor);
                        break;
                    }

                    parenthesizeRest = parenthesizeRest || parenthesize;
                    factor = KhanUtil.expr(factor);

                    if (parenthesizeRest) {
                        factor = "(" + factor + ")";
                    }

                    return factor;
                });

                return factors.join("");
            } else {
                return KhanUtil.expr(arguments[0]);
            }
        },

        "times": function(left, right) {
            var parenthesizeLeft = !KhanUtil.exprIsShort(left);
            var parenthesizeRight = !KhanUtil.exprIsShort(right);

            left = KhanUtil.expr(left);
            right = KhanUtil.expr(right);

            left = parenthesizeLeft ? "(" + left + ")" : left;
            right = parenthesizeRight ? "(" + right + ")" : right;

            return left + " \\times " + right;
        },

        "dot": function(left, right) {
            var parenthesizeLeft = !KhanUtil.exprIsShort(left);
            var parenthesizeRight = !KhanUtil.exprIsShort(right);

            left = KhanUtil.expr(left);
            right = KhanUtil.expr(right);

            left = parenthesizeLeft ? "(" + left + ")" : left;
            right = parenthesizeRight ? "(" + right + ")" : right;

            return left + " \\cdot " + right;
        },

        "/": function(num, den) {
            var parenthesizeNum = !KhanUtil.exprIsShort(num);
            var parenthesizeDen = !KhanUtil.exprIsShort(den);

            num = KhanUtil.expr(num);
            den = KhanUtil.expr(den);

            num = parenthesizeNum ? "(" + num + ")" : num;
            den = parenthesizeDen ? "(" + den + ")" : den;

            return num + "/" + den;
        },

        "frac": function(num, den) {
            return "\\dfrac{" + KhanUtil.expr(num) + "}{" +
                KhanUtil.expr(den) + "}";
        },

        "^": function(base, pow) {
            if (pow === 0) {
                return "";
            } else if (pow === 1) {
                return KhanUtil.expr(base);
            }

            var parenthesizeBase, trigFunction;
            switch (KhanUtil.exprType(base)) {
                case "+":
                case "-":
                case "*":
                case "/":
                case "^":
                case "ln":
                parenthesizeBase = true;
                break;

                case "number":
                parenthesizeBase = base < 0;
                break;

                case "sin":
                case "cos":
                case "tan":
                case "csc":
                case "sec":
                case "cot":
                parenthesizeBase = false;
                trigFunction = true;
                break;

                default:
                parenthesizeBase = false;
                trigFunction = false;
            }

            base = KhanUtil.expr(base);
            if (parenthesizeBase) {
                base = "(" + base + ")";
            }

            pow = KhanUtil.expr(pow);

            if (trigFunction) {
                return base.replace(/\\(\S+?)\{/, function(match, word) {
                    return "\\" + word + "^{" + pow + "} {";
                });
            } else {
                return base + "^{" + pow + "}";
            }
        },

        "sqrt": function(arg) {
            return "\\sqrt{" + KhanUtil.exprParenthesize(arg) + "}";
        },

        "sin": function(arg) {
            return "\\sin{" + KhanUtil.exprParenthesize(arg) + "}";
        },

        "cos": function(arg) {
            return "\\cos{" + KhanUtil.exprParenthesize(arg) + "}";
        },

        "tan": function(arg) {
            return "\\tan{" + KhanUtil.exprParenthesize(arg) + "}";
        },

        "sec": function(arg) {
            return "\\sec{" + KhanUtil.exprParenthesize(arg) + "}";
        },

        "csc": function(arg) {
            return "\\sec{" + KhanUtil.exprParenthesize(arg) + "}";
        },

        "cot": function(arg) {
            return "\\sec{" + KhanUtil.exprParenthesize(arg) + "}";
        },

        "ln": function(arg) {
            return "\\ln{" + KhanUtil.exprParenthesize(arg) + "}";
        },

        "+-": function() {
            if (arguments.length === 1) {
                return "\\pm " + KhanUtil.exprParenthesize(arguments[0]);
            } else {
                var args = [].slice.call(arguments, 0);
                return $.map(args, function(term, i) {
                    return KhanUtil.expr(term);
                }).join(" \\pm ");
            }
        }
    },

    computeOperators: {
        "color": function(color, arg) {
            return KhanUtil.expr(arg, true);
        },

        "+": function() {
            var args = [].slice.call(arguments, 0);
            var sum = 0;

            $.each(args, function(i, term) {
                sum += KhanUtil.expr(term, true);
            });

            return sum;
        },

        "-": function() {
            if (arguments.length === 1) {
                return -KhanUtil.expr(arguments[0], true);
            } else {
                var args = [].slice.call(arguments, 0);
                var sum = 0;

                $.each(args, function(i, term) {
                    sum += (i === 0 ? 1 : -1) * KhanUtil.expr(term, true);
                });

                return sum;
            }
        },

        "*": function() {
            var args = [].slice.call(arguments, 0);
            var prod = 1;

            $.each(args, function(i, term) {
                prod *= KhanUtil.expr(term, true);
            });

            return prod;
        },

        "/": function() {
            var args = [].slice.call(arguments, 0);
            var prod = 1;

            $.each(args, function(i, term) {
                var e = KhanUtil.expr(term, true);
                prod *= (i === 0 ? e : 1 / e);
            });

            return prod;
        },

        "^": function(base, pow) {
            return Math.pow(KhanUtil.expr(base, true), KhanUtil.expr(pow, true));
        },

        "sqrt": function(arg) {
            return Math.sqrt(KhanUtil.expr(arg, true));
        },

        "+-": function() {
            return NaN;
        }
    },

    // Remove ["color", ...] tags from an expression
    exprStripColor: function(expr) {
        if (typeof expr !== "object") {
            return expr;
        } else if (expr[0] === "color") {
            return KhanUtil.exprStripColor(expr[2]);
        } else {
            return $.map(expr, function(el, i) {

                // Wrap in an array because $.map flattens the result by one level
                return [(i === 0) ? el : KhanUtil.exprStripColor(el)];
            });
        }
    },

    // simplify an expression by collapsing all the associative
    // operations.  e.g. ["+", ["+", 1, 2], 3] -> ["+", 1, 2, 3]
    exprSimplifyAssociative: function(expr) {
        if (typeof expr !== "object") {
            return expr;
        }

        var simplified = $.map(expr.slice(1), function(x) {
            //encapsulate in a list so $.map unpacks it correctly
            return [KhanUtil.exprSimplifyAssociative(x)];
        });

        var flattenOneLevel = function(e) {
            switch (expr[0]) {
                case "+":
                if (e[0] === "+") {
                    return e.slice(1);
                }
                break;

                case "*":
                if (e[0] === "*") {
                    return e.slice(1);
                }
                break;
            }
            //make sure that we encapsulate e in an array so $'s map
            //does't accidently unpacks e itself.
            return [e];
        };

        //here we actually want the $ behavior of
        //having any lists that flattenOneLevel returns merged into
        //the result
        var ret = $.map(simplified, flattenOneLevel);
        ret.unshift(expr[0]);

        return ret;
    }
});

KhanUtil.computeOperators["frac"] = KhanUtil.computeOperators["/"];

});

define('utils/math-format.js',['require','./math.js','./expressions.js'],function(require) {

require("./math.js");
require("./expressions.js");

$.extend(KhanUtil, {
    /* Wraps a number in paretheses if it's negative. */
    negParens: function(n) {
        return n < 0 ? "(" + n + ")" : n;
    },

    /* Wrapper for `fraction` which takes a decimal instead of a numerator and
     * denominator. */
    decimalFraction: function(num, defraction, reduce, small, parens) {
        var f = KhanUtil.toFraction(num);
        return KhanUtil.fraction(f[0], f[1], defraction, reduce, small, parens);
    },

    reduce: function(n, d) {
        var gcd = KhanUtil.getGCD(n, d);
        n = n / gcd;
        d = d / gcd;
        return [n, d];
    },

    toFractionTex: function(n, dfrac) {
        var f = KhanUtil.toFraction(n);
        if (f[1] === 1) {
            return f[0];
        } else {
            return (n < 0 ? "-" : "") + "\\" + (dfrac ? "d" : "") + "frac{" + Math.abs(f[0]) + "}{" + Math.abs(f[1]) + "}";
        }
    },

    /* Format the latex of the fraction `n`/`d`.
     * - Will use latex's `dfrac` unless `small` is specified as truthy.
     * - Will wrap the fraction in parentheses if necessary (ie, unless the
     * fraction reduces to a positive integer) if `parens` is specified as
     * truthy.
     * - Will reduce the fraction `n`/`d` if `reduce` is specified as truthy.
     * - Will defraction (spit out 0 if `n` is 0, spit out `n` if `d` is 1, or
     * spit out `undefined` if `d` is 0) if `defraction` is specified as
     * truthy. */
    fraction: function(n, d, defraction, reduce, small, parens) {
        var frac = function(n, d) {
            return (small ? "\\frac" : "\\dfrac") + "{" + n + "}{" + d + "}";
        };

        var neg = n * d < 0;
        var sign = neg ? "-" : "";
        n = Math.abs(n);
        d = Math.abs(d);

        if (reduce) {
            var gcd = KhanUtil.getGCD(n, d);
            n = n / gcd;
            d = d / gcd;
        }

        defraction = defraction && (n === 0 || d === 0 || d === 1);
        parens = parens && (!defraction || neg);
        var begin = parens ? "\\left(" : "";
        var end = parens ? "\\right)" : "";

        var main;
        if (defraction) {
            if (n === 0) {
                main = "0";
            } else if (d === 0) {
                main = "\\text{undefined}";
            } else if (d === 1) {
                main = sign + n;
            }
        } else {
            main = sign + frac(n, d);
        }

        return begin + main + end;
    },

    mixedFractionFromImproper: function(n, d, defraction, reduce, small, parens) {
        return KhanUtil.mixedFraction(Math.floor(n / d), n % d, d, defraction, reduce, small, parens);
    },

    /* Format the latex of the mixed fraction 'num n/d"
     * - For negative numbers, if it is a mixed fraction, make sure the whole
     * number portion is negative.  '-5, 2/3' should be 'mixedFraction(-5,2,3)'
     * do not put negative for both whole number and numerator portion.
     * - Will use latex's `dfrac` unless `small` is specified as truthy.
     * - Will wrap the fraction in parentheses if necessary (ie, unless the
     * fraction reduces to a positive integer) if `parens` is specified as
     * truthy.
     * - Will reduce the fraction `n`/`d` if `reduce` is specified as truthy.
     * - Will defraction (spit out 0 if `n` is 0, spit out `n` if `d` is 1, or
     * spit out `undefined` if `d` is 0) if `defraction` is specified as
     * truthy. */
    mixedFraction: function(number, n, d, defraction, reduce, small, parens) {
        var wholeNum = number ? number : 0;
        var numerator = n ? n : 0;
        var denominator = d ? d : 1;

        if (wholeNum < 0 && numerator < 0) {
            throw "NumberFormatException: Both integer portion and fraction cannot both be negative.";
        }
        if (denominator < 0) {
            throw "NumberFormatException: Denominator cannot be be negative.";
        }
        if (denominator === 0) {
            throw "NumberFormatException: Denominator cannot be be 0.";
        }

        if (reduce) {
            if (wholeNum < 0) {
                wholeNum -= Math.floor(numerator / denominator);
            } else {
                wholeNum += Math.floor(numerator / denominator);
            }

            numerator = numerator % denominator;
        }

        if (wholeNum !== 0 && numerator !== 0) {
            return wholeNum + " " + KhanUtil.fraction(n, d, defraction, reduce, small, parens);
        } else if (wholeNum !== 0 && numerator === 0) {
            return wholeNum;
        } else if (wholeNum === 0 && numerator !== 0) {
            return KhanUtil.fraction(n, d, defraction, reduce, small, parens);
        } else {
            return 0;
        }
    },

    /* Calls fraction with the reduce and defraction flag enabled. Additional
     * parameters correspond to the remaining fraction flags. */
    fractionReduce: function(n, d, small, parens) {
        return KhanUtil.fraction(n, d, true, true, small, parens);
    },

    /* Calls fraction with the small flag enabled. Additional parameters
     * correspond to the remaining fraction flags. */
    fractionSmall: function(n, d, defraction, reduce, parens) {
        return KhanUtil.fraction(n, d, defraction, reduce, true, parens);
    },

    /* Interprets a decimal as a multiple of pi and formats it as would be
     * expected.
     *
     * If niceAngle is truthy, it also delivers more natural values for 0 (0 instead
     * of 0 \pi) and 1 (\pi instead of 1 \pi).
     * */
    piFraction: function(num, niceAngle, tolerance, big) {
        if (num.constructor === Number) {
            if (tolerance == null) {
                tolerance = 0.001;
            }

            var f = KhanUtil.toFraction(num / Math.PI, tolerance),
             n = f[0],
             d = f[1];

            if (niceAngle) {
                if (n === 0) {
                    return "0";
                }
                if (n === 1 && d === 1) {
                    return "\\pi";
                }
            }
            var frac = big ? KhanUtil.fraction(n, d) : KhanUtil.fractionSmall(n, d) ;
            return d === 1 ? n + "\\pi" : frac + "\\pi";
        }
    },

    /* Returns whether the fraction n/d reduces. */
    reduces: function(n, d) {
        // if the GCD is greater than 1, then there is a factor in common and the
        // fraction reduces.
        return KhanUtil.getGCD(n, d) > 1;
    },

    fractionSimplification: function(n, d) {
        var result = "\\frac{" + n + "}{" + d + "}";

        if (d <= 1 || KhanUtil.getGCD(n, d) > 1) {
            result += " = " + KhanUtil.fractionReduce(n, d);
        }

        return result;
    },

    // Randomly return the fraction in its mixed or improper form.
    mixedOrImproper: function(n, d) {
        // mixed
        if (n < d || KhanUtil.rand(2) > 0) {
            return KhanUtil.fraction(n, d);

        // improper
        } else {
            var imp = Math.floor(n / d);
            return imp + KhanUtil.fraction(n - (d * imp), d);
        }
    },

    // splitRadical(24) gives [2, 6] to mean 2 sqrt(6)
    splitRadical: function(n) {
        if (n === 0) {
            return [0, 1];
        }

        var coefficient = 1;
        var radical = n;

        for (var i = 2; i * i <= n; i++) {
            while (radical % (i * i) === 0) {
                radical /= i * i;
                coefficient *= i;
            }
        }

        return [coefficient, radical];
    },

    // formattedSquareRootOf(24) gives 2\sqrt{6}
    formattedSquareRootOf: function(n) {
        if (n === 1 || n === 0) {
            /* so as to not return "" or "\\sqrt{0}" later */
            return n.toString();
        } else {
            var split = KhanUtil.splitRadical(n);
            var coefficient = split[0] === 1 ? "" : split[0].toString();
            var radical = split[1] === 1 ? "" : "\\sqrt{" + split[1] + "}";

            return coefficient + radical;
        }
    },

    squareRootCanSimplify: function(n) {
        return KhanUtil.formattedSquareRootOf(n) !== ("\\sqrt{" + n + "}");
    },

    // For numbers 0-20, return the spelling of the number, otherwise
    // just return the number itself as a string.  This is superior to
    // cardinal() in that it can be translated easily.
    cardinalThrough20: function(n) {
        var cardinalUnits = [$._("zero"), $._("one"), $._("two"), $._("three"),
            $._("four"), $._("five"), $._("six"), $._("seven"), $._("eight"),
            $._("nine"), $._("ten"), $._("eleven"), $._("twelve"),
            $._("thirteen"), $._("fourteen"), $._("fifteen"), $._("sixteen"),
            $._("seventeen"), $._("eighteen"), $._("nineteen"), $._("twenty")];
        if (n >= 0 && n <= 20) {
            return cardinalUnits[n];
        }
        return String(n);
    },

    CardinalThrough20: function(n) {
        // NOTE(csilvers): I *think* this always does the right thing,
        // since scripts that capitalize always do so the same way.
        var card = KhanUtil.cardinalThrough20(n);
        return card.charAt(0).toUpperCase() + card.slice(1);
    },

    ordinalThrough20: function(n) {
        var ordinalUnits = [$._("zeroth"), $._("first"), $._("second"),
            $._("third"), $._("fourth"), $._("fifth"), $._("sixth"),
            $._("seventh"), $._("eighth"), $._("ninth"), $._("tenth"),
            $._("eleventh"), $._("twelfth"), $._("thirteenth"),
            $._("fourteenth"), $._("fifteenth"), $._("sixteenth"),
            $._("seventeenth"), $._("eighteenth"), $._("nineteenth"),
            $._("twentieth")];
        if (n >= 0 && n <= 20) {
            return ordinalUnits[n];
        }
        // This should "never" happen, but better to give weird results
        // than to raise an error.  I think.
        return n + "th";
    },

    // Ported from https://github.com/clojure/clojure/blob/master/src/clj/clojure/pprint/cl_format.clj#L285
    // TODO(csilvers): I18N: this doesn't work at all outside English.
    // cf. https://github.com/kslazarev/numbers_and_words (Ruby, sadly).
    cardinal: function(n) {
        var cardinalScales = ["", $._("thousand"), $._("million"),
            $._("billion"), $._("trillion"), $._("quadrillion"),
            $._("quintillion"), $._("sextillion"), $._("septillion"),
            $._("octillion"), $._("nonillion"), $._("decillion"),
            $._("undecillion"), $._("duodecillion"), $._("tredecillion"),
            $._("quattuordecillion"), $._("quindecillion"),
            $._("sexdecillion"), $._("septendecillion"), $._("octodecillion"),
            $._("novemdecillion"), $._("vigintillion")];
        var cardinalUnits = [$._("zero"), $._("one"), $._("two"), $._("three"),
            $._("four"), $._("five"), $._("six"), $._("seven"), $._("eight"),
            $._("nine"), $._("ten"), $._("eleven"), $._("twelve"),
            $._("thirteen"), $._("fourteen"), $._("fifteen"), $._("sixteen"),
            $._("seventeen"), $._("eighteen"), $._("nineteen")];
        var cardinalTens = ["", "", $._("twenty"), $._("thirty"), $._("forty"),
            $._("fifty"), $._("sixty"), $._("seventy"), $._("eighty"),
            $._("ninety")];
        // For formatting numbers less than 1000
        var smallNumberWords = function(n) {
            var hundredDigit = Math.floor(n / 100);
            var rest = n % 100;
            var str = "";

            if (hundredDigit) {
                str += $._("%(unit)s hundred",
                    {unit: cardinalUnits[hundredDigit]});
            }

            if (hundredDigit && rest) {
                str += " ";
            }

            if (rest) {
                if (rest < 20) {
                    str += cardinalUnits[rest];
                } else {
                    var tenDigit = Math.floor(rest / 10);
                    var unitDigit = rest % 10;

                    if (tenDigit) {
                        str += cardinalTens[tenDigit];
                    }

                    if (tenDigit && unitDigit) {
                        str += "-";
                    }

                    if (unitDigit) {
                        str += cardinalUnits[unitDigit];
                    }
                }
            }

            return str;
        };

        if (n === 0) {
            return $._("zero");
        } else {
            var neg = false;
            if (n < 0) {
                neg = true;
                n = Math.abs(n);
            }

            var words = [];
            var scale = 0;
            while (n > 0) {
                var end = n % 1000;

                if (end > 0) {
                    if (scale > 0) {
                        words.unshift(cardinalScales[scale]);
                    }

                    words.unshift(smallNumberWords(end));
                }

                n = Math.floor(n / 1000);
                scale += 1;
            }

            if (neg) {
                words.unshift($._("negative"));
            }

            return words.join(" ");
        }
    },

    Cardinal: function(n) {
        var card = KhanUtil.cardinal(n);
        return card.charAt(0).toUpperCase() + card.slice(1);
    },

    // Depends on expressions.js for expression formatting
    // Returns a string with the expression for the formatted roots of the quadratic
    // with coefficients a, b, c
    // i.e. "x = \pm 3", "
    quadraticRoots: function(a, b, c) {
        var underRadical = KhanUtil.splitRadical(b * b - 4 * a * c);
        var rootString = "x =";

        if ((b * b - 4 * a * c) === 0) {
            // 0 under the radical
            rootString += KhanUtil.fraction(-b, 2 * a, true, true, true);
        } else if (underRadical[1] === 1) {
            // The absolute value of the number under the radical is a perfect square
            rootString += KhanUtil.fraction(-b + underRadical[0], 2 * a, true, true, true) + "," +
                KhanUtil.fraction(-b - underRadical[0], 2 * a, true, true, true);
        } else if (underRadical[0] === 1) {
            // The number under the radical cannot be simplified
            rootString += KhanUtil.expr(["frac", ["+-", -b, ["sqrt", underRadical[1]]], 2 * a]);
        } else {
            // under the radical can be partially simplified
            var divisor = KhanUtil.getGCD(b, 2 * a, underRadical[0]);

            if (divisor === Math.abs(2 * a)) {
                rootString += KhanUtil.expr(["+-", -b / (2 * a), ["*", underRadical[0] / divisor,
                                                                 ["sqrt", underRadical[1]]]]);
            } else {
                rootString += KhanUtil.expr(["frac", ["+-", -b / divisor, ["*", underRadical[0] / divisor,
                                                                                ["sqrt", underRadical[1]]]],
                                                     2 * a / divisor]);
            }
        }
        return rootString;
    },

    // Thanks to Ghostoy on http://stackoverflow.com/questions/6784894/commafy/6786040#6786040
    commafy: function(num) {
        var str = num.toString().split(".");
        var thousands = icu.getDecimalFormatSymbols().grouping_separator;
        var decimal = icu.getDecimalFormatSymbols().decimal_separator;

        // Note that this is not actually the space character. You can find
        // this character in the icu.XX.js files that use space separators (for
        // example, icu.fr.js)
        if (thousands === "") {
            thousands = "\\;";
        }

        if (str[0].length >= 5) {
            str[0] = str[0].replace(/(\d)(?=(\d{3})+$)/g,
                                    "$1{" + thousands + "}");
        }

        if (str[1] && str[1].length >= 5) {
            str[1] = str[1].replace(/(\d{3})(?=\d)/g, "$1\\;");
        }

        return str.join(decimal);
    },

    // Formats strings like "Axy + By + Cz + D" where A, B, and C are variables
    // initialized to unknown values. Formats things so that TeX takes care of
    // negatives, and also handles cases where the strings beind added are wrapped
    // in TeX color declarations (\color{blue}{Axy} to \color{blue}{xy} if A is 1,
    // and won't be inserted at all if A is 0). Also <code><var>plus(A, B, C)
    // </var></code> is cleaner than <code><var>A</var> + <var>B</var> + <var>C</var></code>.
    // Note: this is somewhat treading on the territory of expressions.js, but has
    // a slightly different use case.
    plus: function() {

        var args = [], s;

        for (var i = 0; i < arguments.length; i++) {
            s = KhanUtil._plusTrim(arguments[i]);
            if (s) {
                args.push(s);
            }
        }

        return args.length > 0 ? args.join(" + ") : "0";
    },

    _plusTrim: function(s) {
        
        if (typeof s === "string" && isNaN(s)) {

            // extract color, so we can handle stripping the 1 out of \color{blue}{1xy}
            if (s.indexOf("{") !== -1) {

                // we're expecting something like "\color{blue}{-1}..."
                var l = s.indexOf("{", s.indexOf("{") + 1) + 1;
                var r = s.indexOf("}", s.indexOf("}") + 1);

                // if we've encountered \color{blue}{1}\color{xy} somehow
                if (l !== s.lastIndexOf("{") + 1 && +KhanUtil._plusTrim(s.slice(l, r)) === 1) {
                    if (s.indexOf("\\") !== -1) {
                        return s.slice(0, s.indexOf("\\")) + s.slice(r + 1);
                    } else {
                        return s.slice(r + 1);
                    }
                }

                return s.slice(0, l) + KhanUtil._plusTrim(s.slice(l, r)) + s.slice(r);
            }

            if (s.indexOf("1") === 0 && isNaN(s[1])) {
                return s.slice(1);
            } else if (s.indexOf("-1") === 0 && isNaN(s[2])) {
                return "-" + s.slice(2);
            } else if (s.indexOf("0") === 0 || s.indexOf("-0") === 0) {
                return "";
            } else {
                return s;
            }

        } else if (typeof s === "number") {

            // we'll just return the number, but this will actually end up getting
            // rid of 0's since a returned 0 will be falsey.
            return s;

            // if we're dealing with a string that looks like a number
        } else if (!isNaN(s)) {

            return +s;

        }

    },

    randVar: function() {
        // NOTE(jeresig): i18n: I assume it's OK to have roman letters here
        return KhanUtil.randFromArray(["a", "k", "n", "p", "q", "r", "t", "x", "y", "z"]);
    },

    eulerFormExponent: function(angle) {
        var fraction = KhanUtil.toFraction(angle / Math.PI, 0.001);
        var numerator = fraction[0], denominator = fraction[1];
        var eExp = ((numerator > 1) ? numerator : "") + "\\pi i";
        if (denominator !== 1) {
            eExp += " / " + denominator;
        }
        return eExp;
    },

    // Formats a complex number in polar form.
    polarForm: function(radius, angle, useEulerForm) {
        var fraction = KhanUtil.toFraction(angle / Math.PI, 0.001);
        var numerator = fraction[0];

        var equation;
        if (useEulerForm) {
            if (numerator > 0) {
                var ePower = KhanUtil.expr(["^", "e", KhanUtil.eulerFormExponent(angle)]);
                equation = ((radius > 1) ? radius : "") + " " + ePower;
            } else {
                equation = radius;
            }
        } else {
            if (angle === 0) {
                equation = radius;
            } else {
                var angleRep = KhanUtil.piFraction(angle, true);
                var cis = "\\cos(" + angleRep + ") + i \\sin(" + angleRep + ")";

                // Special case to circumvent ugly "*1* (sin(...) + i cos(...))"
                if (radius !== 1) {
                    equation = KhanUtil.expr(["*", radius, cis]);
                } else {
                    equation = cis;
                }
            }
        }
        return equation;
    },

    coefficient: function(n) {
        if (n === 1 || n === "1") {
            return "";
        } else if (n === -1 || n === "-1") {
            return "-";
        } else {
            return n;
        }
    },

    fractionVariable: function(numerator, denominator, variable) {
        if (denominator === 0) {
            return "\\text{undefined}";
        }

        if (numerator === 0) {
            return 0;
        }

        if (denominator < 0) {
            numerator *= -1;
            denominator *= -1;
        }

        var GCD = KhanUtil.getGCD(numerator, denominator);
        numerator /= GCD;
        denominator /= GCD;

        if (denominator === 1) {
            return KhanUtil.coefficient(numerator) + variable;
        }

        if (numerator < 0) {
            return "-\\dfrac{" + KhanUtil.coefficient(-numerator) + variable + "}{" + denominator + "}";
        } else {
            return "\\dfrac{" + KhanUtil.coefficient(numerator) + variable + "}{" + denominator + "}";
        }
    },

    complexNumber: function(real, imaginary) {
        if (real === 0 && imaginary === 0) {
            return "0";
        } else if (real === 0) {
            return (KhanUtil.coefficient(imaginary)) + "i";
        } else if (imaginary === 0) {
            return real;
        } else {
            return KhanUtil.expr(["+", real, ["*", imaginary, "i"]]);
        }
    },

    complexFraction: function(real, realDenominator, imag, imagDenominator) {
        var ret = "";
        if (real === 0 && imag === 0) {
            ret = "0";
        }
        if (real !== 0) {
            ret += KhanUtil.fraction(real, realDenominator, false, true);
        }
        if (imag !== 0) {
            if (imag / imagDenominator > 0) {
                if (real !== 0) {
                    ret += " + ";
                }
                ret += KhanUtil.fraction(imag, imagDenominator, false, true) + " i";
            } else {
                imag = Math.abs(imag);
                imagDenominator = Math.abs(imagDenominator);
                ret += " - ";
                ret += KhanUtil.fraction(imag, imagDenominator, false, true) + " i";
            }
        }
        return ret;
    },

    scientificExponent: function(num) {
        return Math.floor(Math.log(Math.abs(num)) / Math.log(10));
    },

    scientificMantissa: function(precision, num) {
        var exponent = KhanUtil.scientificExponent(num);
        var factor = Math.pow(10, exponent);
        precision -= 1; // To account for the 1s digit
        var mantissa = KhanUtil.roundTo(precision, num / factor);
        return mantissa;
    },

    scientific: function(precision, num) {
        var exponent = KhanUtil.scientificExponent(num);
        var mantissa = KhanUtil.localeToFixed(KhanUtil.scientificMantissa(precision, num), precision);
        return "" + mantissa + "\\times 10^{" + exponent + "}";
    }
});

});

define('utils/chemistry.js',['require','./math-format.js'],function(require) {

require("./math-format.js");

$.fn["chemistryLoad"] = function() {
    // TODO(jeresig): i18n: Currently the names of the atomic elements aren't
    // being used in the UI, but if they are, they will need to be translated.
    var elements = {
        "Hydrogen": {
            "symbol" : "H",
            "atomic_number" : 1,
            "atomic_weight" : 1.00794,
            "density g/cm" : "0.0708 (@ -253C)",
            "melting_point K" : 14.01,
            "boiling_point K" : 20.28,
            "atomic_radius pm" : 79,
            "covalent_radius pm" : 32,
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : 14.1,
            "specific_heat (@20C J/g mol)" : "14.267 (H-H)",
            "fusion_heat (kJ/mol)" : "0.117 (H-H)",
            "evaporation_heat (kJ/mol)" : "0.904 (H-H)",
            "thermal_conductivity (@25C W/m K) " : 0.1815,
            "pauling_negativity" : 2.20,
            "first_ionizing kJ/mol" : 1311.3,
            "oxidation_states" : "1, -1",
            "electronic_configuration" : "1s",
            "lattice_structure" : "HEX",
            "lattice_constant ang" : 3.750
        },
        "Helium": {
            "symbol" : "He",
            "atomic_number" : 2,
            "atomic_weight" : 4.002602,
            "density g/cm" : "0.147 (@ -270C)",
            "melting_point K" : 0.95,
            "boiling_point K" : 4.216,
            "atomic_radius pm" : 0.0,
            "covalent_radius pm" : "-",
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : 31.8,
            "specific_heat (@20C J/g mol)" : 5.188,
            "fusion_heat (kJ/mol)" : "-",
            "evaporation_heat (kJ/mol)" : 0.08,
            "thermal_conductivity (@25C W/m K) " : 0.152,
            "pauling_negativity" : "-",
            "first_ionizing kJ/mol" : 2361.3,
            "oxidation_states" : "-",
            "electronic_configuration" : "1s",
            "lattice_structure" : "HEX",
            "lattice_constant ang" : 3.570
        },
        "Lithium": {
            "symbol" : "Li",
            "atomic_number" : 3,
            "atomic_weight" : 6.941,
            "density g/cm" : 0.534,
            "melting_point K" : 553.69,
            "boiling_point K" : 1118.15,
            "atomic_radius pm" : 155,
            "covalent_radius pm" : 163,
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : 13.1,
            "specific_heat (@20C J/g mol)" : 3.489,
            "fusion_heat (kJ/mol)" : 2.89,
            "evaporation_heat (kJ/mol)" : 148,
            "thermal_conductivity (@25C W/m K) " : 84.8,
            "pauling_negativity" : 0.98,
            "first_ionizing kJ/mol" : 519.9,
            "oxidation_states" : 1,
            "electronic_configuration" : "[He]2s",
            "lattice_structure" : "BCC",
            "lattice_constant ang" : 3.490
        },
        "Beryllium": {
            "symbol" : "Be",
            "atomic_number" : 4,
            "atomic_weight" : 9.01218,
            "density g/cm" : 1.848,
            "melting_point K" : 1551,
            "boiling_point K" : 3243,
            "atomic_radius pm" : 112,
            "covalent_radius pm" : 90,
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : 5.0,
            "specific_heat (@20C J/g mol)" : 1.824,
            "fusion_heat (kJ/mol)" : 12.21,
            "evaporation_heat (kJ/mol)" : 309,
            "thermal_conductivity (@25C W/m K) " : 201,
            "pauling_negativity" : 1.57,
            "first_ionizing kJ/mol" : 898.8,
            "oxidation_states" : 2,
            "electronic_configuration" : "[He]2s",
            "lattice_structure" : "HEX",
            "lattice_constant ang" : 2.290
        },
        "Boron": {
            "symbol" : "B",
            "atomic_number" : 5,
            "atomic_weight" : 10.811,
            "density g/cm" : 2.34,
            "melting_point K" : 2573,
            "boiling_point K" : 3931,
            "atomic_radius pm" : 98,
            "covalent_radius pm" : 82,
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : 4.6,
            "specific_heat (@20C J/g mol)" : 1.025,
            "fusion_heat (kJ/mol)" : 23.60,
            "evaporation_heat (kJ/mol)" : 504.5,
            "thermal_conductivity (@25C W/m K) " : 27.4,
            "pauling_negativity" : 2.04,
            "first_ionizing kJ/mol" : 800.2,
            "oxidation_states" : 3,
            "electronic_configuration" : "[He]2s2p",
            "lattice_structure" : "TET",
            "lattice_constant ang" : 8.730
        },
        "Carbon": {
            "symbol" : "C",
            "atomic_number" : 6,
            "atomic_weight" : 12.011,
            "density g/cm" : "2.25 (graphite)",
            "melting_point K" : 3820,
            "boiling_point K" : 5100,
            "atomic_radius pm" : 91,
            "covalent_radius pm" : 77,
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : 5.3,
            "specific_heat (@20C J/g mol)" : 0.711,
            "fusion_heat (kJ/mol)" : "-",
            "evaporation_heat (kJ/mol)" : "-",
            "thermal_conductivity (@25C W/m K) " : 1.59,
            "pauling_negativity" : 2.55,
            "first_ionizing kJ/mol" : 1085.7,
            "oxidation_states" : "4, 2, -4",
            "electronic_configuration" : "[He]2s2p",
            "lattice_structure" : "DIA",
            "lattice_constant ang" : 3.570
        },
        "Nitrogen": {
            "symbol" : "N",
            "atomic_number" : 7,
            "atomic_weight" : 14.00674,
            "density g/cm" : "0.808 (@ -195.8C)",
            "melting_point K" : 63.29,
            "boiling_point K" : 77.4,
            "atomic_radius pm" : 92,
            "covalent_radius pm" : 75,
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : 17.3,
            "specific_heat (@20C J/g mol)" : "1.042 (N-N)",
            "fusion_heat (kJ/mol)" : "-",
            "evaporation_heat (kJ/mol)" : "-",
            "thermal_conductivity (@25C W/m K) " : 0.026,
            "pauling_negativity" : 3.04,
            "first_ionizing kJ/mol" : 1401.5,
            "oxidation_states" : "5, 4, 3, 2, -3",
            "electronic_configuration" : "[He]2s2p",
            "lattice_structure" : "HEX",
            "lattice_constant ang" : 4.039
        },
        "Oxygen": {
            "symbol" : "O",
            "atomic_number" : 8,
            "atomic_weight" : 15.9994,
            "density g/cm" : "1.149 (@ -183C)",
            "melting_point K" : 54.8,
            "boiling_point K" : 90.19,
            "atomic_radius pm" : "-",
            "covalent_radius pm" : 73,
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : 14.0,
            "specific_heat (@20C J/g mol)" : "0.916 (O-O)",
            "fusion_heat (kJ/mol)" : "-",
            "evaporation_heat (kJ/mol)" : "-",
            "thermal_conductivity (@25C W/m K) " : 0.027,
            "pauling_negativity" : 3.44,
            "first_ionizing kJ/mol" : 1313.1,
            "oxidation_states" : "-2, -1",
            "electronic_configuration" : "[He]2s2p",
            "lattice_structure" : "CUB",
            "lattice_constant ang" : 6.830
        },
        "Fluorine": {
            "symbol" : "F",
            "atomic_number" : 9,
            "atomic_weight" : 18.998403,
            "density g/cm" : "1.108 (@ -189C)",
            "melting_point K" : 53.53,
            "boiling_point K" : 85.01,
            "atomic_radius pm" : "-",
            "covalent_radius pm" : 72,
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : 17.1,
            "specific_heat (@20C J/g mol)" : "0.824 (F-F)",
            "fusion_heat (kJ/mol)" : "0.51 (F-F)",
            "evaporation_heat (kJ/mol)" : "6.54 (F-F)",
            "thermal_conductivity (@25C W/m K) " : 0.028,
            "pauling_negativity" : 3.98,
            "first_ionizing kJ/mol" : 1680.0,
            "oxidation_states" : -1,
            "electronic_configuration" : "[He]2s2p",
            "lattice_structure" : "MCL",
            "lattice_constant ang" : "-"
        },
        "Neon": {
            "symbol" : "Ne",
            "atomic_number" : 10,
            "atomic_weight" : 20.1797,
            "density g/cm" : "1.204 (@ -246C)",
            "melting_point K" : 48,
            "boiling_point K" : 27.1,
            "atomic_radius pm" : "-",
            "covalent_radius pm" : 71,
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : 16.8,
            "specific_heat (@20C J/g mol)" : 1.029,
            "fusion_heat (kJ/mol)" : "-",
            "evaporation_heat (kJ/mol)" : 1.74,
            "thermal_conductivity (@25C W/m K) " : "(0.0493)",
            "pauling_negativity" : 0.0,
            "first_ionizing kJ/mol" : 2079.4,
            "oxidation_states" : "-",
            "electronic_configuration" : "[He]2s2p",
            "lattice_structure" : "FCC",
            "lattice_constant ang" : 4.430
        },
        "Sodium": {
            "symbol" : "Na",
            "atomic_number" : 11,
            "atomic_weight" : 22.989768,
            "density g/cm" : 0.971,
            "melting_point K" : 370.96,
            "boiling_point K" : 1156.1,
            "atomic_radius pm" : 190,
            "covalent_radius pm" : 154,
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : 23.7,
            "specific_heat (@20C J/g mol)" : 1.222,
            "fusion_heat (kJ/mol)" : 2.64,
            "evaporation_heat (kJ/mol)" : 97.9,
            "thermal_conductivity (@25C W/m K) " : 142.0,
            "pauling_negativity" : 0.93,
            "first_ionizing kJ/mol" : 495.6,
            "oxidation_states" : 1,
            "electronic_configuration" : "[Ne]3s",
            "lattice_structure" : "BCC",
            "lattice_constant ang" : 4.230
        },
        "Magnesium": {
            "symbol" : "Mg",
            "atomic_number" : 12,
            "atomic_weight" : 24.305,
            "density g/cm" : 1.738,
            "melting_point K" : 922,
            "boiling_point K" : 1363,
            "atomic_radius pm" : 160,
            "covalent_radius pm" : 136,
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : 14.0,
            "specific_heat (@20C J/g mol)" : 1.025,
            "fusion_heat (kJ/mol)" : 9.20,
            "evaporation_heat (kJ/mol)" : 131.8,
            "thermal_conductivity (@25C W/m K) " : 156,
            "pauling_negativity" : 1.31,
            "first_ionizing kJ/mol" : 737.3,
            "oxidation_states" : 2,
            "electronic_configuration" : "[Ne]3s",
            "lattice_structure" : "HEX",
            "lattice_constant ang" : 3.210
        },
        "Aluminum": {
            "symbol" : "Al",
            "atomic_number" : 13,
            "atomic_weight" : 26.981539,
            "density g/cm" : 2.6989,
            "melting_point K" : 933.5,
            "boiling_point K" : 2740,
            "atomic_radius pm" : 143,
            "covalent_radius pm" : 118,
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : 10.0,
            "specific_heat (@20C J/g mol)" : 0.900,
            "fusion_heat (kJ/mol)" : 10.75,
            "evaporation_heat (kJ/mol)" : 284.1,
            "thermal_conductivity (@25C W/m K) " : 237,
            "pauling_negativity" : 1.61,
            "first_ionizing kJ/mol" : 577.2,
            "oxidation_states" : 3,
            "electronic_configuration" : "[Ne]3s3p",
            "lattice_structure" : "FCC",
            "lattice_constant ang" : 4.050
        },
        "Silicon": {
            "symbol" : "Si",
            "atomic_number" : 14,
            "atomic_weight" : 28.0855,
            "density g/cm" : 2.33,
            "melting_point K" : 1683,
            "boiling_point K" : 2628,
            "atomic_radius pm" : 132,
            "covalent_radius pm" : 111,
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : 12.1,
            "specific_heat (@20C J/g mol)" : 0.703,
            "fusion_heat (kJ/mol)" : 50.6,
            "evaporation_heat (kJ/mol)" : 383,
            "thermal_conductivity (@25C W/m K) " : 149,
            "pauling_negativity" : 1.90,
            "first_ionizing kJ/mol" : 786.0,
            "oxidation_states" : "4, -4",
            "electronic_configuration" : "[Ne]3s3p",
            "lattice_structure" : "DIA",
            "lattice_constant ang" : 5.430
        },
        "Phosphorus": {
            "symbol" : "P",
            "atomic_number" : 15,
            "atomic_weight" : 30.973762,
            "density g/cm" : "1.82 (white phosphorus)",
            "melting_point K" : 317.3,
            "boiling_point K" : 553,
            "atomic_radius pm" : 128,
            "covalent_radius pm" : 106,
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : 17.0,
            "specific_heat (@20C J/g mol)" : 0.757,
            "fusion_heat (kJ/mol)" : 2.51,
            "evaporation_heat (kJ/mol)" : 49.8,
            "thermal_conductivity (@25C W/m K) " : "(0.236)",
            "pauling_negativity" : 2.19,
            "first_ionizing kJ/mol" : 1011.2,
            "oxidation_states" : "5, 3, -3",
            "electronic_configuration" : "[Ne]3s3p",
            "lattice_structure" : "CUB",
            "lattice_constant ang" : 7.170
        },
        "Sulfur": {
            "symbol" : "S",
            "atomic_number" : 16,
            "atomic_weight" : 32.066,
            "density g/cm" : 2.070,
            "melting_point K" : 386,
            "boiling_point K" : 717.824,
            "atomic_radius pm" : 127,
            "covalent_radius pm" : 102,
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : 15.5,
            "specific_heat (@20C J/g mol)" : 0.732,
            "fusion_heat (kJ/mol)" : 1.23,
            "evaporation_heat (kJ/mol)" : 10.5,
            "thermal_conductivity (@25C W/m K) " : 0.27,
            "pauling_negativity" : 2.58,
            "first_ionizing kJ/mol" : 999.0,
            "oxidation_states" : "6, 4, 2, -2",
            "electronic_configuration" : "[Ne]3s3p",
            "lattice_structure" : "ORC",
            "lattice_constant ang" : 10.470
        },
        "Chlorine": {
            "symbol" : "Cl",
            "atomic_number" : 17,
            "atomic_weight" : 35.4527,
            "density g/cm" : "1.56 (@ -33.6C)",
            "melting_point K" : 172.2,
            "boiling_point K" : 238.6,
            "atomic_radius pm" : "-",
            "covalent_radius pm" : 99,
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : 18.7,
            "specific_heat (@20C J/g mol)" : "0.477 (Cl-Cl)",
            "fusion_heat (kJ/mol)" : "6.41 (Cl-Cl)",
            "evaporation_heat (kJ/mol)" : "20.41 (Cl-Cl)",
            "thermal_conductivity (@25C W/m K) " : 0.009,
            "pauling_negativity" : 3.16,
            "first_ionizing kJ/mol" : 1254.9,
            "oxidation_states" : "7, 5, 3, 1, -1",
            "electronic_configuration" : "[Ne]3s3p",
            "lattice_structure" : "ORC",
            "lattice_constant ang" : 6.240
        },
        "Argon": {
            "symbol" : "Ar",
            "atomic_number" : 18,
            "atomic_weight" : 39.948,
            "density g/cm" : "1.40 (@ -186C)",
            "melting_point K" : 83.8,
            "boiling_point K" : 87.3,
            "atomic_radius pm" : "2-",
            "covalent_radius pm" : 98,
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : 24.2,
            "specific_heat (@20C J/g mol)" : 0.138,
            "fusion_heat (kJ/mol)" : "-",
            "evaporation_heat (kJ/mol)" : 6.52,
            "thermal_conductivity (@25C W/m K) " : 0.0177,
            "pauling_negativity" : 0.0,
            "first_ionizing kJ/mol" : 1519.6,
            "oxidation_states" : "-",
            "electronic_configuration" : "[Ne]3s3p",
            "lattice_structure" : "FCC",
            "lattice_constant ang" : 5.260
        },
        "Potassium": {
            "symbol" : "K",
            "atomic_number" : 19,
            "atomic_weight" : 39.0983,
            "density g/cm" : 0.856,
            "melting_point K" : 336.8,
            "boiling_point K" : 1047,
            "atomic_radius pm" : 235,
            "covalent_radius pm" : 203,
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : 45.3,
            "specific_heat (@20C J/g mol)" : 0.753,
            "fusion_heat (kJ/mol)" : 102.5,
            "evaporation_heat (kJ/mol)" : 2.33,
            "thermal_conductivity (@25C W/m K) " : 79.0,
            "pauling_negativity" : 0.82,
            "first_ionizing kJ/mol" : 418.5,
            "oxidation_states" : 1,
            "electronic_configuration" : "[Ar]4s",
            "lattice_structure" : "BCC",
            "lattice_constant ang" : 5.230
        },
        "Calcium": {
            "symbol" : "Ca",
            "atomic_number" : 20,
            "atomic_weight" : 40.078,
            "density g/cm" : 1.55,
            "melting_point K" : 1112,
            "boiling_point K" : 1757,
            "atomic_radius pm" : 197,
            "covalent_radius pm" : 174,
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : 29.9,
            "specific_heat (@20C J/g mol)" : 0.653,
            "fusion_heat (kJ/mol)" : 9.20,
            "evaporation_heat (kJ/mol)" : 153.6,
            "thermal_conductivity (@25C W/m K) " : "(201)",
            "pauling_negativity" : 1.00,
            "first_ionizing kJ/mol" : 589.4,
            "oxidation_states" : 2,
            "electronic_configuration" : "[Ar]4s",
            "lattice_structure" : "FCC",
            "lattice_constant ang" : 5.580
        },
        "Scandium": {
            "symbol" : "Sc",
            "atomic_number" : 21,
            "atomic_weight" : 44.95591,
            "density g/cm" : 2.99,
            "melting_point K" : 1814,
            "boiling_point K" : 3104,
            "atomic_radius pm" : 162,
            "covalent_radius pm" : 144,
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : 15.0,
            "specific_heat (@20C J/g mol)" : 0.556,
            "fusion_heat (kJ/mol)" : 15.8,
            "evaporation_heat (kJ/mol)" : 332.7,
            "thermal_conductivity (@25C W/m K) " : 15.8,
            "pauling_negativity" : 1.36,
            "first_ionizing kJ/mol" : 630.8,
            "oxidation_states" : 3,
            "electronic_configuration" : "[Ar]3d4s",
            "lattice_structure" : "HEX",
            "lattice_constant ang" : 3.310
        },
        "Titanium": {
            "symbol" : "Ti",
            "atomic_number" : 22,
            "atomic_weight" : 47.88,
            "density g/cm" : 4.54,
            "melting_point K" : 1933,
            "boiling_point K" : 3560,
            "atomic_radius pm" : 147,
            "covalent_radius pm" : 132,
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : 10.6,
            "specific_heat (@20C J/g mol)" : 0.523,
            "fusion_heat (kJ/mol)" : 18.8,
            "evaporation_heat (kJ/mol)" : 422.6,
            "thermal_conductivity (@25C W/m K) " : 21.9,
            "pauling_negativity" : 1.54,
            "first_ionizing kJ/mol" : 657.8,
            "oxidation_states" : "4, 3",
            "electronic_configuration" : "[Ar]3d4s",
            "lattice_structure" : "HEX",
            "lattice_constant ang" : 2.950
        },
        "Vanadium": {
            "symbol" : "V",
            "atomic_number" : 23,
            "atomic_weight" : 50.9415,
            "density g/cm" : 6.11,
            "melting_point K" : 2160,
            "boiling_point K" : 3650,
            "atomic_radius pm" : 134,
            "covalent_radius pm" : 122,
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : 8.35,
            "specific_heat (@20C J/g mol)" : 0.485,
            "fusion_heat (kJ/mol)" : 17.5,
            "evaporation_heat (kJ/mol)" : 460,
            "thermal_conductivity (@25C W/m K) " : 30.7,
            "pauling_negativity" : 1.63,
            "first_ionizing kJ/mol" : 650.1,
            "oxidation_states" : "5, 4, 3, 2, 0",
            "electronic_configuration" : "[Ar]3d4s",
            "lattice_structure" : "BCC",
            "lattice_constant ang" : 3.020
        },
        "Chromium": {
            "symbol" : "Cr",
            "atomic_number" : 24,
            "atomic_weight" : 51.9961,
            "density g/cm" : 7.18,
            "melting_point K" : 2130,
            "boiling_point K" : 2945,
            "atomic_radius pm" : 130,
            "covalent_radius pm" : 118,
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : 7.23,
            "specific_heat (@20C J/g mol)" : 0.488,
            "fusion_heat (kJ/mol)" : 21,
            "evaporation_heat (kJ/mol)" : 342,
            "thermal_conductivity (@25C W/m K) " : 93.9,
            "pauling_negativity" : 1.66,
            "first_ionizing kJ/mol" : 652.4,
            "oxidation_states" : "6, 3, 2, 0",
            "electronic_configuration" : "[Ar]3d4s",
            "lattice_structure" : "BCC",
            "lattice_constant ang" : 2.880
        },
        "Manganese": {
            "symbol" : "Mn",
            "atomic_number" : 25,
            "atomic_weight" : 54.93805,
            "density g/cm" : 7.21,
            "melting_point K" : 1517,
            "boiling_point K" : 2235,
            "atomic_radius pm" : 135,
            "covalent_radius pm" : 117,
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : 7.39,
            "specific_heat (@20C J/g mol)" : 0.477,
            "fusion_heat (kJ/mol)" : "(13.4)",
            "evaporation_heat (kJ/mol)" : 221,
            "thermal_conductivity (@25C W/m K) " : "(7.8)",
            "pauling_negativity" : 1.55,
            "first_ionizing kJ/mol" : 716.8,
            "oxidation_states" : "7, 6, 4, 3, 2, 0, -1",
            "electronic_configuration" : "[Ar]3d4s",
            "lattice_structure" : "CUB",
            "lattice_constant ang" : 8.890
        },
        "Iron": {
            "symbol" : "Fe",
            "atomic_number" : 26,
            "atomic_weight" : 55.847,
            "density g/cm" : 7.874,
            "melting_point K" : 1808,
            "boiling_point K" : 3023,
            "atomic_radius pm" : 126,
            "covalent_radius pm" : 117,
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : 7.1,
            "specific_heat (@20C J/g mol)" : 0.443,
            "fusion_heat (kJ/mol)" : 13.8,
            "evaporation_heat (kJ/mol)" : "~340",
            "thermal_conductivity (@25C W/m K) " : 80.4,
            "pauling_negativity" : 1.83,
            "first_ionizing kJ/mol" : 759.1,
            "oxidation_states" : "6, 3, 2, 0, -2",
            "electronic_configuration" : "[Ar]3d4s",
            "lattice_structure" : "BCC",
            "lattice_constant ang" : 2.870
        },
        "Cobalt": {
            "symbol" : "Co",
            "atomic_number" : 27,
            "atomic_weight" : 58.9332,
            "density g/cm" : 8.9,
            "melting_point K" : 1768,
            "boiling_point K" : 3143,
            "atomic_radius pm" : 125,
            "covalent_radius pm" : 116,
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : 6.7,
            "specific_heat (@20C J/g mol)" : 0.456,
            "fusion_heat (kJ/mol)" : 15.48,
            "evaporation_heat (kJ/mol)" : 389.1,
            "thermal_conductivity (@25C W/m K) " : 100,
            "pauling_negativity" : 1.88,
            "first_ionizing kJ/mol" : 758.1,
            "oxidation_states" : "3, 2, 0, -1",
            "electronic_configuration" : "[Ar]3d4s",
            "lattice_structure" : "HEX",
            "lattice_constant ang" : 2.510
        },
        "Nickel": {
            "symbol" : "Ni",
            "atomic_number" : 28,
            "atomic_weight" : 58.6934,
            "density g/cm" : 8.902,
            "melting_point K" : 1726,
            "boiling_point K" : 3005,
            "atomic_radius pm" : 124,
            "covalent_radius pm" : 115,
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : 6.6,
            "specific_heat (@20C J/g mol)" : 0.443,
            "fusion_heat (kJ/mol)" : 17.61,
            "evaporation_heat (kJ/mol)" : 378.6,
            "thermal_conductivity (@25C W/m K) " : 90.9,
            "pauling_negativity" : 1.91,
            "first_ionizing kJ/mol" : 736.2,
            "oxidation_states" : "3, 2, 0",
            "electronic_configuration" : "[Ar]3d4s",
            "lattice_structure" : "FCC",
            "lattice_constant ang" : 3.520
        },
        "Copper": {
            "symbol" : "Cu",
            "atomic_number" : 29,
            "atomic_weight" : 63.546,
            "density g/cm" : 8.96,
            "melting_point K" : 1356.6,
            "boiling_point K" : 2840,
            "atomic_radius pm" : 128,
            "covalent_radius pm" : 117,
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : 7.1,
            "specific_heat (@20C J/g mol)" : 0.385,
            "fusion_heat (kJ/mol)" : 13.01,
            "evaporation_heat (kJ/mol)" : 304.6,
            "thermal_conductivity (@25C W/m K) " : 401,
            "pauling_negativity" : 1.90,
            "first_ionizing kJ/mol" : 745.0,
            "oxidation_states" : "2, 1",
            "electronic_configuration" : "[Ar]3d4s",
            "lattice_structure" : "FCC",
            "lattice_constant ang" : 3.610
        },
        "Zinc": {
            "symbol" : "Zn",
            "atomic_number" : 30,
            "atomic_weight" : 65.39,
            "density g/cm" : 7.133,
            "melting_point K" : 692.73,
            "boiling_point K" : 1180,
            "atomic_radius pm" : 138,
            "covalent_radius pm" : 125,
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : 9.2,
            "specific_heat (@20C J/g mol)" : 0.388,
            "fusion_heat (kJ/mol)" : 7.28,
            "evaporation_heat (kJ/mol)" : 114.8,
            "thermal_conductivity (@25C W/m K) " : 116,
            "pauling_negativity" : 1.65,
            "first_ionizing kJ/mol" : 905.8,
            "oxidation_states" : 2,
            "electronic_configuration" : "[Ar]3d4s",
            "lattice_structure" : "HEX",
            "lattice_constant ang" : 2.660
        },
        "Gallium": {
            "symbol" : "Ga",
            "atomic_number" : 31,
            "atomic_weight" : 69.723,
            "density g/cm" : 5.91,
            "melting_point K" : 302.93,
            "boiling_point K" : 2676,
            "atomic_radius pm" : 141,
            "covalent_radius pm" : 126,
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : 11.8,
            "specific_heat (@20C J/g mol)" : 0.372,
            "fusion_heat (kJ/mol)" : 5.59,
            "evaporation_heat (kJ/mol)" : 270.3,
            "thermal_conductivity (@25C W/m K) " : 28.1,
            "pauling_negativity" : 1.81,
            "first_ionizing kJ/mol" : 578.7,
            "oxidation_states" : 3,
            "electronic_configuration" : "[Ar]3d4s4p",
            "lattice_structure" : "ORC",
            "lattice_constant ang" : 4.510
        },
        "Germanium": {
            "symbol" : "Ge",
            "atomic_number" : 32,
            "atomic_weight" : 72.61,
            "density g/cm" : 5.323,
            "melting_point K" : 1210.6,
            "boiling_point K" : 3103,
            "atomic_radius pm" : 137,
            "covalent_radius pm" : 122,
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : 13.6,
            "specific_heat (@20C J/g mol)" : 0.322,
            "fusion_heat (kJ/mol)" : 36.8,
            "evaporation_heat (kJ/mol)" : 328,
            "thermal_conductivity (@25C W/m K) " : 60.2,
            "pauling_negativity" : 2.01,
            "first_ionizing kJ/mol" : 760.0,
            "oxidation_states" : 4,
            "electronic_configuration" : "[Ar]3d4s4p",
            "lattice_structure" : "DIA",
            "lattice_constant ang" : 5.660
        },
        "Arsenic": {
            "symbol" : "As",
            "atomic_number" : 33,
            "atomic_weight" : 74.92159,
            "density g/cm" : "5.73 (grey arsenic)",
            "melting_point K" : 1090,
            "boiling_point K" : 876,
            "atomic_radius pm" : 139,
            "covalent_radius pm" : 120,
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : 13.1,
            "specific_heat (@20C J/g mol)" : 0.328,
            "fusion_heat (kJ/mol)" : "-",
            "evaporation_heat (kJ/mol)" : 32.4,
            "thermal_conductivity (@25C W/m K) " : "(50.2)",
            "pauling_negativity" : 2.18,
            "first_ionizing kJ/mol" : 946.2,
            "oxidation_states" : "5, 3, -2",
            "electronic_configuration" : "[Ar]3d4s4p",
            "lattice_structure" : "RHL",
            "lattice_constant ang" : 4.130
        },
        "Selenium": {
            "symbol" : "Se",
            "atomic_number" : 34,
            "atomic_weight" : 78.96,
            "density g/cm" : 4.79,
            "melting_point K" : 490,
            "boiling_point K" : 958.1,
            "atomic_radius pm" : 140,
            "covalent_radius pm" : 116,
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : 16.5,
            "specific_heat (@20C J/g mol)" : "0.321 (Se-Se)",
            "fusion_heat (kJ/mol)" : 5.23,
            "evaporation_heat (kJ/mol)" : 59.7,
            "thermal_conductivity (@25C W/m K) " : 0.52,
            "pauling_negativity" : 2.55,
            "first_ionizing kJ/mol" : 940.4,
            "oxidation_states" : "6, 4, -2",
            "electronic_configuration" : "[Ar]3d4s4p",
            "lattice_structure" : "HEX",
            "lattice_constant ang" : 4.360
        },
        "Bromine": {
            "symbol" : "Br",
            "atomic_number" : 35,
            "atomic_weight" : 79.904,
            "density g/cm" : 3.12,
            "melting_point K" : 265.9,
            "boiling_point K" : 331.9,
            "atomic_radius pm" : "-",
            "covalent_radius pm" : 114,
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : 23.5,
            "specific_heat (@20C J/g mol)" : "0.473 (Br-Br)",
            "fusion_heat (kJ/mol)" : "10.57 (Br-Br)",
            "evaporation_heat (kJ/mol)" : "29.56 (Br-Br)",
            "thermal_conductivity (@25C W/m K) " : 0.005,
            "pauling_negativity" : 2.96,
            "first_ionizing kJ/mol" : 1142.0,
            "oxidation_states" : "7, 5, 3, 1, -1",
            "electronic_configuration" : "[Ar]3d4s4p",
            "lattice_structure" : "ORC",
            "lattice_constant ang" : 6.670
        },
        "Krypton": {
            "symbol" : "Kr",
            "atomic_number" : 36,
            "atomic_weight" : 83.8,
            "density g/cm" : "2.155 (@ -153C)",
            "melting_point K" : 116.6,
            "boiling_point K" : 120.85,
            "atomic_radius pm" : "-",
            "covalent_radius pm" : 112,
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : 32.2,
            "specific_heat (@20C J/g mol)" : 0.247,
            "fusion_heat (kJ/mol)" : "-",
            "evaporation_heat (kJ/mol)" : 9.05,
            "thermal_conductivity (@25C W/m K) " : 0.0095,
            "pauling_negativity" : 0.0,
            "first_ionizing kJ/mol" : 1350.0,
            "oxidation_states" : 2,
            "electronic_configuration" : "[Ar]3d4s4p",
            "lattice_structure" : "FCC",
            "lattice_constant ang" : 5.720
        },
        "Rubidium": {
            "symbol" : "Rb",
            "atomic_number" : 37,
            "atomic_weight" : 85.4678,
            "density g/cm" : 1.532,
            "melting_point K" : 312.2,
            "boiling_point K" : 961,
            "atomic_radius pm" : 248,
            "covalent_radius pm" : 216,
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : 55.9,
            "specific_heat (@20C J/g mol)" : 0.360,
            "fusion_heat (kJ/mol)" : 2.20,
            "evaporation_heat (kJ/mol)" : 75.8,
            "thermal_conductivity (@25C W/m K) " : 58.2,
            "pauling_negativity" : 0.82,
            "first_ionizing kJ/mol" : 402.8,
            "oxidation_states" : 1,
            "electronic_configuration" : "[Kr]5s",
            "lattice_structure" : "BCC",
            "lattice_constant ang" : 5.590
        },
        "Strontium": {
            "symbol" : "Sr",
            "atomic_number" : 38,
            "atomic_weight" : 87.62,
            "density g/cm" : 2.54,
            "melting_point K" : 1042,
            "boiling_point K" : 1657,
            "atomic_radius pm" : 215,
            "covalent_radius pm" : 191,
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : 33.7,
            "specific_heat (@20C J/g mol)" : 0.301,
            "fusion_heat (kJ/mol)" : 9.20,
            "evaporation_heat (kJ/mol)" : 144,
            "thermal_conductivity (@25C W/m K) " : "(35.4)",
            "pauling_negativity" : 0.95,
            "first_ionizing kJ/mol" : 549.0,
            "oxidation_states" : 2,
            "electronic_configuration" : "[Kr]5s",
            "lattice_structure" : "FCC",
            "lattice_constant ang" : 6.080
        },
        "Yttrium": {
            "symbol" : "Y",
            "atomic_number" : 39,
            "atomic_weight" : 88.90585,
            "density g/cm" : 4.47,
            "melting_point K" : 1795,
            "boiling_point K" : 3611,
            "atomic_radius pm" : 178,
            "covalent_radius pm" : 162,
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : 19.8,
            "specific_heat (@20C J/g mol)" : 0.284,
            "fusion_heat (kJ/mol)" : 11.5,
            "evaporation_heat (kJ/mol)" : 367,
            "thermal_conductivity (@25C W/m K) " : "(17.2)",
            "pauling_negativity" : 1.22,
            "first_ionizing kJ/mol" : 615.4,
            "oxidation_states" : 3,
            "electronic_configuration" : "[Kr]4d5s",
            "lattice_structure" : "HEX",
            "lattice_constant ang" : 3.650
        },
        "Zirconium": {
            "symbol" : "Zr",
            "atomic_number" : 40,
            "atomic_weight" : 91.224,
            "density g/cm" : 6.506,
            "melting_point K" : 2125,
            "boiling_point K" : 4650,
            "atomic_radius pm" : 160,
            "covalent_radius pm" : 145,
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : 14.1,
            "specific_heat (@20C J/g mol)" : 0.281,
            "fusion_heat (kJ/mol)" : 19.2,
            "evaporation_heat (kJ/mol)" : 567,
            "thermal_conductivity (@25C W/m K) " : 22.7,
            "pauling_negativity" : 1.33,
            "first_ionizing kJ/mol" : 659.7,
            "oxidation_states" : 4,
            "electronic_configuration" : "[Kr]4d5s",
            "lattice_structure" : "HEX",
            "lattice_constant ang" : 3.230
        },
        "Niobium": {
            "symbol" : "Nb",
            "atomic_number" : 41,
            "atomic_weight" : 92.90638,
            "density g/cm" : 8.57,
            "melting_point K" : 2741,
            "boiling_point K" : 5015,
            "atomic_radius pm" : 146,
            "covalent_radius pm" : 134,
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : 10.8,
            "specific_heat (@20C J/g mol)" : 0.268,
            "fusion_heat (kJ/mol)" : 26.8,
            "evaporation_heat (kJ/mol)" : 680,
            "thermal_conductivity (@25C W/m K) " : 53.7,
            "pauling_negativity" : 1.6,
            "first_ionizing kJ/mol" : 663.6,
            "oxidation_states" : "5, 3",
            "electronic_configuration" : "[Kr]4d5s",
            "lattice_structure" : "BCC",
            "lattice_constant ang" : 3.300
        },
        "Molybdenum": {
            "symbol" : "Mo",
            "atomic_number" : 42,
            "atomic_weight" : 95.94,
            "density g/cm" : 10.22,
            "melting_point K" : 2890,
            "boiling_point K" : 4885,
            "atomic_radius pm" : 139,
            "covalent_radius pm" : 130,
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : 9.4,
            "specific_heat (@20C J/g mol)" : 0.251,
            "fusion_heat (kJ/mol)" : 28,
            "evaporation_heat (kJ/mol)" : "~590",
            "thermal_conductivity (@25C W/m K) " : "(138)",
            "pauling_negativity" : 2.16,
            "first_ionizing kJ/mol" : 684.8,
            "oxidation_states" : "6, 5, 4, 3, 2, 0",
            "electronic_configuration" : "[Kr]4d5s",
            "lattice_structure" : "BCC",
            "lattice_constant ang" : 3.150
        },
        "Technetium": {
            "symbol" : "Tc",
            "atomic_number" : 43,
            "atomic_weight" : 97.9072,
            "density g/cm" : 11.5,
            "melting_point K" : 2445,
            "boiling_point K" : 5150,
            "atomic_radius pm" : 136,
            "covalent_radius pm" : 127,
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : 8.5,
            "specific_heat (@20C J/g mol)" : 0.243,
            "fusion_heat (kJ/mol)" : 23.8,
            "evaporation_heat (kJ/mol)" : 585,
            "thermal_conductivity (@25C W/m K) " : 50.6,
            "pauling_negativity" : 1.9,
            "first_ionizing kJ/mol" : 702.2,
            "oxidation_states" : 7,
            "electronic_configuration" : "[Kr]4d5s",
            "lattice_structure" : "HEX",
            "lattice_constant ang" : 2.740
        },
        "Ruthenium": {
            "symbol" : "Ru",
            "atomic_number" : 44,
            "atomic_weight" : 101.07,
            "density g/cm" : 12.41,
            "melting_point K" : 2583,
            "boiling_point K" : 4173,
            "atomic_radius pm" : 134,
            "covalent_radius pm" : 125,
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : 8.3,
            "specific_heat (@20C J/g mol)" : 0.238,
            "fusion_heat (kJ/mol)" : "(25.5)",
            "evaporation_heat (kJ/mol)" : "-",
            "thermal_conductivity (@25C W/m K) " : 117.0,
            "pauling_negativity" : 2.2,
            "first_ionizing kJ/mol" : 710.3,
            "oxidation_states" : "8, 6, 4, 3, 2, 0, -2",
            "electronic_configuration" : "[Kr]4d5s",
            "lattice_structure" : "HEX",
            "lattice_constant ang" : 2.700
        },
        "Rhodium": {
            "symbol" : "Rh",
            "atomic_number" : 45,
            "atomic_weight" : 102.9055,
            "density g/cm" : 12.41,
            "melting_point K" : 2239,
            "boiling_point K" : 4000,
            "atomic_radius pm" : 134,
            "covalent_radius pm" : 125,
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : 8.3,
            "specific_heat (@20C J/g mol)" : 0.244,
            "fusion_heat (kJ/mol)" : 21.8,
            "evaporation_heat (kJ/mol)" : 494,
            "thermal_conductivity (@25C W/m K) " : 150,
            "pauling_negativity" : 2.28,
            "first_ionizing kJ/mol" : 719.5,
            "oxidation_states" : "5, 4, 3, 2, 1, 0",
            "electronic_configuration" : "[Kr]4d5s",
            "lattice_structure" : "FCC",
            "lattice_constant ang" : 3.800
        },
        "Palladium": {
            "symbol" : "Pd",
            "atomic_number" : 46,
            "atomic_weight" : 106.42,
            "density g/cm" : 12.02,
            "melting_point K" : 1825,
            "boiling_point K" : 3413,
            "atomic_radius pm" : 137,
            "covalent_radius pm" : 128,
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : 8.9,
            "specific_heat (@20C J/g mol)" : 0.244,
            "fusion_heat (kJ/mol)" : 17.24,
            "evaporation_heat (kJ/mol)" : 372.4,
            "thermal_conductivity (@25C W/m K) " : 71.8,
            "pauling_negativity" : 2.20,
            "first_ionizing kJ/mol" : 803.5,
            "oxidation_states" : "4, 2, 0",
            "electronic_configuration" : "[Kr]4d5s",
            "lattice_structure" : "FCC",
            "lattice_constant ang" : 3.890
        },
        "Silver": {
            "symbol" : "Ag",
            "atomic_number" : 47,
            "atomic_weight" : 107.8682,
            "density g/cm" : 10.5,
            "melting_point K" : 1235.1,
            "boiling_point K" : 2485,
            "atomic_radius pm" : 144,
            "covalent_radius pm" : 134,
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : 10.3,
            "specific_heat (@20C J/g mol)" : 0.237,
            "fusion_heat (kJ/mol)" : 11.95,
            "evaporation_heat (kJ/mol)" : 254.1,
            "thermal_conductivity (@25C W/m K) " : 429,
            "pauling_negativity" : 1.93,
            "first_ionizing kJ/mol" : 730.5,
            "oxidation_states" : "2, 1",
            "electronic_configuration" : "[Kr]4d5s",
            "lattice_structure" : "FCC",
            "lattice_constant ang" : 4.090
        },
        "Cadmium": {
            "symbol" : "Cd",
            "atomic_number" : 48,
            "atomic_weight" : 112.411,
            "density g/cm" : 8.65,
            "melting_point K" : 594.1,
            "boiling_point K" : 1038,
            "atomic_radius pm" : 154,
            "covalent_radius pm" : 148,
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : 13.1,
            "specific_heat (@20C J/g mol)" : 0.232,
            "fusion_heat (kJ/mol)" : 6.11,
            "evaporation_heat (kJ/mol)" : 59.1,
            "thermal_conductivity (@25C W/m K) " : 96.9,
            "pauling_negativity" : 1.69,
            "first_ionizing kJ/mol" : 867.2,
            "oxidation_states" : 2,
            "electronic_configuration" : "[Kr]4d5s",
            "lattice_structure" : "HEX",
            "lattice_constant ang" : 2.980
        },
        "Indium": {
            "symbol" : "In",
            "atomic_number" : 49,
            "atomic_weight" : 114.818,
            "density g/cm" : 7.31,
            "melting_point K" : 429.32,
            "boiling_point K" : 2353,
            "atomic_radius pm" : 166,
            "covalent_radius pm" : 144,
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : 15.7,
            "specific_heat (@20C J/g mol)" : 0.234,
            "fusion_heat (kJ/mol)" : 3.24,
            "evaporation_heat (kJ/mol)" : 225.1,
            "thermal_conductivity (@25C W/m K) " : 81.8,
            "pauling_negativity" : 1.78,
            "first_ionizing kJ/mol" : 558.0,
            "oxidation_states" : 3,
            "electronic_configuration" : "[Kr]4d5s5p",
            "lattice_structure" : "TET",
            "lattice_constant ang" : 4.590
        },
        "Tin": {
            "symbol" : "Sn",
            "atomic_number" : 50,
            "atomic_weight" : 118.71,
            "density g/cm" : 7.31,
            "melting_point K" : 505.1,
            "boiling_point K" : 2543,
            "atomic_radius pm" : 162,
            "covalent_radius pm" : 141,
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : 16.3,
            "specific_heat (@20C J/g mol)" : 0.222,
            "fusion_heat (kJ/mol)" : 7.07,
            "evaporation_heat (kJ/mol)" : 296,
            "thermal_conductivity (@25C W/m K) " : 66.8,
            "pauling_negativity" : 1.96,
            "first_ionizing kJ/mol" : 708.2,
            "oxidation_states" : "4, 2",
            "electronic_configuration" : "[Kr]4d5s5p",
            "lattice_structure" : "TET",
            "lattice_constant ang" : 5.820
        },
        "Antimony": {
            "symbol" : "Sb",
            "atomic_number" : 51,
            "atomic_weight" : 121.760,
            "density g/cm" : 6.691,
            "melting_point K" : 903.9,
            "boiling_point K" : 1908,
            "atomic_radius pm" : 159,
            "covalent_radius pm" : 140,
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : 18.4,
            "specific_heat (@20C J/g mol)" : 0.205,
            "fusion_heat (kJ/mol)" : 20.08,
            "evaporation_heat (kJ/mol)" : 195.2,
            "thermal_conductivity (@25C W/m K) " : 24.43,
            "pauling_negativity" : 2.05,
            "first_ionizing kJ/mol" : 833.3,
            "oxidation_states" : "5, 3, -2",
            "electronic_configuration" : "[Kr]4d5s5p",
            "lattice_structure" : "RHL",
            "lattice_constant ang" : 4.510
        },
        "Tellurium": {
            "symbol" : "Te",
            "atomic_number" : 52,
            "atomic_weight" : 127.6,
            "density g/cm" : 6.24,
            "melting_point K" : 722.7,
            "boiling_point K" : 1263,
            "atomic_radius pm" : 160,
            "covalent_radius pm" : 136,
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : 20.5,
            "specific_heat (@20C J/g mol)" : 0.201,
            "fusion_heat (kJ/mol)" : 17.91,
            "evaporation_heat (kJ/mol)" : 49.8,
            "thermal_conductivity (@25C W/m K) " : 14.3,
            "pauling_negativity" : 2.1,
            "first_ionizing kJ/mol" : 869.0,
            "oxidation_states" : "6, 4, 2",
            "electronic_configuration" : "[Kr]4d5s5p",
            "lattice_structure" : "HEX",
            "lattice_constant ang" : 4.450
        },
        "Iodine": {
            "symbol" : "I",
            "atomic_number" : 53,
            "atomic_weight" : 126.90447,
            "density g/cm" : 4.93,
            "melting_point K" : 386.7,
            "boiling_point K" : 457.5,
            "atomic_radius pm" : "-",
            "covalent_radius pm" : 133,
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : 25.7,
            "specific_heat (@20C J/g mol)" : "0.427 (I-I)",
            "fusion_heat (kJ/mol)" : "15.52 (I-I)",
            "evaporation_heat (kJ/mol)" : "41.95 (I-I)",
            "thermal_conductivity (@25C W/m K) " : "(0.45)",
            "pauling_negativity" : 2.66,
            "first_ionizing kJ/mol" : 1008.3,
            "oxidation_states" : "7, 5, 1, -1",
            "electronic_configuration" : "[Kr]4d5s5p",
            "lattice_structure" : "ORC",
            "lattice_constant ang" : 7.720
        },
        "Xenon": {
            "symbol" : "Xe",
            "atomic_number" : 54,
            "atomic_weight" : 131.29,
            "density g/cm" : "3.52 (@ -109C)",
            "melting_point K" : 161.3,
            "boiling_point K" : 166.1,
            "atomic_radius pm" : "-",
            "covalent_radius pm" : 131,
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : 42.9,
            "specific_heat (@20C J/g mol)" : 0.158,
            "fusion_heat (kJ/mol)" : "-",
            "evaporation_heat (kJ/mol)" : 12.65,
            "thermal_conductivity (@25C W/m K) " : 0.0057,
            "pauling_negativity" : 0.0,
            "first_ionizing kJ/mol" : 1170.0,
            "oxidation_states" : 7,
            "electronic_configuration" : "[Kr]4d5s5p",
            "lattice_structure" : "FCC",
            "lattice_constant ang" : 6.200
        },
        "Cesium": {
            "symbol" : "Cs",
            "atomic_number" : 55,
            "atomic_weight" : 132.90543,
            "density g/cm" : 1.873,
            "melting_point K" : 301.6,
            "boiling_point K" : 951.6,
            "atomic_radius pm" : 267,
            "covalent_radius pm" : 235,
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : 70.0,
            "specific_heat (@20C J/g mol)" : 0.241,
            "fusion_heat (kJ/mol)" : 2.09,
            "evaporation_heat (kJ/mol)" : 68.3,
            "thermal_conductivity (@25C W/m K) " : 35.9,
            "pauling_negativity" : 0.79,
            "first_ionizing kJ/mol" : 375.5,
            "oxidation_states" : 1,
            "electronic_configuration" : "[Xe]6s",
            "lattice_structure" : "BCC",
            "lattice_constant ang" : 6.050
        },
        "Barium": {
            "symbol" : "Ba",
            "atomic_number" : 56,
            "atomic_weight" : 137.327,
            "density g/cm" : 3.5,
            "melting_point K" : 1002,
            "boiling_point K" : 1910,
            "atomic_radius pm" : 222,
            "covalent_radius pm" : 198,
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : 39.0,
            "specific_heat (@20C J/g mol)" : 0.192,
            "fusion_heat (kJ/mol)" : 7.66,
            "evaporation_heat (kJ/mol)" : 142.0,
            "thermal_conductivity (@25C W/m K) " : "(18.4)",
            "pauling_negativity" : 0.89,
            "first_ionizing kJ/mol" : 502.5,
            "oxidation_states" : 2,
            "electronic_configuration" : "[Xe]6s",
            "lattice_structure" : "BCC",
            "lattice_constant ang" : 5.020
        },
        "Lanthanum": {
            "symbol" : "La",
            "atomic_number" : 57,
            "atomic_weight" : 138.9055,
            "density g/cm" : 6.15,
            "melting_point K" : 1194,
            "boiling_point K" : 3730,
            "atomic_radius pm" : 187,
            "covalent_radius pm" : 169,
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : 22.5,
            "specific_heat (@20C J/g mol)" : 0.197,
            "fusion_heat (kJ/mol)" : 8.5,
            "evaporation_heat (kJ/mol)" : 402,
            "thermal_conductivity (@25C W/m K) " : 13.4,
            "pauling_negativity" : 1.10,
            "first_ionizing kJ/mol" : 541.1,
            "oxidation_states" : 3,
            "electronic_configuration" : "[Xe]6d6s",
            "lattice_structure" : "HEX",
            "lattice_constant ang" : 3.750
        },
        "Cerium": {
            "symbol" : "Ce",
            "atomic_number" : 58,
            "atomic_weight" : 140.115,
            "density g/cm" : 6.757,
            "melting_point K" : 1072,
            "boiling_point K" : 3699,
            "atomic_radius pm" : 181,
            "covalent_radius pm" : 165,
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : 21.0,
            "specific_heat (@20C J/g mol)" : 0.205,
            "fusion_heat (kJ/mol)" : 5.2,
            "evaporation_heat (kJ/mol)" : 398,
            "thermal_conductivity (@25C W/m K) " : 11.3,
            "pauling_negativity" : 1.12,
            "first_ionizing kJ/mol" : 540.1,
            "oxidation_states" : "4, 3",
            "electronic_configuration" : "[Xe]4f5d6s",
            "lattice_structure" : "FCC",
            "lattice_constant ang" : 5.160
        },
        "Praseodymium": {
            "symbol" : "Pr",
            "atomic_number" : 59,
            "atomic_weight" : 140.90765,
            "density g/cm" : 6.773,
            "melting_point K" : 1204,
            "boiling_point K" : 3785,
            "atomic_radius pm" : 182,
            "covalent_radius pm" : 165,
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : 20.8,
            "specific_heat (@20C J/g mol)" : 0.192,
            "fusion_heat (kJ/mol)" : 11.3,
            "evaporation_heat (kJ/mol)" : 331,
            "thermal_conductivity (@25C W/m K) " : 12.5,
            "pauling_negativity" : 1.13,
            "first_ionizing kJ/mol" : 526.6,
            "oxidation_states" : "4, 3",
            "electronic_configuration" : "[Xe]4f5d6s",
            "lattice_structure" : "HEX",
            "lattice_constant ang" : 3.670
        },
        "Neodymium": {
            "symbol" : "Nd",
            "atomic_number" : 60,
            "atomic_weight" : 144.24,
            "density g/cm" : 7.007,
            "melting_point K" : 1294,
            "boiling_point K" : 3341,
            "atomic_radius pm" : 182,
            "covalent_radius pm" : 184,
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : 20.6,
            "specific_heat (@20C J/g mol)" : 0.205,
            "fusion_heat (kJ/mol)" : 7.1,
            "evaporation_heat (kJ/mol)" : 289,
            "thermal_conductivity (@25C W/m K) " : "(16.5)",
            "pauling_negativity" : 1.14,
            "first_ionizing kJ/mol" : 531.5,
            "oxidation_states" : 3,
            "electronic_configuration" : "[Xe]4f5d6s",
            "lattice_structure" : "HEX",
            "lattice_constant ang" : 3.660
        },
        "Promethium": {
            "symbol" : "Pm",
            "atomic_number" : 61,
            "atomic_weight" : 144.9127,
            "density g/cm" : 7.2,
            "melting_point K" : 1441,
            "boiling_point K" : 3000,
            "atomic_radius pm" : "-",
            "covalent_radius pm" : 163,
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : "-",
            "specific_heat (@20C J/g mol)" : 0.185,
            "fusion_heat (kJ/mol)" : "-",
            "evaporation_heat (kJ/mol)" : "-",
            "thermal_conductivity (@25C W/m K) " : 17.9,
            "pauling_negativity" : 0.0,
            "first_ionizing kJ/mol" : 536,
            "oxidation_states" : 3,
            "electronic_configuration" : "[Xe]4f5d6s",
            "lattice_structure" : "n/a",
            "lattice_constant ang" : "n/a"
        },
        "Samarium": {
            "symbol" : "Sm",
            "atomic_number" : 62,
            "atomic_weight" : 150.36,
            "density g/cm" : 7.520,
            "melting_point K" : 1350,
            "boiling_point K" : 2064,
            "atomic_radius pm" : 181,
            "covalent_radius pm" : 162,
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : 19.9,
            "specific_heat (@20C J/g mol)" : 0.180,
            "fusion_heat (kJ/mol)" : 8.9,
            "evaporation_heat (kJ/mol)" : 165,
            "thermal_conductivity (@25C W/m K) " : "(13.3)",
            "pauling_negativity" : 1.17,
            "first_ionizing kJ/mol" : 540.1,
            "oxidation_states" : "3, 2",
            "electronic_configuration" : "[Xe]4f5d6s",
            "lattice_structure" : "RHL",
            "lattice_constant ang" : 9.000
        },
        "Europium": {
            "symbol" : "Eu",
            "atomic_number" : 63,
            "atomic_weight" : 151.965,
            "density g/cm" : 5.243,
            "melting_point K" : 1095,
            "boiling_point K" : 1870,
            "atomic_radius pm" : 199,
            "covalent_radius pm" : 185,
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : 28.9,
            "specific_heat (@20C J/g mol)" : 0.176,
            "fusion_heat (kJ/mol)" : "-",
            "evaporation_heat (kJ/mol)" : 176,
            "thermal_conductivity (@25C W/m K) " : 13.9,
            "pauling_negativity" : 0.0,
            "first_ionizing kJ/mol" : 546.9,
            "oxidation_states" : "3, 2",
            "electronic_configuration" : "[Xe]4f5d6s",
            "lattice_structure" : "BCC",
            "lattice_constant ang" : 4.610
        },
        "Gadolinium": {
            "symbol" : "Gd",
            "atomic_number" : 64,
            "atomic_weight" : 157.25,
            "density g/cm" : 7.900,
            "melting_point K" : 1586,
            "boiling_point K" : 3539,
            "atomic_radius pm" : 179,
            "covalent_radius pm" : 161,
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : 19.9,
            "specific_heat (@20C J/g mol)" : 0.230,
            "fusion_heat (kJ/mol)" : "-",
            "evaporation_heat (kJ/mol)" : 398,
            "thermal_conductivity (@25C W/m K) " : "(10.5)",
            "pauling_negativity" : 1.20,
            "first_ionizing kJ/mol" : 594.2,
            "oxidation_states" : 3,
            "electronic_configuration" : "[Xe]4f5d6s",
            "lattice_structure" : "HEX",
            "lattice_constant ang" : 3.640
        },
        "Terbium": {
            "symbol" : "Tb",
            "atomic_number" : 65,
            "atomic_weight" : 158.92534,
            "density g/cm" : 8.229,
            "melting_point K" : 1629,
            "boiling_point K" : 3296,
            "atomic_radius pm" : 180,
            "covalent_radius pm" : 159,
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : 19.2,
            "specific_heat (@20C J/g mol)" : 0.183,
            "fusion_heat (kJ/mol)" : "-",
            "evaporation_heat (kJ/mol)" : 389,
            "thermal_conductivity (@25C W/m K) " : 11.1,
            "pauling_negativity" : 1.2,
            "first_ionizing kJ/mol" : 569,
            "oxidation_states" : "4, 3",
            "electronic_configuration" : "[Xe]4f5d6s",
            "lattice_structure" : "HEX",
            "lattice_constant ang" : 3.600
        },
        "Dysprosium": {
            "symbol" : "Dy",
            "atomic_number" : 66,
            "atomic_weight" : 162.50,
            "density g/cm" : 8.55,
            "melting_point K" : 1685,
            "boiling_point K" : 2835,
            "atomic_radius pm" : 180,
            "covalent_radius pm" : 159,
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : 19.0,
            "specific_heat (@20C J/g mol)" : 0.173,
            "fusion_heat (kJ/mol)" : "-",
            "evaporation_heat (kJ/mol)" : 291,
            "thermal_conductivity (@25C W/m K) " : 10.7,
            "pauling_negativity" : "-",
            "first_ionizing kJ/mol" : 567,
            "oxidation_states" : 3,
            "electronic_configuration" : "[Xe]4f5d6s",
            "lattice_structure" : "HEX",
            "lattice_constant ang" : 3.590
        },
        "Holmium": {
            "symbol" : "Ho",
            "atomic_number" : 67,
            "atomic_weight" : 164.93032,
            "density g/cm" : 8.795,
            "melting_point K" : 1747,
            "boiling_point K" : 2968,
            "atomic_radius pm" : 179,
            "covalent_radius pm" : 158,
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : 18.7,
            "specific_heat (@20C J/g mol)" : 0.164,
            "fusion_heat (kJ/mol)" : "-",
            "evaporation_heat (kJ/mol)" : 301,
            "thermal_conductivity (@25C W/m K) " : "(16.2)",
            "pauling_negativity" : 1.23,
            "first_ionizing kJ/mol" : 574,
            "oxidation_states" : 3,
            "electronic_configuration" : "[Xe]4f5d6s",
            "lattice_structure" : "HEX",
            "lattice_constant ang" : 3.580
        },
        "Erbium": {
            "symbol" : "Er",
            "atomic_number" : 68,
            "atomic_weight" : 167.26,
            "density g/cm" : 9.06,
            "melting_point K" : 1802,
            "boiling_point K" : 3136,
            "atomic_radius pm" : 178,
            "covalent_radius pm" : 157,
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : 18.4,
            "specific_heat (@20C J/g mol)" : 0.168,
            "fusion_heat (kJ/mol)" : "-",
            "evaporation_heat (kJ/mol)" : 317,
            "thermal_conductivity (@25C W/m K) " : "(14.5)",
            "pauling_negativity" : 1.24,
            "first_ionizing kJ/mol" : 581,
            "oxidation_states" : 3,
            "electronic_configuration" : "[Xe]4f5d6s",
            "lattice_structure" : "HEX",
            "lattice_constant ang" : 3.560
        },
        "Thulium": {
            "symbol" : "Tm",
            "atomic_number" : 69,
            "atomic_weight" : 168.93421,
            "density g/cm" : 9.321,
            "melting_point K" : 1818,
            "boiling_point K" : 2220,
            "atomic_radius pm" : 177,
            "covalent_radius pm" : 156,
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : 18.1,
            "specific_heat (@20C J/g mol)" : 0.160,
            "fusion_heat (kJ/mol)" : "-",
            "evaporation_heat (kJ/mol)" : 232,
            "thermal_conductivity (@25C W/m K) " : "(16.9)",
            "pauling_negativity" : 1.25,
            "first_ionizing kJ/mol" : 589,
            "oxidation_states" : "3, 2",
            "electronic_configuration" : "[Xe]4f5d6s",
            "lattice_structure" : "HEX",
            "lattice_constant ang" : 3.540
        },
        "Ytterbium": {
            "symbol" : "Yb",
            "atomic_number" : 70,
            "atomic_weight" : 173.04,
            "density g/cm" : 6.9654,
            "melting_point K" : 1097,
            "boiling_point K" : 1466,
            "atomic_radius pm" : 194,
            "covalent_radius pm" : "-",
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : 24.8,
            "specific_heat (@20C J/g mol)" : 0.145,
            "fusion_heat (kJ/mol)" : 3.35,
            "evaporation_heat (kJ/mol)" : 159,
            "thermal_conductivity (@25C W/m K) " : "(34.9)",
            "pauling_negativity" : 1.1,
            "first_ionizing kJ/mol" : 603,
            "oxidation_states" : "3, 2",
            "electronic_configuration" : "[Xe]4f5d6s",
            "lattice_structure" : "FCC",
            "lattice_constant ang" : 5.490
        },
        "Lutetium": {
            "symbol" : "Lu",
            "atomic_number" : 71,
            "atomic_weight" : 174.967,
            "density g/cm" : 9.8404,
            "melting_point K" : 1936,
            "boiling_point K" : 3668,
            "atomic_radius pm" : 175,
            "covalent_radius pm" : 156,
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : 17.8,
            "specific_heat (@20C J/g mol)" : 0.155,
            "fusion_heat (kJ/mol)" : "-",
            "evaporation_heat (kJ/mol)" : 414,
            "thermal_conductivity (@25C W/m K) " : "(16.4)",
            "pauling_negativity" : 1.27,
            "first_ionizing kJ/mol" : 513,
            "oxidation_states" : 3,
            "electronic_configuration" : "[Xe]4f5d6s",
            "lattice_structure" : "HEX",
            "lattice_constant ang" : 3.510
        },
        "Hafnium": {
            "symbol" : "Hf",
            "atomic_number" : 72,
            "atomic_weight" : 178.49,
            "density g/cm" : 13.31,
            "melting_point K" : 2503,
            "boiling_point K" : 5470,
            "atomic_radius pm" : 167,
            "covalent_radius pm" : 144,
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : 13.6,
            "specific_heat (@20C J/g mol)" : 0.146,
            "fusion_heat (kJ/mol)" : "(25.1)",
            "evaporation_heat (kJ/mol)" : 575,
            "thermal_conductivity (@25C W/m K) " : 23.0,
            "pauling_negativity" : 1.3,
            "first_ionizing kJ/mol" : 575.2,
            "oxidation_states" : 4,
            "electronic_configuration" : "[Xe]4f5d6s",
            "lattice_structure" : "HEX",
            "lattice_constant ang" : 3.200
        },
        "Tantalum": {
            "symbol" : "Ta",
            "atomic_number" : 73,
            "atomic_weight" : 180.9479,
            "density g/cm" : 16.654,
            "melting_point K" : 3269,
            "boiling_point K" : 5698,
            "atomic_radius pm" : 149,
            "covalent_radius pm" : 134,
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : 10.9,
            "specific_heat (@20C J/g mol)" : 0.140,
            "fusion_heat (kJ/mol)" : 24.7,
            "evaporation_heat (kJ/mol)" : 758,
            "thermal_conductivity (@25C W/m K) " : 57.5,
            "pauling_negativity" : 1.5,
            "first_ionizing kJ/mol" : 760.1,
            "oxidation_states" : 5,
            "electronic_configuration" : "[Xe]4f5d6s",
            "lattice_structure" : "BCC",
            "lattice_constant ang" : 3.310
        },
        "Tungsten": {
            "symbol" : "W",
            "atomic_number" : 74,
            "atomic_weight" : 183.84,
            "density g/cm" : 19.3,
            "melting_point K" : 3680,
            "boiling_point K" : 5930,
            "atomic_radius pm" : 141,
            "covalent_radius pm" : 130,
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : 9.53,
            "specific_heat (@20C J/g mol)" : 0.133,
            "fusion_heat (kJ/mol)" : "(35)",
            "evaporation_heat (kJ/mol)" : 824,
            "thermal_conductivity (@25C W/m K) " : 173,
            "pauling_negativity" : 1.7,
            "first_ionizing kJ/mol" : 769.7,
            "oxidation_states" : "6, 5, 4, 3, 2, 0",
            "electronic_configuration" : "[Xe]4f5d6s",
            "lattice_structure" : "BCC",
            "lattice_constant ang" : 3.160
        },
        "Rhenium": {
            "symbol" : "Re",
            "atomic_number" : 75,
            "atomic_weight" : 186.207,
            "density g/cm" : 21.02,
            "melting_point K" : 3453,
            "boiling_point K" : 5900,
            "atomic_radius pm" : 137,
            "covalent_radius pm" : 128,
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : 8.85,
            "specific_heat (@20C J/g mol)" : 0.138,
            "fusion_heat (kJ/mol)" : 34,
            "evaporation_heat (kJ/mol)" : 704,
            "thermal_conductivity (@25C W/m K) " : 48.0,
            "pauling_negativity" : 1.9,
            "first_ionizing kJ/mol" : 759.1,
            "oxidation_states" : "5, 4, 3, 2, -1",
            "electronic_configuration" : "[Xe]4f5d6s",
            "lattice_structure" : "HEX",
            "lattice_constant ang" : 2.760
        },
        "Osmium": {
            "symbol" : "Os",
            "atomic_number" : 76,
            "atomic_weight" : 190.23,
            "density g/cm" : 22.57,
            "melting_point K" : 3327,
            "boiling_point K" : 5300,
            "atomic_radius pm" : 135,
            "covalent_radius pm" : 126,
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : 8.43,
            "specific_heat (@20C J/g mol)" : 0.131,
            "fusion_heat (kJ/mol)" : 31.7,
            "evaporation_heat (kJ/mol)" : 738,
            "thermal_conductivity (@25C W/m K) " : "(87.6)",
            "pauling_negativity" : 2.2,
            "first_ionizing kJ/mol" : 819.8,
            "oxidation_states" : "8, 6, 4, 3, 2, 0, -2",
            "electronic_configuration" : "[Xe]4f5d6s",
            "lattice_structure" : "HEX",
            "lattice_constant ang" : 2.740
        },
        "Iridium": {
            "symbol" : "Ir",
            "atomic_number" : 77,
            "atomic_weight" : 192.22,
            "density g/cm" : 22.42,
            "melting_point K" : 2683,
            "boiling_point K" : 4403,
            "atomic_radius pm" : 136,
            "covalent_radius pm" : 127,
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : 8.54,
            "specific_heat (@20C J/g mol)" : 0.133,
            "fusion_heat (kJ/mol)" : 27.61,
            "evaporation_heat (kJ/mol)" : 604,
            "thermal_conductivity (@25C W/m K) " : 147,
            "pauling_negativity" : 2.20,
            "first_ionizing kJ/mol" : 868.1,
            "oxidation_states" : "6, 4, 3, 2, 1, 0, -1",
            "electronic_configuration" : "[Xe]4f5d6s",
            "lattice_structure" : "FCC",
            "lattice_constant ang" : 3.840
        },
        "Platinum": {
            "symbol" : "Pt",
            "atomic_number" : 78,
            "atomic_weight" : 195.08,
            "density g/cm" : 21.45,
            "melting_point K" : 2045,
            "boiling_point K" : 4100,
            "atomic_radius pm" : 139,
            "covalent_radius pm" : 130,
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : 9.10,
            "specific_heat (@20C J/g mol)" : 0.133,
            "fusion_heat (kJ/mol)" : 21.76,
            "evaporation_heat (kJ/mol)" : "~470",
            "thermal_conductivity (@25C W/m K) " : 71.6,
            "pauling_negativity" : 2.28,
            "first_ionizing kJ/mol" : 868.1,
            "oxidation_states" : "4, 2, 0",
            "electronic_configuration" : "[Xe]4f5d6s",
            "lattice_structure" : "FCC",
            "lattice_constant ang" : 3.920
        },
        "Gold": {
            "symbol" : "Au",
            "atomic_number" : 79,
            "atomic_weight" : 196.96654,
            "density g/cm" : 19.3,
            "melting_point K" : 1337.58,
            "boiling_point K" : 3080,
            "atomic_radius pm" : 146,
            "covalent_radius pm" : 134,
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : 10.2,
            "specific_heat (@20C J/g mol)" : 0.129,
            "fusion_heat (kJ/mol)" : 12.68,
            "evaporation_heat (kJ/mol)" : "~340",
            "thermal_conductivity (@25C W/m K) " : 318,
            "pauling_negativity" : 2.54,
            "first_ionizing kJ/mol" : 889.3,
            "oxidation_states" : "3, 1",
            "electronic_configuration" : "[Xe]4f5d6s",
            "lattice_structure" : "FCC",
            "lattice_constant ang" : 4.080
        },
        "Mercury": {
            "symbol" : "Hg",
            "atomic_number" : 80,
            "atomic_weight" : 200.59,
            "density g/cm" : "13.546 (@ +20C)",
            "melting_point K" : 234.28,
            "boiling_point K" : 629.73,
            "atomic_radius pm" : 157,
            "covalent_radius pm" : 149,
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : 14.8,
            "specific_heat (@20C J/g mol)" : 0.138,
            "fusion_heat (kJ/mol)" : 2.295,
            "evaporation_heat (kJ/mol)" : 58.5,
            "thermal_conductivity (@25C W/m K) " : 8.3,
            "pauling_negativity" : 2.00,
            "first_ionizing kJ/mol" : 1006.0,
            "oxidation_states" : "2, 1",
            "electronic_configuration" : "[Xe]4f5d6s",
            "lattice_structure" : "RHL",
            "lattice_constant ang" : 2.990
        },
        "Thallium": {
            "symbol" : "Tl",
            "atomic_number" : 81,
            "atomic_weight" : 204.3833,
            "density g/cm" : 11.85,
            "melting_point K" : 576.6,
            "boiling_point K" : 1730,
            "atomic_radius pm" : 171,
            "covalent_radius pm" : 148,
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : 17.2,
            "specific_heat (@20C J/g mol)" : 0.128,
            "fusion_heat (kJ/mol)" : 4.31,
            "evaporation_heat (kJ/mol)" : 162.4,
            "thermal_conductivity (@25C W/m K) " : 46.1,
            "pauling_negativity" : 1.62,
            "first_ionizing kJ/mol" : 588.9,
            "oxidation_states" : "3, 1",
            "electronic_configuration" : "[Xe]4f5d6s6p",
            "lattice_structure" : "HEX",
            "lattice_constant ang" : 3.460
        },
        "Lead": {
            "symbol" : "Pb",
            "atomic_number" : 82,
            "atomic_weight" : 207.2,
            "density g/cm" : 11.35,
            "melting_point K" : 600.65,
            "boiling_point K" : 2013,
            "atomic_radius pm" : 175,
            "covalent_radius pm" : 147,
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : 18.3,
            "specific_heat (@20C J/g mol)" : 0.159,
            "fusion_heat (kJ/mol)" : 4.77,
            "evaporation_heat (kJ/mol)" : 177.8,
            "thermal_conductivity (@25C W/m K) " : 35.3,
            "pauling_negativity" : 1.8,
            "first_ionizing kJ/mol" : 715.2,
            "oxidation_states" : "4, 2",
            "electronic_configuration" : "[Xe]4f5d6s6p",
            "lattice_structure" : "FCC",
            "lattice_constant ang" : 4.950
        },
        "Bismuth": {
            "symbol" : "Bi",
            "atomic_number" : 83,
            "atomic_weight" : 208.98037,
            "density g/cm" : 9.747,
            "melting_point K" : 544.5,
            "boiling_point K" : 1883,
            "atomic_radius pm" : 170,
            "covalent_radius pm" : 146,
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : 21.3,
            "specific_heat (@20C J/g mol)" : 0.124,
            "fusion_heat (kJ/mol)" : 11.00,
            "evaporation_heat (kJ/mol)" : 172.0,
            "thermal_conductivity (@25C W/m K) " : 7.9,
            "pauling_negativity" : 2.02,
            "first_ionizing kJ/mol" : 702.9,
            "oxidation_states" : "5, 3",
            "electronic_configuration" : "[Xe]4f5d6s6p",
            "lattice_structure" : "RHL",
            "lattice_constant ang" : 4.750
        },
        "Polonium": {
            "symbol" : "Po",
            "atomic_number" : 84,
            "atomic_weight" : 208.9824,
            "density g/cm" : 9.32,
            "melting_point K" : 527,
            "boiling_point K" : 1235,
            "atomic_radius pm" : 176,
            "covalent_radius pm" : 146,
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : 22.7,
            "specific_heat (@20C J/g mol)" : 0.125,
            "fusion_heat (kJ/mol)" : "(10)",
            "evaporation_heat (kJ/mol)" : "(102.9)",
            "thermal_conductivity (@25C W/m K) " : "-",
            "pauling_negativity" : 2.0,
            "first_ionizing kJ/mol" : 813.1,
            "oxidation_states" : "6, 4, 2",
            "electronic_configuration" : "[Xe]4f5d6s6p",
            "lattice_structure" : "SC",
            "lattice_constant ang" : 3.350
        },
        "Astatine": {
            "symbol" : "At",
            "atomic_number" : 85,
            "atomic_weight" : 209.9871,
            "density g/cm" : "n/a",
            "melting_point K" : 575,
            "boiling_point K" : 610,
            "atomic_radius pm" : "-",
            "covalent_radius pm" : "(145)",
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : "-",
            "specific_heat (@20C J/g mol)" : "-",
            "fusion_heat (kJ/mol)" : "-",
            "evaporation_heat (kJ/mol)" : "-",
            "thermal_conductivity (@25C W/m K) " : "-",
            "pauling_negativity" : 2.2,
            "first_ionizing kJ/mol" : 916.3,
            "oxidation_states" : "7, 5, 3, 1, -1",
            "electronic_configuration" : "[Xe]4f5d6s6p",
            "lattice_structure" : "n/a",
            "lattice_constant ang" : "n/a"
        },
        "Radon": {
            "symbol" : "Rn",
            "atomic_number" : 86,
            "atomic_weight" : 222.0176,
            "density g/cm" : "4.4 (@ -62C)",
            "melting_point K" : 202,
            "boiling_point K" : 211.4,
            "atomic_radius pm" : "-",
            "covalent_radius pm" : "-",
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : "-",
            "specific_heat (@20C J/g mol)" : 0.094,
            "fusion_heat (kJ/mol)" : "-",
            "evaporation_heat (kJ/mol)" : 18.1,
            "thermal_conductivity (@25C W/m K) " : 0.0036,
            "pauling_negativity" : "-",
            "first_ionizing kJ/mol" : 1036.5,
            "oxidation_states" : "-",
            "electronic_configuration" : "[Xe]4f5d6s6p",
            "lattice_structure" : "FCC",
            "lattice_constant ang" : "n/a"
        },
        "Francium": {
            "symbol" : "Fr",
            "atomic_number" : 87,
            "atomic_weight" : 223.0197,
            "density g/cm" : "n/a",
            "melting_point K" : 300,
            "boiling_point K" : 950,
            "atomic_radius pm" : "-",
            "covalent_radius pm" : "-",
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : "-",
            "specific_heat (@20C J/g mol)" : "-",
            "fusion_heat (kJ/mol)" : 15,
            "evaporation_heat (kJ/mol)" : "-",
            "thermal_conductivity (@25C W/m K) " : "-",
            "pauling_negativity" : 0.7,
            "first_ionizing kJ/mol" : "~375",
            "oxidation_states" : 2,
            "electronic_configuration" : "[Rn]7s",
            "lattice_structure" : "BCC",
            "lattice_constant ang" : "n/a"
        },
        "Radium": {
            "symbol" : "Ra",
            "atomic_number" : 88,
            "atomic_weight" : 226.0254,
            "density g/cm" : "(5.5)",
            "melting_point K" : 973,
            "boiling_point K" : 1413,
            "atomic_radius pm" : "-",
            "covalent_radius pm" : "-",
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : 45.0,
            "specific_heat (@20C J/g mol)" : 0.120,
            "fusion_heat (kJ/mol)" : "(9.6)",
            "evaporation_heat (kJ/mol)" : "(113)",
            "thermal_conductivity (@25C W/m K) " : "(18.6)",
            "pauling_negativity" : 0.9,
            "first_ionizing kJ/mol" : 509.0,
            "oxidation_states" : 2,
            "electronic_configuration" : "[Rn]7s",
            "lattice_structure" : "n/a",
            "lattice_constant ang" : "n/a"
        },
        "Actinium": {
            "symbol" : "Ac",
            "atomic_number" : 89,
            "atomic_weight" : 227.0278,
            "density g/cm" : "n/a",
            "melting_point K" : 1320,
            "boiling_point K" : 3470,
            "atomic_radius pm" : 188,
            "covalent_radius pm" : "-",
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : 22.54,
            "specific_heat (@20C J/g mol)" : "-",
            "fusion_heat (kJ/mol)" : "(10.5)",
            "evaporation_heat (kJ/mol)" : "(292.9)",
            "thermal_conductivity (@25C W/m K) " : "-",
            "pauling_negativity" : 1.1,
            "first_ionizing kJ/mol" : 665.5,
            "oxidation_states" : 3,
            "electronic_configuration" : "[Rn]6d7s",
            "lattice_structure" : "FCC",
            "lattice_constant ang" : 5.310
        },
        "Thorium": {
            "symbol" : "Th",
            "atomic_number" : 90,
            "atomic_weight" : 232.0381,
            "density g/cm" : 11.78,
            "melting_point K" : 2028,
            "boiling_point K" : 5060,
            "atomic_radius pm" : 180,
            "covalent_radius pm" : 165,
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : 19.8,
            "specific_heat (@20C J/g mol)" : 0.113,
            "fusion_heat (kJ/mol)" : 16.11,
            "evaporation_heat (kJ/mol)" : 513.7,
            "thermal_conductivity (@25C W/m K) " : "(54.0)",
            "pauling_negativity" : 1.3,
            "first_ionizing kJ/mol" : 670.4,
            "oxidation_states" : 4,
            "electronic_configuration" : "[Rn]5f6d7s",
            "lattice_structure" : "FCC",
            "lattice_constant ang" : 5.080
        },
        "Protactinium": {
            "symbol" : "Pa",
            "atomic_number" : 91,
            "atomic_weight" : 231.03588,
            "density g/cm" : 15.37,
            "melting_point K" : 2113,
            "boiling_point K" : 4300,
            "atomic_radius pm" : 161,
            "covalent_radius pm" : "-",
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : 15.0,
            "specific_heat (@20C J/g mol)" : 0.121,
            "fusion_heat (kJ/mol)" : 16.7,
            "evaporation_heat (kJ/mol)" : 481.2,
            "thermal_conductivity (@25C W/m K) " : "-",
            "pauling_negativity" : 1.5,
            "first_ionizing kJ/mol" : "n/a",
            "oxidation_states" : "5, 4",
            "electronic_configuration" : "[Rn]5f6d7s",
            "lattice_structure" : "TET",
            "lattice_constant ang" : 3.920
        },
        "Uranium": {
            "symbol" : "U",
            "atomic_number" : 92,
            "atomic_weight" : 238.0289,
            "density g/cm" : 19.05,
            "melting_point K" : 1405.5,
            "boiling_point K" : 4018,
            "atomic_radius pm" : 138,
            "covalent_radius pm" : 142,
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : 12.5,
            "specific_heat (@20C J/g mol)" : 0.115,
            "fusion_heat (kJ/mol)" : 12.6,
            "evaporation_heat (kJ/mol)" : 417,
            "thermal_conductivity (@25C W/m K) " : 27.5,
            "pauling_negativity" : 1.38,
            "first_ionizing kJ/mol" : 686.4,
            "oxidation_states" : "6, 5, 4, 3",
            "electronic_configuration" : "[Rn]5f6d7s",
            "lattice_structure" : "ORC",
            "lattice_constant ang" : 2.850
        },
        "Neptunium": {
            "symbol" : "Np",
            "atomic_number" : 93,
            "atomic_weight" : 237.048,
            "density g/cm" : 20.25,
            "melting_point K" : 913,
            "boiling_point K" : 4175,
            "atomic_radius pm" : 130,
            "covalent_radius pm" : "-",
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : 21.1,
            "specific_heat (@20C J/g mol)" : "-",
            "fusion_heat (kJ/mol)" : "(9.6)",
            "evaporation_heat (kJ/mol)" : 336,
            "thermal_conductivity (@25C W/m K) " : "(6.3)",
            "pauling_negativity" : 1.36,
            "first_ionizing kJ/mol" : "n/a",
            "oxidation_states" : "6, 5, 4, 3",
            "electronic_configuration" : "[Rn]5f6d7s",
            "lattice_structure" : "ORC",
            "lattice_constant ang" : 4.720
        },
        "Plutonium": {
            "symbol" : "Pu",
            "atomic_number" : 94,
            "atomic_weight" : 244.0642,
            "density g/cm" : 19.84,
            "melting_point K" : 914,
            "boiling_point K" : 3505,
            "atomic_radius pm" : 151,
            "covalent_radius pm" : "-",
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : "-",
            "specific_heat (@20C J/g mol)" : "-",
            "fusion_heat (kJ/mol)" : 2.8,
            "evaporation_heat (kJ/mol)" : 343.5,
            "thermal_conductivity (@25C W/m K) " : "(6.7)",
            "pauling_negativity" : 1.28,
            "first_ionizing kJ/mol" : 491.9,
            "oxidation_states" : "6, 5, 4, 3",
            "electronic_configuration" : "[Rn]5f6d7s",
            "lattice_structure" : "MCL",
            "lattice_constant ang" : "n/a"
        },
        "Americium": {
            "symbol" : "Am",
            "atomic_number" : 95,
            "atomic_weight" : 243.0614,
            "density g/cm" : 13.67,
            "melting_point K" : 1267,
            "boiling_point K" : 2880,
            "atomic_radius pm" : 173,
            "covalent_radius pm" : "-",
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : 20.8,
            "specific_heat (@20C J/g mol)" : "-",
            "fusion_heat (kJ/mol)" : "(10.0)",
            "evaporation_heat (kJ/mol)" : 238.5,
            "thermal_conductivity (@25C W/m K) " : "-",
            "pauling_negativity" : 1.3,
            "first_ionizing kJ/mol" : "n/a",
            "oxidation_states" : "6, 5, 4, 3",
            "electronic_configuration" : "[Rn]5f6d7s",
            "lattice_structure" : "n/a",
            "lattice_constant ang" : "n/a"
        },
        "Curium": {
            "symbol" : "Cm",
            "atomic_number" : 96,
            "atomic_weight" : 247.0703,
            "density g/cm" : 13.51,
            "melting_point K" : 1340,
            "boiling_point K" : "n/a",
            "atomic_radius pm" : 299,
            "covalent_radius pm" : "n/a",
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : 18.28,
            "specific_heat (@20C J/g mol)" : "n/a",
            "fusion_heat (kJ/mol)" : "n/a",
            "evaporation_heat (kJ/mol)" : "n/a",
            "thermal_conductivity (@25C W/m K) " : "n/a",
            "pauling_negativity" : 1.3,
            "first_ionizing kJ/mol" : "(580)",
            "oxidation_states" : "4, 3",
            "electronic_configuration" : "[Rn]5f6d7s",
            "lattice_structure" : "n/a",
            "lattice_constant ang" : "n/A"
        },
        "Berkelium": {
            "symbol" : "Bk",
            "atomic_number" : 97,
            "atomic_weight" : 247.0703,
            "density g/cm" : 13.25,
            "melting_point K" : "n/a",
            "boiling_point K" : "n/a",
            "atomic_radius pm" : 297,
            "covalent_radius pm" : "n/a",
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : "n/a",
            "specific_heat (@20C J/g mol)" : "n/a",
            "fusion_heat (kJ/mol)" : "n/a",
            "evaporation_heat (kJ/mol)" : "n/a",
            "thermal_conductivity (@25C W/m K) " : "n/a",
            "pauling_negativity" : 1.3,
            "first_ionizing kJ/mol" : "(600)",
            "oxidation_states" : "4, 3",
            "electronic_configuration" : "[Rn]5f6d7s",
            "lattice_structure" : "n/a",
            "lattice_constant ang" : "n/a"
        },
        "Californium": {
            "symbol" : "Cf",
            "atomic_number" : 98,
            "atomic_weight" : 251.0796,
            "density g/cm" : 15.1,
            "melting_point K" : 900,
            "boiling_point K" : "n/a",
            "atomic_radius pm" : 295,
            "covalent_radius pm" : "n/a",
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : "n/a",
            "specific_heat (@20C J/g mol)" : "n/a",
            "fusion_heat (kJ/mol)" : "n/a",
            "evaporation_heat (kJ/mol)" : "n/a",
            "thermal_conductivity (@25C W/m K) " : "n/a",
            "pauling_negativity" : 1.3,
            "first_ionizing kJ/mol" : "(610)",
            "oxidation_states" : "4, 3",
            "electronic_configuration" : "[Rn]5f6d7s",
            "lattice_structure" : "n/a",
            "lattice_constant ang" : "n/a"
        },
        "Einsteinium": {
            "symbol" : "Es",
            "atomic_number" : 99,
            "atomic_weight" : 252.083,
            "density g/cm" : "n/a",
            "melting_point K" : "n/a",
            "boiling_point K" : 1130,
            "atomic_radius pm" : 292,
            "covalent_radius pm" : "n/a",
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : "n/a",
            "specific_heat (@20C J/g mol)" : "n/a",
            "fusion_heat (kJ/mol)" : "n/a",
            "evaporation_heat (kJ/mol)" : "n/a",
            "thermal_conductivity (@25C W/m K) " : "n/a",
            "pauling_negativity" : 1.3,
            "first_ionizing kJ/mol" : "(620)",
            "oxidation_states" : 3,
            "electronic_configuration" : "[Rn]5f6d7s",
            "lattice_structure" : "n/a",
            "lattice_constant ang" : "n/a"
        },
        "Fermium": {
            "symbol" : "Fm",
            "atomic_number" : 100,
            "atomic_weight" : 257.0951,
            "density g/cm" : "n/a",
            "melting_point K" : 1800,
            "boiling_point K" : "n/a",
            "atomic_radius pm" : 290,
            "covalent_radius pm" : "n/a",
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : "n/a",
            "specific_heat (@20C J/g mol)" : "n/a",
            "fusion_heat (kJ/mol)" : "n/a",
            "evaporation_heat (kJ/mol)" : "n/a",
            "thermal_conductivity (@25C W/m K) " : "n/a",
            "pauling_negativity" : 1.3,
            "first_ionizing kJ/mol" : "(630)",
            "oxidation_states" : 3,
            "electronic_configuration" : "[Rn]5f6d7s",
            "lattice_structure" : "n/a",
            "lattice_constant ang" : "n/a"
        },
        "Mendelevium": {
            "symbol" : "Md",
            "atomic_number" : 101,
            "atomic_weight" : 258.1,
            "density g/cm" : "n/a",
            "melting_point K" : 1100,
            "boiling_point K" : "n/a",
            "atomic_radius pm" : 287,
            "covalent_radius pm" : "n/a",
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : "n/a",
            "specific_heat (@20C J/g mol)" : "n/a",
            "fusion_heat (kJ/mol)" : "n/a",
            "evaporation_heat (kJ/mol)" : "n/a",
            "thermal_conductivity (@25C W/m K) " : "n/a",
            "pauling_negativity" : 1.3,
            "first_ionizing kJ/mol" : "(635)",
            "oxidation_states" : 3,
            "electronic_configuration" : "[Rn]5f6d7s",
            "lattice_structure" : "n/a",
            "lattice_constant ang" : "n/a"
        },
        "Nobelium": {
            "symbol" : "No",
            "atomic_number" : 102,
            "atomic_weight" : 259.1009,
            "density g/cm" : "n/a",
            "melting_point K" : 1100,
            "boiling_point K" : "n/a",
            "atomic_radius pm" : 285,
            "covalent_radius pm" : "n/a",
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : "n/a",
            "specific_heat (@20C J/g mol)" : "n/a",
            "fusion_heat (kJ/mol)" : "n/a",
            "evaporation_heat (kJ/mol)" : "n/a",
            "thermal_conductivity (@25C W/m K) " : "n/a",
            "pauling_negativity" : 1.3,
            "first_ionizing kJ/mol" : "(640)",
            "oxidation_states" : "3,2",
            "electronic_configuration" : "[Rn]5f6d7s",
            "lattice_structure" : "n/a",
            "lattice_constant ang" : "n/a"
        },
        "Lawrencium": {
            "symbol" : "Lr",
            "atomic_number" : 103,
            "atomic_weight" : 262.11,
            "density g/cm" : "n/a",
            "melting_point K" : "n/a",
            "boiling_point K" : "n/a",
            "atomic_radius pm" : 282,
            "covalent_radius pm" : "n/a",
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : "n/a",
            "specific_heat (@20C J/g mol)" : "n/a",
            "fusion_heat (kJ/mol)" : "n/a",
            "evaporation_heat (kJ/mol)" : "n/a",
            "thermal_conductivity (@25C W/m K) " : "n/a",
            "pauling_negativity" : "n/a",
            "first_ionizing kJ/mol" : "n/a",
            "oxidation_states" : 3,
            "electronic_configuration" : "[Rn]5f6d7s",
            "lattice_structure" : "n/a",
            "lattice_constant ang" : "n/a"
        },
        "Rutherfordium": {
            "symbol" : "Rf",
            "atomic_number" : 104,
            "atomic_weight" : "[261]",
            "density g/cm" : "n/a",
            "melting_point K" : "n/a",
            "boiling_point K" : "n/a",
            "atomic_radius pm" : "n/a",
            "covalent_radius pm" : "n/a",
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : "n/a",
            "specific_heat (@20C J/g mol)" : "n/a",
            "fusion_heat (kJ/mol)" : "n/a",
            "evaporation_heat (kJ/mol)" : "n/a",
            "thermal_conductivity (@25C W/m K) " : "n/a",
            "pauling_negativity" : "n/a",
            "first_ionizing kJ/mol" : "n/a",
            "oxidation_states" : "-",
            "electronic_configuration" : "[Rn]5f6d7s",
            "lattice_structure" : "n/a",
            "lattice_constant ang" : "n/a"
        },
        "Dubnium": {
            "symbol" : "Db",
            "atomic_number" : 105,
            "atomic_weight" : "[262]",
            "density g/cm" : "n/a",
            "melting_point K" : "n/a",
            "boiling_point K" : "n/a",
            "atomic_radius pm" : "n/a",
            "covalent_radius pm" : "n/a",
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : "n/a",
            "specific_heat (@20C J/g mol)" : "n/a",
            "fusion_heat (kJ/mol)" : "n/a",
            "evaporation_heat (kJ/mol)" : "n/a",
            "thermal_conductivity (@25C W/m K) " : "n/a",
            "pauling_negativity" : "n/a",
            "first_ionizing kJ/mol" : "n/a",
            "oxidation_states" : "-",
            "electronic_configuration" : "[Rn]5f6d6s",
            "lattice_structure" : "n/a",
            "lattice_constant ang" : "n/a"
        },
        "Seaborgium": {
            "symbol" : "Sg",
            "atomic_number" : 106,
            "atomic_weight" : "[266]",
            "density g/cm" : "n/a",
            "melting_point K" : "n/a",
            "boiling_point K" : "n/a",
            "atomic_radius pm" : "n/a",
            "covalent_radius pm" : "n/a",
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : "n/a",
            "specific_heat (@20C J/g mol)" : "n/a",
            "fusion_heat (kJ/mol)" : "n/a",
            "evaporation_heat (kJ/mol)" : "n/a",
            "thermal_conductivity (@25C W/m K) " : "n/a",
            "pauling_negativity" : "n/a",
            "first_ionizing kJ/mol" : "n/a",
            "oxidation_states" : "-",
            "electronic_configuration" : "[Rn]5f6d7s",
            "lattice_structure" : "n/a",
            "lattice_constant ang" : "n/a"
        },
        "Bohrium": {
            "symbol" : "Bh",
            "atomic_number" : 107,
            "atomic_weight" : "[264]",
            "density g/cm" : "n/a",
            "melting_point K" : "n/a",
            "boiling_point K" : "n/a",
            "atomic_radius pm" : "n/a",
            "covalent_radius pm" : "n/a",
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : "n/a",
            "specific_heat (@20C J/g mol)" : "n/a",
            "fusion_heat (kJ/mol)" : "n/a",
            "evaporation_heat (kJ/mol)" : "n/a",
            "thermal_conductivity (@25C W/m K) " : "n/a",
            "pauling_negativity" : "n/a",
            "first_ionizing kJ/mol" : "n/a",
            "oxidation_states" : "n/a",
            "electronic_configuration" : "n/a",
            "lattice_structure" : "n/a",
            "lattice_constant ang" : "n/a"
        },
        "Hassium": {
            "symbol" : "Hs",
            "atomic_number" : 108,
            "atomic_weight" : "[269]",
            "density g/cm" : "n/a",
            "melting_point K" : "n/a",
            "boiling_point K" : "n/a",
            "atomic_radius pm" : "n/a",
            "covalent_radius pm" : "n/a",
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : "n/a",
            "specific_heat (@20C J/g mol)" : "n/a",
            "fusion_heat (kJ/mol)" : "n/a",
            "evaporation_heat (kJ/mol)" : "n/a",
            "thermal_conductivity (@25C W/m K) " : "n/a",
            "pauling_negativity" : "n/a",
            "first_ionizing kJ/mol" : "n/a",
            "oxidation_states" : "n/a",
            "electronic_configuration" : "n/a",
            "lattice_structure" : "n/a",
            "lattice_constant ang" : "n/a"
        },
        "Meitnerium": {
            "symbol" : "Mt",
            "atomic_number" : 109,
            "atomic_weight" : "[278]",
            "density g/cm" : "n/a",
            "melting_point K" : "n/a",
            "boiling_point K" : "n/a",
            "atomic_radius pm" : "n/a",
            "covalent_radius pm" : "n/a",
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : "n/a",
            "specific_heat (@20C J/g mol)" : "n/a",
            "fusion_heat (kJ/mol)" : "n/a",
            "evaporation_heat (kJ/mol)" : "n/a",
            "thermal_conductivity (@25C W/m K) " : "n/a",
            "pauling_negativity" : "n/a",
            "first_ionizing kJ/mol" : "n/a",
            "oxidation_states" : "n/a",
            "electronic_configuration" : "n/a",
            "lattice_structure" : "n/a",
            "lattice_constant ang" : "n/a"
        },
        "Darmstadtium": {
            "symbol" : "Ds",
            "atomic_number" : 110,
            "atomic_weight" : "[281]",
            "density g/cm" : "n/a",
            "melting_point K" : "n/a",
            "boiling_point K" : "n/a",
            "atomic_radius pm" : "n/a",
            "covalent_radius pm" : "n/a",
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : "n/a",
            "specific_heat (@20C J/g mol)" : "n/a",
            "fusion_heat (kJ/mol)" : "n/a",
            "evaporation_heat (kJ/mol)" : "n/a",
            "thermal_conductivity (@25C W/m K) " : "n/a",
            "pauling_negativity" : "n/a",
            "first_ionizing kJ/mol" : "n/a",
            "oxidation_states" : "n/a",
            "electronic_configuration" : "n/a",
            "lattice_structure" : "n/a",
            "lattice_constant ang" : "n/a"
        },
        "Roentgenium": {
            "symbol" : "Rg",
            "atomic_number" : 111,
            "atomic_weight" : "[281]",
            "density g/cm" : "n/a",
            "melting_point K" : "n/a",
            "boiling_point K" : "n/a",
            "atomic_radius pm" : "n/a",
            "covalent_radius pm" : "n/a",
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : "n/a",
            "specific_heat (@20C J/g mol)" : "n/a",
            "fusion_heat (kJ/mol)" : "n/a",
            "evaporation_heat (kJ/mol)" : "n/a",
            "thermal_conductivity (@25C W/m K) " : "n/a",
            "pauling_negativity" : "n/a",
            "first_ionizing kJ/mol" : "n/a",
            "oxidation_states" : "n/a",
            "electronic_configuration" : "n/a",
            "lattice_structure" : "n/a",
            "lattice_constant ang" : "n/a"
        },
        "Copernicium": {
            "symbol" : "Cn",
            "atomic_number" : 112,
            "atomic_weight" : "[285]",
            "density g/cm" : "n/a",
            "melting_point K" : "n/a",
            "boiling_point K" : "n/a",
            "atomic_radius pm" : "n/a",
            "covalent_radius pm" : "n/a",
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : "n/a",
            "specific_heat (@20C J/g mol)" : "n/a",
            "fusion_heat (kJ/mol)" : "n/a",
            "evaporation_heat (kJ/mol)" : "n/a",
            "thermal_conductivity (@25C W/m K) " : "n/a",
            "pauling_negativity" : "n/a",
            "first_ionizing kJ/mol" : "n/a",
            "oxidation_states" : "n/a",
            "electronic_configuration" : "n/a",
            "lattice_structure" : "n/a",
            "lattice_constant ang" : "n/a"
        },
        "Ununtrium": {
            "symbol" : "Uut",
            "atomic_number" : 113,
            "atomic_weight" : "[286]",
            "density g/cm" : "n/a",
            "melting_point K" : "n/a",
            "boiling_point K" : "n/a",
            "atomic_radius pm" : "n/a",
            "covalent_radius pm" : "n/a",
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : "n/a",
            "specific_heat (@20C J/g mol)" : "n/a",
            "fusion_heat (kJ/mol)" : "n/a",
            "evaporation_heat (kJ/mol)" : "n/a",
            "thermal_conductivity (@25C W/m K) " : "n/a",
            "pauling_negativity" : "n/a",
            "first_ionizing kJ/mol" : "n/a",
            "oxidation_states" : "n/a",
            "electronic_configuration" : "n/a",
            "lattice_structure" : "n/a",
            "lattice_constant ang" : "n/a"
        },
        "Flerovium": {
            "symbol" : "Fl",
            "atomic_number" : 114,
            "atomic_weight" : "[289]",
            "density g/cm" : "n/a",
            "melting_point K" : "n/a",
            "boiling_point K" : "n/a",
            "atomic_radius pm" : "n/a",
            "covalent_radius pm" : "n/a",
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : "n/a",
            "specific_heat (@20C J/g mol)" : "n/a",
            "fusion_heat (kJ/mol)" : "n/a",
            "evaporation_heat (kJ/mol)" : "n/a",
            "thermal_conductivity (@25C W/m K) " : "n/a",
            "pauling_negativity" : "n/a",
            "first_ionizing kJ/mol" : "n/a",
            "oxidation_states" : "n/a",
            "electronic_configuration" : "n/a",
            "lattice_structure" : "n/a",
            "lattice_constant ang" : "n/a"
        },
        "Ununpentium": {
            "symbol" : "Uup",
            "atomic_number" : 115,
            "atomic_weight" : "[289]",
            "density g/cm" : "n/a",
            "melting_point K" : "n/a",
            "boiling_point K" : "n/a",
            "atomic_radius pm" : "n/a",
            "covalent_radius pm" : "n/a",
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : "n/a",
            "specific_heat (@20C J/g mol)" : "n/a",
            "fusion_heat (kJ/mol)" : "n/a",
            "evaporation_heat (kJ/mol)" : "n/a",
            "thermal_conductivity (@25C W/m K) " : "n/a",
            "pauling_negativity" : "n/a",
            "first_ionizing kJ/mol" : "n/a",
            "oxidation_states" : "n/a",
            "electronic_configuration" : "n/a",
            "lattice_structure" : "n/a",
            "lattice_constant ang" : "n/a"
        },
        "Livermorium": {
            "symbol" : "Lv",
            "atomic_number" : 116,
            "atomic_weight" : "[293]",
            "density g/cm" : "n/a",
            "melting_point K" : "n/a",
            "boiling_point K" : "n/a",
            "atomic_radius pm" : "n/a",
            "covalent_radius pm" : "n/a",
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : "n/a",
            "specific_heat (@20C J/g mol)" : "n/a",
            "fusion_heat (kJ/mol)" : "n/a",
            "evaporation_heat (kJ/mol)" : "n/a",
            "thermal_conductivity (@25C W/m K) " : "n/a",
            "pauling_negativity" : "n/a",
            "first_ionizing kJ/mol" : "n/a",
            "oxidation_states" : "n/a",
            "electronic_configuration" : "n/a",
            "lattice_structure" : "n/a",
            "lattice_constant ang" : "n/a"
        },
        "Ununseptium": {
            "symbol" : "Uus",
            "atomic_number" : 117,
            "atomic_weight" : "[294]",
            "density g/cm" : "n/a",
            "melting_point K" : "n/a",
            "boiling_point K" : "n/a",
            "atomic_radius pm" : "n/a",
            "covalent_radius pm" : "n/a",
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : "n/a",
            "specific_heat (@20C J/g mol)" : "n/a",
            "fusion_heat (kJ/mol)" : "n/a",
            "evaporation_heat (kJ/mol)" : "n/a",
            "thermal_conductivity (@25C W/m K) " : "n/a",
            "pauling_negativity" : "n/a",
            "first_ionizing kJ/mol" : "n/a",
            "oxidation_states" : "n/a",
            "electronic_configuration" : "n/a",
            "lattice_structure" : "n/a",
            "lattice_constant ang" : "n/a"
        },
        "Ununoctium": {
            "symbol" : "Uuo",
            "atomic_number" : 118,
            "atomic_weight" : "[294]",
            "density g/cm" : "n/a",
            "melting_point K" : "n/a",
            "boiling_point K" : "n/a",
            "atomic_radius pm" : "n/a",
            "covalent_radius pm" : "n/a",
            "ionic_radius pm" : "",
            "atomic_volume cm3/mol" : "n/a",
            "specific_heat (@20C J/g mol)" : "n/a",
            "fusion_heat (kJ/mol)" : "n/a",
            "evaporation_heat (kJ/mol)" : "n/a",
            "thermal_conductivity (@25C W/m K) " : "n/a",
            "pauling_negativity" : "n/a",
            "first_ionizing kJ/mol" : "n/a",
            "oxidation_states" : "n/a",
            "electronic_configuration" : "n/a",
            "lattice_structure" : "n/a",
            "lattice_constant ang" : "n/a"
        }
    };

    var periodicTable = $("<div>").appendTo("body");
    periodicTable.attr("title", $._("Periodic table of the elements"));
    periodicTable.dialog({
        autoOpen: false,
        show: "fade",
        hide: "fade",
        modal: "true",
        width: 900
    });
    // Disable the scratchpad so people don't try drawing on top of the "show
    // periodic table" button instead of clicking it.
    Khan.scratchpad.disable();
    $("#show-periodic-table").on("click", function() {
        periodicTable.dialog("open");
        return false;
    });


    var table = $("<table>").appendTo(periodicTable);
    table.addClass("periodic-table");

    var layout = [
        [ 1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  2],
        [ 3,  4,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  5,  6,  7,  8,  9, 10],
        [11, 12,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 13, 14, 15, 16, 17, 18],
        [19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36],
        [37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54],
        [55, 56, 57, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86],
        [87, 88, 89, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118],
        [ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0],
        [ 0,  0,  0, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71,  0],
        [ 0,  0,  0, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 0]];

    _.each(layout, function(row) {
        var tr = $("<tr>").appendTo(table);
        _.each(row, function(atomicNum) {
            var td = $("<td>").appendTo(tr);
            if (atomicNum !== 0) {
                td.addClass("element");
                var element = _.find(elements, function(element) { return element.atomic_number === atomicNum; });
                var weight = isNaN(element.atomic_weight) ? element.atomic_weight : KhanUtil.localeToFixed(element.atomic_weight, 2);
                $("<div>").appendTo(td).text(atomicNum).addClass("atomic-num");
                $("<div>").appendTo(td).text(element.symbol).addClass("symbol");
                $("<div>").appendTo(td).text(weight).addClass("weight");
            }
        });
    });

    $.extend(KhanUtil, {
        molarMass: function(symbol) {
            var element = _.find(elements, function(element) { return element.symbol === symbol; });
            return KhanUtil.roundTo(2, element.atomic_weight);
        }
    });
};

});

define('utils/cipher.js',['require'],function(require) {

$.extend(KhanUtil, {

    /* A set of cipher messages to diversify exercises */
    getCipherMessage: function(num) {
        return [
            $._("I have learned all kinds of different things from using Khan Academy"),
            $._("The world is filled with secrets and mysteries just waiting to be discovered"),
            $._("When a message contains a single character by itself, it is most likely either the letter i or a"),
            $._("Words which have repeating letters like too and all can also give a hint to what the secret message is"),
            $._("You have just cracked a Caesar cipher and obtained the title of code breaker")
        ][num - 1];
    },

    /* Apply caesar shift to a string, and returns the encoded message */
    applyCaesar: function(msg, shift) {

        var cipher = "",
            lc = "abcdefghijklmnopqrstuvwxyz",
            uc = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";

        for (var i = 0, len = msg.length; i < len; i++) {
            if (msg[i] >= "a" && msg[i] <= "z") {
                cipher = cipher + lc[(lc.indexOf(msg[i]) + shift) % 26];
            }
            else if (msg[i] >= "A" && msg[i] <= "Z") {
                cipher = cipher + uc[(uc.indexOf(msg[i]) + shift) % 26];
            }
            else {
                cipher = cipher + msg[i];
            }
        }

        return cipher;
    },

    /* Apply Vigenere cipher shift to a string, and returns the encoded message */
    applyVigenere: function(msg, key) {

        var cipher = "",
            shift = 0,
            count = 0,  // Don't count spaces when iterating the key word
            lc = "abcdefghijklmnopqrstuvwxyz",
            uc = "ABCDEFGHIJKLMNOPQRSTUVWXYZ",
            k = key.toLowerCase();

        for (var i = 0, len = msg.length, keyLen = k.length; i < len; i++) {
            // Grab shift for the current sequence of the key word
            shift = lc.indexOf(k[count % keyLen]);

            if (msg[i] >= "a" && msg[i] <= "z") {
                cipher = cipher + lc[(lc.indexOf(msg[i]) + shift) % 26];
                count++;
            }
            else if (msg[i] >= "A" && msg[i] <= "Z") {
                cipher = cipher + uc[(uc.indexOf(msg[i]) + shift) % 26];
                count++;
            }
            else {
                cipher = cipher + msg[i];
            }
        }

        return cipher;
    },

    /* Returns array of English letter frequenciy, normalized and then scaled */
    normEnglishLetterFreq: function(scale) {

        var freq = [.08167, .01492, .02782, .04253, .12702, .02228, .02015,  // a,b,c,d,e,f,g
                    .06094, .06966, .00154, .00772, .04024, .02406, .06749,  // h,i,j,k,l,m,n
                    .07507, .01929, .00095, .05987, .06327, .09056, .02758,  // o,p,q,r,s,t,u
                    .00978, .02360, .00150, .01974, .00074];               // v,w,x,y,z

        for (var i = 0, len = freq.length; i < len; i++) {
            freq[i] = freq[i] * scale;
        }

        return freq;
    },

    /* returns array of Cipher letter frequenciy, normalized and then scaled */
    normCipherLetterFreq: function(cipher, scale) {
        var msg = cipher.toLowerCase(),
            freq = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], //a-z @Nolint
            count = 0,  //letter count
            lc = "abcdefghijklmnopqrstuvwxyz";

        // Count up aplha charecters in cipher
        for (var i = 0, len = msg.length; i < len; i++) {
            if (msg[i] >= "a" && msg[i] <= "z") {
                freq[lc.indexOf(msg[i])]++;
                count++;
            }
        }

        // Normalize the cipher letter frequency, then scale it
        for (var i = 0, len = freq.length; i < len; i++) {
            freq[i] = (freq[i] / count) * scale;
        }

        return freq;
    }

});

});

define('utils/graphie.js',['require','./kpoint.js','./tex.js','./tmpl.js'],function(require) {

var kpoint = require("./kpoint.js");
require("./tex.js");  // for graphie.label()
require("./tmpl.js");

var Graphie = KhanUtil.Graphie = function() {
};

/* Convert cartesian coordinates [x, y] to polar coordinates [r,
 * theta], with theta in degrees, or in radians if angleInRadians is
 * specified.
 */
function cartToPolar(coord, angleInRadians) {
    var r = Math.sqrt(Math.pow(coord[0], 2) + Math.pow(coord[1], 2));
    var theta = Math.atan2(coord[1], coord[0]);
    // convert angle range from [-pi, pi] to [0, 2pi]
    if (theta < 0) {
        theta += 2 * Math.PI;
    }
    if (!angleInRadians) {
        theta = theta * 180 / Math.PI;
    }
    return [r, theta];
}

function polar(r, th) {
    if (typeof r === "number") {
        r = [r, r];
    }
    th = th * Math.PI / 180;
    return [r[0] * Math.cos(th), r[1] * Math.sin(th)];
}

$.extend(KhanUtil, {
    unscaledSvgPath: function(points) {
        // If this is an empty closed path, return "" instead of "z", which
        // would give an error
        if (points[0] === true) {
            return "";
        }
        return $.map(points, function(point, i) {
            if (point === true) {
                return "z";
            }
            return (i === 0 ? "M" : "L") + point[0] + " " + point[1];
        }).join("");
    },

    getDistance: function(point1, point2) {
        return kpoint.distanceToPoint(point1, point2);
    },

    /**
    * Return the difference between two sets of coordinates
    */
    coordDiff: function(startCoord, endCoord) {
        return _.map(endCoord, function(val, i) {
            return endCoord[i] - startCoord[i];
        });
    },

    /**
    * Round the given coordinates to a given snap value
    * (e.g., nearest 0.2 increment)
    */
    snapCoord: function(coord, snap) {
        return _.map(coord, function(val, i) {
            return KhanUtil.roundToNearest(snap[i], val);
        });
    },

    // Find the angle in degrees between two or three points
    findAngle: function(point1, point2, vertex) {
        if (vertex === undefined) {
            var x = point1[0] - point2[0];
            var y = point1[1] - point2[1];
            if (!x && !y) {
                return 0;
            }
            return (180 + Math.atan2(-y, -x) * 180 / Math.PI + 360) % 360;
        } else {
            return KhanUtil.findAngle(point1, vertex) - KhanUtil.findAngle(point2, vertex);
        }
    },

    graphs: {}
});


_.extend(Graphie.prototype, {
    cartToPolar: cartToPolar,
    polar: polar
});

var labelDirections = {
    "center": [-0.5, -0.5],
    "above": [-0.5, -1.0],
    "above right": [0.0, -1.0],
    "right": [0.0, -0.5],
    "below right": [0.0, 0.0],
    "below": [-0.5, 0.0],
    "below left": [-1.0, 0.0],
    "left": [-1.0, -0.5],
    "above left": [-1.0, -1.0]
};

KhanUtil.createGraphie = function(el) {
    var xScale = 40, yScale = 40, xRange, yRange;

    $(el).css("position", "relative");
    var raphael = Raphael(el);

    // For a sometimes-reproducible IE8 bug; doesn't affect SVG browsers at all
    $(el).children("div").css("position", "absolute");

    // Set up some reasonable defaults
    var currentStyle = {
        "stroke-width": 2,
        "fill": "none"
    };

    var scaleVector = function(point) {
        if (typeof point === "number") {
            return scaleVector([point, point]);
        }

        var x = point[0], y = point[1];
        return [x * xScale, y * yScale];
    };

    var scalePoint = function scalePoint(point) {
        if (typeof point === "number") {
            return scalePoint([point, point]);
        }

        var x = point[0], y = point[1];
        return [(x - xRange[0]) * xScale, (yRange[1] - y) * yScale];
    };

    var unscalePoint = function(point) {
        if (typeof point === "number") {
            return unscalePoint([point, point]);
        }

        var x = point[0], y = point[1];
        return [x / xScale + xRange[0], yRange[1] - y / yScale];
    };

    var unscaleVector = function(point) {
        if (typeof point === "number") {
            return unscaleVector([point, point]);
        }

        return [point[0] / xScale, point[1] / yScale];
    };

    var setLabelMargins = function(span, size) {
        var $span = $(span);
        var direction = $span.data("labelDirection");
        $span.css("visibility", "");

        if (typeof direction === "number") {
            var x = Math.cos(direction);
            var y = Math.sin(direction);

            var scale = Math.min(
                size[0] / 2 / Math.abs(x),
                size[1] / 2 / Math.abs(y));

            $span.css({
                marginLeft: (-size[0] / 2) + x * scale,
                marginTop: (-size[1] / 2) - y * scale
            });
        } else {
            var multipliers = labelDirections[direction || "center"];
            $span.css({
                marginLeft: Math.round(size[0] * multipliers[0]),
                marginTop: Math.round(size[1] * multipliers[1])
            });
        }
    };

    var svgPath = function(points, alreadyScaled) {
        // Bound a number by 1e-6 and 1e20 to avoid exponents after toString
        function boundNumber(num) {
            if (num === 0) {
                return num;
            } else if (num < 0) {
                return -boundNumber(-num);
            } else {
                return Math.max(1e-6, Math.min(num, 1e20));
            }
        }

        return $.map(points, function(point, i) {
            if (point === true) {
                return "z";
            } else {
                var scaled = alreadyScaled ? point : scalePoint(point);
                return (i === 0 ? "M" : "L") + boundNumber(scaled[0]) + " " + boundNumber(scaled[1]);
            }
        }).join("");
    };

    $.extend(KhanUtil, {svgPath: svgPath});

    var processAttributes = function(attrs) {
        var transformers = {
            scale: function(scale) {
                if (typeof scale === "number") {
                    scale = [scale, scale];
                }

                xScale = scale[0];
                yScale = scale[1];

                // Update the canvas size
                raphael.setSize((xRange[1] - xRange[0]) * xScale, (yRange[1] - yRange[0]) * yScale);
            },

            clipRect: function(pair) {
                var point = pair[0], size = pair[1];
                point[1] += size[1]; // because our coordinates are flipped

                return { "clip-rect": scalePoint(point).concat(scaleVector(size)).join(" ") };
            },

            strokeWidth: function(val) {
                return { "stroke-width": parseFloat(val) };
            },

            rx: function(val) {
                return { rx: scaleVector([val, 0])[0] };
            },

            ry: function(val) {
                return { ry: scaleVector([0, val])[1] };
            },

            r: function(val) {
                var scaled = scaleVector([val, val]);
                return { rx: scaled[0], ry: scaled[1] };
            }
        };

        var processed = {};
        $.each(attrs || {}, function(key, value) {
            var transformer = transformers[key];

            if (typeof transformer === "function") {
                $.extend(processed, transformer(value));
            } else {
                var dasherized = key.replace(/([A-Z]+)([A-Z][a-z])/g, "$1-$2")
                    .replace(/([a-z\d])([A-Z])/g, "$1-$2")
                    .toLowerCase();
                processed[dasherized] = value;
            }
        });

        return processed;
    };

    var addArrowheads = function arrows(path) {
        var type = path.constructor.prototype;

        if (type === Raphael.el) {
            if (path.type === "path" && typeof path.arrowheadsDrawn === "undefined") {
                var w = path.attr("stroke-width"), s = 0.6 + 0.4 * w;
                var l = path.getTotalLength();

                if (l < 0.75 * s) {
                    // You're weird because that's a *really* short path
                    // Giving up now before I get more confused

                } else {
                    // This makes a lot more sense
                    var set = raphael.set();
                    var head = raphael.path("M-3 4 C-2.75 2.5 0 0.25 0.75 0C0 -0.25 -2.75 -2.5 -3 -4");
                    var end = path.getPointAtLength(l - 0.4);
                    var almostTheEnd = path.getPointAtLength(l - 0.75 * s);
                    var angle = Math.atan2(end.y - almostTheEnd.y, end.x - almostTheEnd.x) * 180 / Math.PI;
                    var attrs = path.attr();
                    delete attrs.path;

                    var subpath = path.getSubpath(0, l - 0.75 * s);
                    subpath = raphael.path(subpath).attr(attrs);
                    subpath.arrowheadsDrawn = true;
                    path.remove();

                    head.rotate(angle, 0.75, 0).scale(s, s, 0.75, 0)
                        .translate(almostTheEnd.x, almostTheEnd.y).attr(attrs)
                        .attr({ "stroke-linejoin": "round", "stroke-linecap": "round" });
                    head.arrowheadsDrawn = true;
                    set.push(subpath);
                    set.push(head);
                    return set;
                }
            }
        } else if (type === Raphael.st) {
            for (var i = 0, l = path.items.length; i < l; i++) {
                arrows(path.items[i]);
            }
        }
        return path;
    };

    var drawingTools = {
        circle: function(center, radius) {
            return raphael.ellipse.apply(raphael, scalePoint(center).concat(scaleVector([radius, radius])));
        },

        // (x, y) is coordinate of bottom left corner
        rect: function(x, y, width, height) {
            // Raphael needs (x, y) to be coordinate of upper left corner
            var corner = scalePoint([x, y + height]);
            var dims = scaleVector([width, height]);
            return raphael.rect.apply(raphael, corner.concat(dims));
        },

        ellipse: function(center, radii) {
            return raphael.ellipse.apply(raphael, scalePoint(center).concat(scaleVector(radii)));
        },

        arc: function(center, radius, startAngle, endAngle, sector) {
            startAngle = (startAngle % 360 + 360) % 360;
            endAngle = (endAngle % 360 + 360) % 360;

            var cent = scalePoint(center);
            var radii = scaleVector(radius);
            var startVector = polar(radius, startAngle);
            var endVector = polar(radius, endAngle);

            var startPoint = scalePoint([center[0] + startVector[0], center[1] + startVector[1]]);
            var endPoint = scalePoint([center[0] + endVector[0], center[1] + endVector[1]]);

            var largeAngle = ((endAngle - startAngle) % 360 + 360) % 360 > 180;

            return raphael.path(
                "M" + startPoint.join(" ") +
                "A" + radii.join(" ") +
                " 0 " + // ellipse rotation
                (largeAngle ? 1 : 0) +
                " 0 " + // sweep flag
                endPoint.join(" ") +
                (sector ? "L" + cent.join(" ") + "z" : ""));
        },

        path: function(points) {
            var p = raphael.path(svgPath(points));
            p.graphiePath = points;
            return p;
        },

        scaledPath: function(points) {
            var p = raphael.path(svgPath(points, /* alreadyScaled */ true));
            p.graphiePath = points;
            return p;
        },

        line: function(start, end) {
            return this.path([start, end]);
        },

        grid: function(xr, yr) {
            var step = currentStyle.step || [1, 1];
            var set = raphael.set();

            var x = step[0] * Math.ceil(xr[0] / step[0]);
            for (; x <= xr[1]; x += step[0]) {
                set.push(this.line([x, yr[0]], [x, yr[1]]));
            }

            var y = step[1] * Math.ceil(yr[0] / step[1]);
            for (; y <= yr[1]; y += step[1]) {
                set.push(this.line([xr[0], y], [xr[1], y]));
            }

            return set;
        },

        label: function(point, text, direction, latex) {
            latex = (typeof latex === "undefined") || latex;

            var $span = $("<span>").addClass("graphie-label");

            if (!latex) {
                $span.html(text);
            }

            var pad = currentStyle["label-distance"];

            // TODO(alpert): Isn't currentStyle applied afterwards
            // automatically since this is a 'drawing tool'?
            $span
                .css($.extend({}, currentStyle, {
                        position: "absolute",
                        padding: (pad != null ? pad : 7) + "px"
                    }))
                .data("labelDirection", direction)
                .appendTo(el);

            $span.setPosition = function(point) {
                var scaledPoint = scalePoint(point);
                $span.css({
                    left: scaledPoint[0],
                    top: scaledPoint[1]
                });
            };

            $span.setPosition(point);

            var span = $span[0];

            $span.processMath = function(math, force) {
                KhanUtil.processMath(span, math, force, function() {
                    var width = span.scrollWidth;
                    var height = span.scrollHeight;
                    setLabelMargins(span, [width, height]);
                });
            };

            if (latex) {
                $span.processMath(text, /* force */ false);
            } else {
                var width = span.scrollWidth;
                var height = span.scrollHeight;
                setLabelMargins(span, [width, height]);
            }

            return $span;
        },

        plotParametric: function(fn, range, shade, fn2) {
            // Note: fn2 should only be set if 'shade' is true, as it denotes
            // the function between which fn should have its area shaded.
            // In general, plotParametric shouldn't be used to shade the area
            // between two arbitrary parametrics functions over an interval,
            // as the method assumes that fn and fn2 are both of the form
            // fn(t) = (t, fn'(t)) for some initial fn'.
            fn2 = fn2 || function(t) { return [t, 0]; };

            currentStyle.strokeLinejoin || (currentStyle.strokeLinejoin = "round");
            currentStyle.strokeLinecap || (currentStyle.strokeLinecap = "round");

            var min = range[0], max = range[1];
            var step = (max - min) / (currentStyle["plot-points"] || 800);
            if (step === 0) {
                step = 1;
            }

            var paths = raphael.set();
            var points = [];
            var lastDiff = KhanUtil.coordDiff(fn(min), fn2(min));

            var lastFlip = min;
            for (var t = min; t <= max; t += step) {
                var top = fn(t);
                var bottom = fn2(t);
                var diff = KhanUtil.coordDiff(top, bottom);

                // Find points where it flips
                // Create path that sketches area between the two functions
                if (
                    // if there is an asymptote here, meaning that the graph switches signs and has a large difference
                    ((diff[1] < 0) !== (lastDiff[1] < 0)) && Math.abs(diff[1] - lastDiff[1]) > 2 * yScale ||
                    // or the function value gets really high (which breaks raphael)
                    Math.abs(diff[1]) > 1e7 ||
                    // or the function is undefined
                    isNaN(diff[1])
                   ) {
                    // split the path at this point, and draw it
                    if (shade) {
                        points.push(top);

                        // backtrack to draw paired function
                        for (var u = t - step; u >= lastFlip; u -= step) {
                            points.push(fn2(u));
                        }
                        lastFlip = t;
                    }
                    paths.push(this.path(points));
                    // restart the path, excluding this point
                    points = [];
                    if (shade) {
                        points.push(top);
                    }
                } else {
                    // otherwise, just add the point to the path
                    points.push(top);
                }

                lastDiff = diff;
            }

            if (shade) {
                // backtrack to draw paired function
                for (var u = max - step; u >= lastFlip; u -= step) {
                    points.push(fn2(u));
                }
            }
            paths.push(this.path(points));

            return paths;
        },

        plotPolar: function(fn, range) {
            var min = range[0], max = range[1];

            // There is probably a better heuristic for this
            currentStyle["plot-points"] || (currentStyle["plot-points"] = 2 * (max - min) * xScale);

            return this.plotParametric(function(th) {
                return polar(fn(th), th * 180 / Math.PI);
            }, range);
        },

        plot: function(fn, range, swapAxes, shade, fn2) {
            var min = range[0], max = range[1];
            currentStyle["plot-points"] || (currentStyle["plot-points"] = 2 * (max - min) * xScale);

            if (swapAxes) {
                if (fn2) {
                    // TODO(charlie): support swapped axis area shading
                    throw new Error(
                        "Can't shade area between functions with swapped axes."
                    );
                }
                return this.plotParametric(function(y) {
                    return [fn(y), y];
                }, range, shade);
            } else {
                if (fn2) {
                    if (shade) {
                        return this.plotParametric(function(x) {
                            return [x, fn(x)];
                        }, range, shade, function(x) {
                            return [x, fn2(x)];
                        });
                    } else {
                        throw new Error(
                            "fn2 should only be set when 'shade' is True."
                        );
                    }
                }
                return this.plotParametric(function(x) {
                    return [x, fn(x)];
                }, range, shade);
            }
        },

        /**
         * Given a piecewise function, return a Raphael set of paths that
         * can be used to draw the function, e.g. using style().
         * Calls plotParametric.
         *
         * @param  {[]} fnArray    array of functions which when called
         *                         with a parameter i return the value of
         *                         the function at i
         * @param  {[]} rangeArray array of ranges over which the
         *                         corresponding functions are defined
         * @return {Raphael set}
         */
        plotPiecewise: function(fnArray, rangeArray) {
            var paths = raphael.set();
            var self = this;
            _.times(fnArray.length, function(i) {
                var fn = fnArray[i];
                var range = rangeArray[i];
                var fnPaths = self.plotParametric(function(x) {
                    return [x, fn(x)];
                }, range);
                _.each(fnPaths, function(fnPath) {
                    paths.push(fnPath);
                });
            });

            return paths;
        },

        /**
         * Given an array of coordinates of the form [x, y], create and
         * return a Raphael set of Raphael circle objects at those
         * coordinates
         *
         * @param  {Array of arrays} endpointArray
         * @return {Raphael set}
         */
        plotEndpointCircles: function(endpointArray) {
            var circles = raphael.set();
            var self = this;

            _.each(endpointArray, function(coord, i) {
                circles.push(self.circle(coord, 0.15));
            });

            return circles;
        },

        plotAsymptotes: function(fn, range) {
            var min = range[0], max = range[1];
            var step = (max - min) / (currentStyle["plot-points"] || 800);

            var asymptotes = raphael.set(), lastVal = fn(min);

            for (var t = min; t <= max; t += step) {
                var funcVal = fn(t);

                if (((funcVal < 0) !== (lastVal < 0)) && Math.abs(funcVal - lastVal) > 2 * yScale) {
                    asymptotes.push(
                        this.line([t, yScale], [t, -yScale])
                    );
                }

                lastVal = funcVal;
            }

            return asymptotes;
        }
    };

    var graphie = new Graphie();
    _.extend(graphie, {
        raphael: raphael,

        init: function(options) {
            var scale = options.scale || [40, 40];
            scale = (typeof scale === "number" ? [scale, scale] : scale);

            xScale = scale[0];
            yScale = scale[1];

            if (options.range == null) {
                return Khan.error("range should be specified in graph init");
            }

            xRange = options.range[0];
            yRange = options.range[1];

            var w = (xRange[1] - xRange[0]) * xScale, h = (yRange[1] - yRange[0]) * yScale;
            raphael.setSize(w, h);

            $(el).css({
                "width": w,
                "height": h
            });

            this.range = options.range;
            this.scale = scale;
            this.dimensions = [w, h];
            this.xpixels = w;
            this.ypixels = h;

            return this;
        },

        style: function(attrs, fn) {
            var processed = processAttributes(attrs);

            if (typeof fn === "function") {
                var oldStyle = currentStyle;
                currentStyle = $.extend({}, currentStyle, processed);
                var result = fn.call(graphie);
                currentStyle = oldStyle;
                return result;
            } else {
                $.extend(currentStyle, processed);
            }
        },

        scalePoint: scalePoint,
        scaleVector: scaleVector,

        unscalePoint: unscalePoint,
        unscaleVector: unscaleVector
    });

    $.each(drawingTools, function(name) {
        graphie[name] = function() {
            var last = arguments[arguments.length - 1];
            var oldStyle = currentStyle;
            var result;

            // The last argument is probably trying to change the style
            if (typeof last === "object" && !_.isArray(last)) {
                currentStyle = $.extend({}, currentStyle, processAttributes(last));

                var rest = [].slice.call(arguments, 0, arguments.length - 1);
                result = drawingTools[name].apply(drawingTools, rest);
            } else {
                currentStyle = $.extend({}, currentStyle);

                result = drawingTools[name].apply(drawingTools, arguments);
            }

            // Bad heuristic for recognizing Raphael elements and sets
            var type = result.constructor.prototype;
            if (type === Raphael.el || type === Raphael.st) {
                result.attr(currentStyle);

                if (currentStyle.arrows) {
                    result = addArrowheads(result);
                }
            } else if (result instanceof $) {
                result.css(currentStyle);
            }

            currentStyle = oldStyle;
            return result;
        };
    });


    // Initializes graphie settings for a graph and draws the basic graph
    // features (axes, grid, tick marks, and axis labels)
    // Options expected are:
    // - range: [[a, b], [c, d]] or [a, b]
    // - scale: [a, b] or number
    // - gridOpacity: number (0 - 1)
    // - gridStep: [a, b] or number (relative to units)
    // - tickStep: [a, b] or number (relative to grid steps)
    // - tickLen: [a, b] or number (in pixels)
    // - labelStep: [a, b] or number (relative to tick steps)
    // - yLabelFormat: fn to format label string for y-axis
    // - xLabelFormat: fn to format label string for x-axis
    // - smartLabelPositioning: true or false to ignore minus sign
    graphie.graphInit = function(options) {

        options = options || {};

        $.each(options, function(prop, val) {

            // allow options to be specified by a single number for shorthand if
            // the horizontal and vertical components are the same
            if (!prop.match(/.*Opacity$/) && prop !== "range" &&
                typeof val === "number") {
                options[prop] = [val, val];
            }

            // allow symmetric ranges to be specified by the absolute values
            if (prop === "range" || prop === "gridRange") {
                if (val.constructor === Array) {
                    if (val[0].constructor !== Array) {  // but don't mandate symmetric ranges
                        options[prop] = [[-val[0], val[0]], [-val[1], val[1]]];
                    }
                } else if (typeof val === "number") {
                    options[prop] = [[-val, val], [-val, val]];
                }
            }

        });

        var range = options.range || [[-10, 10], [-10, 10]],
            gridRange = options.gridRange || options.range,
            scale = options.scale || [20, 20],
            grid = options.grid != null ? options.grid : true,
            gridOpacity = options.gridOpacity || 0.1,
            gridStep = options.gridStep || [1, 1],
            axes = options.axes != null ? options.axes : true,
            axisArrows = options.axisArrows || "",
            axisOpacity = options.axisOpacity || 1.0,
            axisCenter = options.axisCenter || [
                Math.min(Math.max(range[0][0], 0), range[0][1]),
                Math.min(Math.max(range[1][0], 0), range[1][1])
            ],
            ticks = options.ticks != null ? options.ticks : true,
            tickStep = options.tickStep || [2, 2],
            tickLen = options.tickLen || [5, 5],
            tickOpacity = options.tickOpacity || 1.0,
            labels = options.labels || options.labelStep || false,
            labelStep = options.labelStep || [1, 1],
            labelOpacity = options.labelOpacity || 1.0,
            unityLabels = options.unityLabels || false,
            labelFormat = options.labelFormat || function(a) { return a; },
            xLabelFormat = options.xLabelFormat || labelFormat,
            yLabelFormat = options.yLabelFormat || labelFormat,
            smartLabelPositioning = options.smartLabelPositioning != null ?
                options.smartLabelPositioning : true,
            realRange = [
                [range[0][0] - (range[0][0] > 0 ? 1 : 0),
                 range[0][1] + (range[0][1] < 0 ? 1 : 0)],
                [range[1][0] - (range[1][0] > 0 ? 1 : 0),
                 range[1][1] + (range[1][1] < 0 ? 1 : 0)]
            ];

        if (!_.isArray(unityLabels)) {
            unityLabels = [unityLabels, unityLabels];
        }

        if (smartLabelPositioning) {
            var minusIgnorer = function(lf) { return function(a) {
                return (lf(a) + "").replace(/-(\d)/g, "\\llap{-}$1");
            }; };

            xLabelFormat = minusIgnorer(xLabelFormat);
            yLabelFormat = minusIgnorer(yLabelFormat);
        }

        this.init({
            range: realRange,
            scale: scale
        });

        // draw grid
        if (grid) {
            this.grid(gridRange[0], gridRange[1], {
                stroke: "#000000",
                opacity: gridOpacity,
                step: gridStep
            });
        }

        // draw axes
        if (axes) {

            // this is a slight hack until <-> arrowheads work
            if (axisArrows === "<->" || true) {
                this.style({
                    stroke: "#000000",
                    opacity: axisOpacity,
                    strokeWidth: 2,
                    arrows: "->"
                }, function() {
                    if (range[1][0] < 0 && range[1][1] > 0) {
                        this.path([axisCenter, [gridRange[0][0], axisCenter[1]]]);
                        this.path([axisCenter, [gridRange[0][1], axisCenter[1]]]);
                    }
                    if (range[0][0] < 0 && range[0][1] > 0) {
                        this.path([axisCenter, [axisCenter[0], gridRange[1][0]]]);
                        this.path([axisCenter, [axisCenter[0], gridRange[1][1]]]);
                    }
                });

            // also, we don't support "<-" arrows yet, but why you
            // would want that on your graph is beyond me.
            } else if (axisArrows === "->" || axisArrows === "") {
                this.style({
                    stroke: "#000000",
                    opacity: axisOpacity,
                    strokeWidth: 2,
                    arrows: axisArrows
                }, function() {
                    this.path([[gridRange[0][0], axisCenter[1]], [gridRange[0][1], axisCenter[1]]]);
                    this.path([[axisCenter[0], gridRange[1][0]], [axisCenter[0], gridRange[1][1]]]);
                });

            }

        }

        // draw tick marks
        if (ticks) {
            this.style({
                stroke: "#000000",
                opacity: tickOpacity,
                strokeWidth: 1
            }, function() {

                // horizontal axis
                var step = gridStep[0] * tickStep[0],
                    len = tickLen[0] / scale[1],
                    start = gridRange[0][0],
                    stop = gridRange[0][1];

                if (range[1][0] < 0 && range[1][1] > 0) {
                    for (var x = step + axisCenter[0]; x <= stop; x += step) {
                        if (x < stop || !axisArrows) {
                            this.line([x, -len + axisCenter[1]], [x, len + axisCenter[1]]);
                        }
                    }

                    for (var x = -step + axisCenter[0]; x >= start; x -= step) {
                        if (x > start || !axisArrows) {
                            this.line([x, -len + axisCenter[1]], [x, len + axisCenter[1]]);
                        }
                    }
                }

                // vertical axis
                step = gridStep[1] * tickStep[1];
                len = tickLen[1] / scale[0];
                start = gridRange[1][0];
                stop = gridRange[1][1];

                if (range[0][0] < 0 && range[0][1] > 0) {
                    for (var y = step + axisCenter[1]; y <= stop; y += step) {
                        if (y < stop || !axisArrows) {
                            this.line([-len + axisCenter[0], y], [len + axisCenter[0], y]);
                        }
                    }

                    for (var y = -step + axisCenter[1]; y >= start; y -= step) {
                        if (y > start || !axisArrows) {
                            this.line([-len + axisCenter[0], y], [len + axisCenter[0], y]);
                        }
                    }
                }

            });
        }

        // draw axis labels
        if (labels) {
            this.style({
                stroke: "#000000",
                opacity: labelOpacity
            }, function() {

                // horizontal axis
                var step = gridStep[0] * tickStep[0] * labelStep[0],
                    start = gridRange[0][0],
                    stop = gridRange[0][1],
                    xAxisPosition = (axisCenter[0] < 0) ? "above" : "below",
                    yAxisPosition = (axisCenter[0] < 0) ? "right" : "left",
                    xShowZero = axisCenter[0] === 0 && axisCenter[1] !== 0,
                    yShowZero = axisCenter[0] !== 0 && axisCenter[1] === 0,
                    axisOffCenter = axisCenter[0] !== 0 || axisCenter[1] !== 0,
                    showUnityX = unityLabels[0] || axisOffCenter,
                    showUnityY = unityLabels[1] || axisOffCenter;

                // positive x-axis
                for (var x = (xShowZero ? 0 : step) + axisCenter[0]; x <= stop; x += step) {
                    if (x < stop || !axisArrows) {
                        this.label([x, axisCenter[1]], xLabelFormat(x), xAxisPosition);
                    }
                }

                // negative x-axis
                for (var x = -step * (showUnityX ? 1 : 2) + axisCenter[0]; x >= start; x -= step) {
                    if (x > start || !axisArrows) {
                        this.label([x, axisCenter[1]], xLabelFormat(x), xAxisPosition);
                    }
                }

                step = gridStep[1] * tickStep[1] * labelStep[1];
                start = gridRange[1][0];
                stop = gridRange[1][1];

                // positive y-axis
                for (var y = (yShowZero ? 0 : step) + axisCenter[1]; y <= stop; y += step) {
                    if (y < stop || !axisArrows) {
                        this.label([axisCenter[0], y], yLabelFormat(y), yAxisPosition);
                    }
                }

                // negative y-axis
                for (var y = -step * (showUnityY ? 1 : 2) + axisCenter[1]; y >= start; y -= step) {
                    if (y > start || !axisArrows) {
                        this.label([axisCenter[0], y], yLabelFormat(y), yAxisPosition);
                    }
                }
            });
        }

    };

    return graphie;
};

$.fn.graphie = function(problem) {
    if (Khan.query.nographie != null) {
        return;
    }
    return this.find(".graphie, script[type='text/graphie']").addBack().filter(".graphie, script[type='text/graphie']").each(function() {
        // Grab code for later execution
        var code = $(this).text(), graphie;

        // Ignore graphie elements that have already been processed
        if ($(this).data("graphie") != null) {
            return;
        }

        // Remove any of the code that's in there
        $(this).empty();

        // Initialize the graph
        if ($(this).data("update")) {
            var id = $(this).data("update");
            $(this).remove();

            // Graph could be in either of these
            var area = $("#problemarea").add(problem);
            graphie = area.find("#" + id + ".graphie").data("graphie");
        } else {
            var el = this;
            if ($(this).filter("script")[0] != null) {
                el = $("<div>").addClass("graphie")
                    .attr("id", $(this).attr("id")).insertAfter(this)[0];
                $(this).remove();
            }
            graphie = KhanUtil.createGraphie(el);
            $(el).data("graphie", graphie);

            var id = $(el).attr("id");
            if (id) {
                KhanUtil.graphs[id] = graphie;
            }
        }

        // So we can write graph.bwahahaha = 17 to save stuff between updates
        if (typeof graphie.graph === "undefined") {
            graphie.graph = {};
        }

        // Add newline in case code ends with a // comment
        code = "(function() {" + code + "\n})()";

        // Execute the graph-specific code
        KhanUtil.currentGraph = graphie;
        $.tmpl.getVAR(code, graphie);
        // delete KhanUtil.currentGraph;
    }).end();
};

});

/*
 * Line Utils
 * A line is an array of two points e.g. [[-5, 0], [5, 0]].
 */
define('utils/kline.js',['require','./kpoint.js','./kvector.js','./knumber.js'],function(require) {

var kpoint = require("./kpoint.js");
var kvector = require("./kvector.js");
var knumber = require("./knumber.js");

var kline = KhanUtil.kline = {

    distanceToPoint: function(line, point) {
        return kpoint.distanceToLine(point, line);
    },

    reflectPoint: function(line, point) {
        return kpoint.reflectOverLine(point, line);
    },

    midpoint: function(line) {
        return [
            (line[0][0] + line[1][0]) / 2,
            (line[0][1] + line[1][1]) / 2
        ];
    },

    /**
    * Tests if two lines are collinear.
    * https://en.wikipedia.org/wiki/Collinearity
    */
    equal: function(line1, line2, tolerance) {
        /**
        * line1's points are trivially collinear.
        * So check against each point in line2.
        * Form a triangle of the points (line1 and a single point from line2)
        * iff the area of the triangle is zero, are the points collinear
        * http://mathworld.wolfram.com/Collinear.html
        */
        var x1 = line1[0][0];
        var y1 = line1[0][1];
        var x2 = line1[1][0];
        var y2 = line1[1][1];
        return _.every(line2, function(point) {
            var x3 = point[0];
            var y3 = point[1];
            
            //calculating area of triangle formed by the three points
            //https://en.wikipedia.org/wiki/Shoelace_formula#Examples
            //A = 1/2|x1*y2 + x2*y3 + x3*y1 - x2*y1 - x3*y2 - x1*y3|
            var area = (1/2)*Math.abs(x1*y2 + x2*y3 + x3*y1 -
                x2*y1 - x3*y2 - x1*y3);

            return knumber.equal(area, 0, tolerance);
        });
    },

    intersect: function(px, py, rx, ry, qx, qy, sx, sy) {
        // Returns true is the line from (px, py) to (rx, ry) intersections the line (qx, qy) to (sx, sy)
        // http://stackoverflow.com/questions/563198/how-do-you-detect-where-two-line-segments-intersect/565282#565282
        function cross(vx, vy, wx, wy) {
            return vx * wy - vy * wx;
        }

        if (cross(rx, ry, sx, sy) === 0) {
            return cross(qx - px, qy - py, rx, ry) === 0;
        } else {
            var t = cross(qx - px, qy - py, sx, sy) / cross(rx, ry, sx, sy);
            var u = cross(qx - px, qy - py, rx, ry) / cross(rx, ry, sx, sy);
            return 0 <= t && t <= 1 && 0 <= u && u <= 1;
        }
    }
};

return kline;

});

define('utils/interactive.js',['require','../third_party/jquery.mobile.vmouse.js','./graphie.js','./knumber.js','./kvector.js','./kpoint.js','./kline.js'],function(require) {

require("../third_party/jquery.mobile.vmouse.js");

require("./graphie.js");
var knumber = require("./knumber.js");
var kvector = require("./kvector.js");
var kpoint = require("./kpoint.js");
var kline = require("./kline.js");

function sum(array) {
    return _.reduce(array, function(memo, arg) { return memo + arg; }, 0);
}

function clockwise(points) {
    var segments = _.zip(points, points.slice(1).concat(points.slice(0, 1)));
    var areas = _.map(segments, function(segment) {
        var p1 = segment[0], p2 = segment[1];
        return (p2[0] - p1[0]) * (p2[1] + p1[1]);
    });
    return sum(areas) > 0;
}

/* vector-add multiple [x, y] coords/vectors */
function addPoints() {
    var points = _.toArray(arguments);
    var zipped = _.zip.apply(_, points);
    return _.map(zipped, sum);
}

function reverseVector(vector) {
    return _.map(vector, function(coord) {
        return coord * -1;
    });
}

function scaledDistanceFromAngle(angle) {
    // constants based on the magic numbers from graphie.addTriangle()
    var a = 3.51470560176242 * 20;
    var b = 0.5687298702748785 * 20;
    var c = -0.037587715462826674;
    return (a - b) * Math.exp(c * angle) + b;
}

function scaledPolarRad(radius, radians) {
    return [
        radius * Math.cos(radians),
        radius * Math.sin(radians) * -1 // SVG flips y axis
    ];
}

function scaledPolarDeg(radius, degrees) {
    var radians = degrees * Math.PI / 180;
    return scaledPolarRad(radius, radians);
}


$.extend(KhanUtil, {
    // Fill opacity for inequality shading
    FILL_OPACITY: 0.3,

    // TODO(alpert): Should this be a global?
    dragging: false,

    createSorter: function() {
        var sorter = {};
        var list;

        sorter.hasAttempted = false;

        sorter.init = function(element) {
            list = $("[id=" + element + "]").last();
            var container = list.wrap("<div>").parent();
            var placeholder = $("<li>");
            placeholder.addClass("placeholder");
            container.addClass("sortable ui-helper-clearfix");

            list.find("li").each(function(tileNum, tile) {
                $(tile).bind("vmousedown", function(event) {
                    if (event.type === "vmousedown" && (event.which === 1 || event.which === 0)) {
                        event.preventDefault();
                        $(tile).addClass("dragging");
                        var tileIndex = $(this).index();
                        placeholder.insertAfter(tile);
                        placeholder.width($(tile).width());
                        $(this).css("z-index", 100);
                        var offset = $(this).offset();
                        var click = {
                            left: event.pageX - offset.left - 3,
                            top: event.pageY - offset.top - 3
                        };
                        $(tile).css({ position: "absolute" });
                        $(tile).offset({
                            left: offset.left,
                            top: offset.top
                        });

                        $(document).bind("vmousemove.tile vmouseup.tile", function(event) {
                            event.preventDefault();
                            if (event.type === "vmousemove") {
                                sorter.hasAttempted = true;
                                $(tile).offset({
                                    left: event.pageX - click.left,
                                    top: event.pageY - click.top
                                });
                                var leftEdge = list.offset().left;
                                var midWidth = $(tile).offset().left - leftEdge;
                                var index = 0;
                                var sumWidth = 0;
                                list.find("li").each(function() {
                                    if (this === placeholder[0] || this === tile) {
                                        return;
                                    }
                                    if (midWidth > sumWidth + $(this).outerWidth(true) / 2) {
                                        index += 1;
                                    }
                                    sumWidth += $(this).outerWidth(true);
                                });
                                if (index !== tileIndex) {
                                    tileIndex = index;
                                    if (index === 0) {
                                        placeholder.prependTo(list);
                                        $(tile).prependTo(list);
                                    } else {
                                        placeholder.detach();
                                        $(tile).detach();
                                        var preceeding = list.find("li")[index - 1];
                                        placeholder.insertAfter(preceeding);
                                        $(tile).insertAfter(preceeding);
                                    }
                                }
                            } else if (event.type === "vmouseup") {
                                $(document).unbind(".tile");
                                var position = $(tile).offset();
                                $(position).animate(placeholder.offset(), {
                                    duration: 150,
                                    step: function(now, fx) {
                                        position[fx.prop] = now;
                                        $(tile).offset(position);
                                    },
                                    complete: function() {
                                        $(tile).css("z-index", 0);
                                        placeholder.detach();
                                        $(tile).css({ position: "static" });
                                        $(tile).removeClass("dragging");
                                    }
                                });
                            }
                        });
                    }
                });
            });
        };

        sorter.getContent = function() {
            var content = [];
            list.find("li").each(function(tileNum, tile) {
                content.push($.trim($(tile).find(".sort-key").text()));
            });
            return content;
        };

        sorter.setContent = function(content) {
            var tiles = [];
            $.each(content, function(n, sortKey) {
                var tile = list.find("li .sort-key").filter(function() {
                    // sort-key must match exactly
                    return $(this).text() === sortKey;
                }).closest("li").get(0);
                $(tile).detach();  // remove matched tile so you can have duplicates
                tiles.push(tile);
            });
            list.append(tiles);
        };


        return sorter;
    },

    // Useful for shapes that are only sometimes drawn. If a shape isn't
    // needed, it can be replaced with bogusShape which just has stub methods
    // that successfully do nothing.
    // The alternative would be 'if..typeof' checks all over the place.
    bogusShape: {
        animate: function() {},
        attr: function() {},
        remove: function() {}
    }
});

$.extend(KhanUtil.Graphie.prototype, {
    // Wrap graphInit to create a fixed-size graph automatically scaled to the given range
    initAutoscaledGraph: function(range, options) {
        var graph = this;
        options = $.extend({
            xpixels: 500,
            ypixels: 500,
            xdivisions: 20,
            ydivisions: 20,
            labels: true,
            unityLabels: true,
            range: (range === undefined ? [[-10, 10], [-10, 10]] : range)
        }, options);

        options.scale = [
            options.xpixels / (options.range[0][1] - options.range[0][0]),
            options.ypixels / (options.range[1][1] - options.range[1][0])
        ];
        options.gridStep = [
            (options.range[0][1] - options.range[0][0]) / options.xdivisions,
            (options.range[1][1] - options.range[1][0]) / options.ydivisions
        ];

        // Attach the resulting metrics to the graph for later reference
        graph.xpixels = options.xpixels;
        graph.ypixels = options.ypixels;
        graph.range = options.range;
        graph.scale = options.scale;

        graph.graphInit(options);
    },

    // graphie puts text spans on top of the SVG, which looks good, but gets
    // in the way of mouse events. This adds another SVG element on top
    // of everything else where we can add invisible shapes with mouse
    // handlers wherever we want.
    addMouseLayer: function(options) {
        var graph = this;
        options = _.extend({
            allowScratchpad: false
        }, options);

        graph.mouselayer = Raphael(graph.raphael.canvas.parentNode, graph.xpixels, graph.ypixels);
        $(graph.mouselayer.canvas).css("z-index", 2);
        if (options.onClick || options.onMouseDown || options.onMouseMove ||
                options.onMouseOver || options.onMouseOut) {
            var canvasClickTarget = graph.mouselayer.rect(
                    0, 0, graph.xpixels, graph.ypixels).attr({
                fill: "#000",
                opacity: 0
            });
            var isClickingCanvas = false;

            $(graph.mouselayer.canvas).on("vmousedown", function(e) {
                if (e.target === canvasClickTarget[0]) {
                    if (options.onMouseDown) {
                        options.onMouseDown(graph.getMouseCoord(e));
                    }
                    isClickingCanvas = true;

                    if (options.onMouseMove) {
                        $(document).bind("vmousemove.mouseLayer", function(e) {
                            if (isClickingCanvas) {
                                e.preventDefault();
                                options.onMouseMove(graph.getMouseCoord(e));
                            }
                        });
                    }

                    $(document).bind("vmouseup.mouseLayer", function(e) {
                        $(document).unbind(".mouseLayer");

                        // Only register clicks that started on the canvas, and not
                        // on another mouseLayer target
                        if (isClickingCanvas && options.onClick) {
                            options.onClick(graph.getMouseCoord(e));
                        }
                        isClickingCanvas = false;
                    });
                }
            });
            if (options.onMouseOver) {
                $(graph.mouselayer.canvas).on("vmouseover", function(e) {
                    options.onMouseOver(graph.getMouseCoord(e));
                });
            }
            if (options.onMouseOut) {
                $(graph.mouselayer.canvas).on("vmouseout", function(e) {
                    options.onMouseOut(graph.getMouseCoord(e));
                });
            }
        }
        if (!options.allowScratchpad) {
            Khan.scratchpad.disable();
        }
    },

    /**
     * Get mouse coordinates in pixels
     */
    getMousePx: function(event) {
        var graphie = this;

        // mouse{X|Y} is in pixels relative to the SVG
        var mouseX = event.pageX - $(graphie.raphael.
            canvas.parentNode).offset().left;
        var mouseY = event.pageY - $(graphie.raphael.
            canvas.parentNode).offset().top;

        return [mouseX, mouseY];
    },

    /**
     * Get mouse coordinates in graph coordinates
     */
    getMouseCoord: function(event) {
        return this.unscalePoint(this.getMousePx(event));
    },

    // Draw angle arcs
    drawArcs: function(point1, vertex, point3, numArcs) {
        var startAngle = KhanUtil.findAngle(point1, vertex);
        var endAngle = KhanUtil.findAngle(point3, vertex);
        if (((endAngle - startAngle) % 360 + 360) % 360 > 180) {
            var temp = startAngle;
            startAngle = endAngle;
            endAngle = temp;
        }

        var radius = 0.3;
        // smaller angles need a bigger radius
        if ((((endAngle - startAngle) % 360 + 360) % 360) < 75) {
            radius = (-0.6 / 90) * (((endAngle - startAngle) % 360 + 360) % 360) + 0.8;
        }

        var arcset = [];
        for (var arc = 0; arc < numArcs; ++arc) {
            arcset.push(this.arc(vertex, radius + (0.15 * arc), startAngle, endAngle));
        }
        return arcset;
    },

    /**
     * Unlike all other Graphie-related code, the following three functions use
     * a lot of scaled coordinates (so that labels appear the same size
     * regardless of current shape/figure scale). These are prefixed with 's'.
     */
    labelAngle: function(options) {
        var graphie = this;

        _.defaults(options, {
            point1: [0, 0],
            vertex: [0, 0],
            point3: [0, 0],
            label: null,
            numArcs: 1,
            showRightAngleMarker: true,
            pushOut: 0,
            clockwise: false,
            style: {}
        });

        // Allow null text to hide the 90 degree angle marker
        var text = (options.text === undefined) ? "" : options.text;

        var vertex = options.vertex;
        var sVertex = graphie.scalePoint(vertex);

        var p1, p3;
        if (options.clockwise) {
            p1 = options.point1;
            p3 = options.point3;
        } else {
            p1 = options.point3;
            p3 = options.point1;
        }

        // TODO(alex): more spacing if >= 100 degrees (due to +1 character)
        // also take into account angle vs. text orientation, if possible

        // Calculate angles
        var startAngle = KhanUtil.findAngle(p1, vertex);
        var endAngle = KhanUtil.findAngle(p3, vertex);
        var angle = (endAngle + 360 - startAngle) % 360;
        var halfAngle = (startAngle + angle / 2) % 360;

        // Calculate distance from angle
        var sPadding = 5 * options.pushOut;
        var sRadius = sPadding + scaledDistanceFromAngle(angle);

        var temp = [];

        if (Math.abs(angle - 90) < 1e-9 && options.showRightAngleMarker) {
            // Draw right angle box
            var v1 = addPoints(sVertex, scaledPolarDeg(sRadius, startAngle));
            var v2 = addPoints(sVertex, scaledPolarDeg(sRadius, endAngle));

            sRadius *= Math.SQRT2;
            var v3 = addPoints(sVertex, scaledPolarDeg(sRadius, halfAngle));

            _.each([v1, v2], function(v) {
                temp.push(graphie.scaledPath([v, v3], options.style));
            });
        } else {
            // Draw arcs
            _.times(options.numArcs, function(i) {
                temp.push(graphie.arc(
                    vertex,
                    graphie.unscaleVector(sRadius),
                    startAngle,
                    endAngle,
                    options.style
                ));
                sRadius += 3;
            });
        }

        if (text) {
            // Update label text

            // Substitute actual angle measure for "$deg"
            var match = text.match(/\$deg(\d)?/);
            if (match) {
                var precision = match[1] || 1;
                text = text.replace(
                    match[0],
                    KhanUtil.toFixedApprox(angle, precision) + "^{\\circ}"
                );
            }

            // Calculate label position
            var sOffset = scaledPolarDeg(sRadius + 15, halfAngle);
            var sPosition = addPoints(sVertex, sOffset);
            var position = graphie.unscalePoint(sPosition);

            // Reuse label if possible
            if (options.label) {
                options.label.setPosition(position);
                options.label.processMath(text, /* force */ true);
            } else {
                graphie.label(position, text, "center", options.style);
            }
        }

        return temp;
    },

    labelSide: function(options) {
        var graphie = this;

        _.defaults(options, {
            point1: [0, 0],
            point2: [0, 0],
            label: null,
            text: "",
            numTicks: 0,
            numArrows: 0,
            clockwise: false,
            style: {}
        });

        var p1, p2;
        if (options.clockwise) {
            p1 = options.point1;
            p2 = options.point2;
        } else {
            p1 = options.point2;
            p2 = options.point1;
        }

        var midpoint = [(p1[0] + p2[0]) / 2, (p1[1] + p2[1]) / 2];
        var sMidpoint = graphie.scalePoint(midpoint);

        var parallelAngle = Math.atan2(p2[1] - p1[1], p2[0] - p1[0]);
        var perpendicularAngle = parallelAngle + Math.PI / 2;

        var temp = [];
        var sCumulativeOffset = 0;

        if (options.numTicks) {
            // Draw ticks
            var n = options.numTicks;

            var sSpacing = 5;
            var sHeight = 5;

            var style = _.extend({}, options.style, {
                strokeWidth: 2
            });

            _.times(n, function(i) {
                var sOffset = sSpacing * (i - (n - 1) / 2);

                var sOffsetVector = scaledPolarRad(sOffset, parallelAngle);
                var sHeightVector = scaledPolarRad(sHeight, perpendicularAngle);

                var sPath = [
                    addPoints(sMidpoint, sOffsetVector, sHeightVector),
                    addPoints(sMidpoint, sOffsetVector,
                              reverseVector(sHeightVector))
                ];

                temp.push(graphie.scaledPath(sPath, style));
            });

            sCumulativeOffset += sSpacing * (n - 1) + 15;
        }

        if (options.numArrows) {
            // Draw arrows
            var n = options.numArrows;

            // Arrows always point up, unless horizontal (if so, point right)
            var start = [p1, p2].sort(function(a, b) {
                if (a[1] === b[1]) {
                    return a[0] - b[0];
                } else {
                    return a[1] - b[1];
                }
            })[0];
            var sStart = graphie.scalePoint(start);

            var style = _.extend({}, options.style, {
                arrows: "->",
                strokeWidth: 2
            });

            var sSpacing = 5;

            _.times(n, function(i) {
                var sOffset = sCumulativeOffset + sSpacing * i;
                var sOffsetVector = scaledPolarRad(sOffset, parallelAngle);

                if (start !== p1) {
                    sOffsetVector = reverseVector(sOffsetVector);
                }

                var sEnd = addPoints(sMidpoint, sOffsetVector);

                temp.push(graphie.scaledPath([sStart, sEnd], style));
            });
        }

        var text = options.text;
        if (text) {
            // Update label text

            // Substitute actual side length for "$len"
            var match = text.match(/\$len(\d)?/);
            if (match) {
                var distance = KhanUtil.getDistance(p1, p2);
                var precision = match[1] || 1;
                text = text.replace(
                    match[0],
                    KhanUtil.toFixedApprox(distance, precision)
                );
            }

            // Calculate label position

            // distance needs to take into account length of label
            // and perhaps orientation, to be smart about it
            var sOffset = 20;
            var sOffsetVector = scaledPolarRad(sOffset, perpendicularAngle);
            var sPosition = addPoints(sMidpoint, sOffsetVector);
            var position = graphie.unscalePoint(sPosition);

            // Reuse label if possible
            if (options.label) {
                options.label.setPosition(position);
                options.label.processMath(text, /* force */ true);
            } else {
                graphie.label(position, text, "center", options.style);
            }
        }

        return temp;
    },

    /* Can also be used to label points that aren't vertices */
    labelVertex: function(options) {
        var graphie = this;

        _.defaults(options, {
            point1: null,
            vertex: [0, 0],
            point3: null,
            label: null,
            text: "",
            clockwise: false,
            style: {}
        });

        if (!options.text) {
            return;
        }

        var vertex = options.vertex;
        var sVertex = graphie.scalePoint(vertex);

        var p1, p3;
        if (options.clockwise) {
            p1 = options.point1;
            p3 = options.point3;
        } else {
            p1 = options.point3;
            p3 = options.point1;
        }

        // Calculate label angle relative to vertex
        var angle = 135;
        var halfAngle;
        if (p1 && p3) {
            // Point within a polygon
            var startAngle = KhanUtil.findAngle(p1, vertex);
            var endAngle = KhanUtil.findAngle(p3, vertex);
            angle = (endAngle + 360 - startAngle) % 360;
            halfAngle = (startAngle + angle / 2 + 180) % 360;
        } else if (p1) {
            // Point on a line/segment
            var parallelAngle = KhanUtil.findAngle(vertex, p1);
            halfAngle = parallelAngle + 90;
        } else if (p3) {
            var parallelAngle = KhanUtil.findAngle(p3, vertex);
            halfAngle = parallelAngle + 90;
        } else {
            // Standalone point
            halfAngle = 135;
        }

        // Calculate label position
        var sRadius = 10 + scaledDistanceFromAngle(360 - angle);
        var sOffsetVector = scaledPolarDeg(sRadius, halfAngle);
        var sPosition = addPoints(sVertex, sOffsetVector);
        var position = graphie.unscalePoint(sPosition);

        // Reuse label if possible
        if (options.label) {
            options.label.setPosition(position);
            options.label.processMath(options.text, /* force */ true);
        } else {
            graphie.label(position, options.text, "center", options.style);
        }
    },


    // Add a point to the graph that can be dragged around.
    // It allows automatic constraints on its movement as well as automatically
    // managing line segments that terminate at the point.
    //
    // Options can be set to control how the point behaves:
    //   coord[]:
    //     The initial position of the point
    //   snapX, snapY:
    //     The minimum increment the point can be moved
    //
    // The return value is an object that can be used to manipulate the point:
    //   The coordX and coordY properties tell you the current position
    //
    //   By adding an onMove() method to the returned object, you can install an
    //   event handler that gets called every time the user moves the point.
    //
    //   The returned object also provides a moveTo(x,y) method that will move
    //   the point to a specific coordinate
    //
    // Constraints can be set on the on the returned object:
    //
    //  - Set point to be immovable:
    //        movablePoint.constraints.fixed = true
    //
    //  - Constrain point to a fixed distance from another point. The resulting
    //    point will move in a circle:
    //        movablePoint.fixedDistance = {
    //           dist: 2,
    //           point: point1
    //        }
    //
    //  - Constrain point to a line defined by a fixed angle between it and
    //    two other points:
    //        movablePoint.fixedAngle = {
    //           angle: 45,
    //           vertex: point1,
    //           ref: point2
    //        }
    //
    //  - Confined the point to traveling in a vertical or horizontal line,
    //    respectively
    //        movablePoint.constrainX = true;
    //        movablePoint.constrainY = true;
    //
    //  - Connect a movableLineSegment to a movablePoint. The point is attached
    //    to a specific end of the line segment by adding the segment either to
    //    the list of lines that start at the point or the list of lines that
    //    end at the point (movableLineSegment can do this for you):
    //        movablePoint.lineStarts.push(movableLineSegment);
    //          - or -
    //        movablePoint.lineEnds.push(movableLineSegment);
    //
    //  - Connect a movablePolygon to a movablePoint in exacty the same way:
    //        movablePoint.polygonVertices.push(movablePolygon);
    //
    addMovablePoint: function(options) {
        // The state object that gets returned
        var movablePoint = $.extend(true, {
            graph: this,
            coord: [0, 0],
            snapX: 0,
            snapY: 0,
            pointSize: 4,
            highlight: false,
            dragging: false,
            visible: true,
            bounded: true,
            constraints: {
                fixed: false,
                constrainX: false,
                constrainY: false,
                fixedAngle: {},
                fixedDistance: {}
            },
            lineStarts: [],
            lineEnds: [],
            polygonVertices: [],
            normalStyle: {},
            highlightStyle: {
                fill: KhanUtil.INTERACTING,
                stroke: KhanUtil.INTERACTING
            },
            labelStyle: {
                color: KhanUtil.INTERACTIVE
            },
            vertexLabel: "",
            mouseTarget: null
        }, options);

        var normalColor = (movablePoint.constraints.fixed) ?
                                  KhanUtil.DYNAMIC
                                : KhanUtil.INTERACTIVE;
        movablePoint.normalStyle = _.extend({}, {
            "fill": normalColor,
            "stroke": normalColor
        }, options.normalStyle);

        // deprecated: don't use coordX/coordY; use coord[]
        if (options.coordX !== undefined) {
            movablePoint.coord[0] = options.coordX;
        }
        if (options.coordY !== undefined) {
            movablePoint.coord[1] = options.coordY;
        }

        var graph = movablePoint.graph;

        var applySnapAndConstraints = function(coord) {
            // coord should be the scaled coordinate

            // move point away from edge of graph unless it's invisible or fixed
            if (movablePoint.visible &&
                    movablePoint.bounded &&
                    !movablePoint.constraints.fixed) {
                // can't go beyond 10 pixels from the edge
                coord = graph.constrainToBounds(coord, 10);
            }

            var coordX = coord[0];
            var coordY = coord[1];

            // snap coordinates to grid
            if (movablePoint.snapX !== 0) {
                coordX = Math.round(coordX / movablePoint.snapX) * movablePoint.snapX;
            }
            if (movablePoint.snapY !== 0) {
                coordY = Math.round(coordY / movablePoint.snapY) * movablePoint.snapY;
            }

            // snap to points around circle
            if (movablePoint.constraints.fixedDistance.snapPoints) {
                var mouse = graph.scalePoint(coord);
                var mouseX = mouse[0];
                var mouseY = mouse[1];

                var snapRadians = 2 * Math.PI / movablePoint.constraints.fixedDistance.snapPoints;
                var radius = movablePoint.constraints.fixedDistance.dist;

                // get coordinates relative to the fixedDistance center
                var centerCoord = movablePoint.constraints.fixedDistance.point;
                var centerX = (centerCoord[0] - graph.range[0][0]) * graph.scale[0];
                var centerY = (-centerCoord[1] + graph.range[1][1]) * graph.scale[1];

                var mouseXrel = mouseX - centerX;
                var mouseYrel = -mouseY + centerY;
                var radians = Math.atan(mouseYrel / mouseXrel);
                var outsideArcTanRange = mouseXrel < 0;

                // adjust so that angles increase from 0 to 2 pi as you go around the circle
                if (outsideArcTanRange) {
                    radians += Math.PI;
                }

                // perform the snap
                radians = Math.round(radians / snapRadians) * snapRadians;

                // convert from radians back to pixels
                mouseXrel = radius * Math.cos(radians);
                mouseYrel = radius * Math.sin(radians);
                // convert back to coordinates relative to graphie canvas
                mouseX = mouseXrel + centerX;
                mouseY = - mouseYrel + centerY;
                coordX = KhanUtil.roundTo(5, mouseX / graph.scale[0] + graph.range[0][0]);
                coordY = KhanUtil.roundTo(5, graph.range[1][1] - mouseY / graph.scale[1]);
            }

            // apply any constraints on movement
            var result = movablePoint.applyConstraint([coordX, coordY]);
            return result;
        };

        // Using the passed coordinates, apply any constraints and return the closest coordinates
        // that match the constraints.
        movablePoint.applyConstraint = function(coord, extraConstraints, override) {
            var newCoord = coord.slice();
            // use the configured constraints for the point plus any passed-in constraints; use only passed-in constraints if override is set
            var constraints = {};
            if (override) {
                $.extend(constraints, {
                    fixed: false,
                    constrainX: false,
                    constrainY: false,
                    fixedAngle: {},
                    fixedDistance: {}
                }, extraConstraints);
            } else {
                $.extend(constraints, this.constraints, extraConstraints);
            }

            // constrain to vertical movement
            if (constraints.constrainX) {
                newCoord = [this.coord[0], coord[1]];

            // constrain to horizontal movement
            } else if (constraints.constrainY) {
                newCoord = [coord[0], this.coord[1]];

            // both distance and angle are constrained
            } else if (typeof constraints.fixedAngle.angle === "number" && typeof constraints.fixedDistance.dist === "number") {
                var vertex = constraints.fixedAngle.vertex.coord || constraints.fixedAngle.vertex;
                var ref = constraints.fixedAngle.ref.coord || constraints.fixedAngle.ref;
                var distPoint = constraints.fixedDistance.point.coord || constraints.fixedDistance.point;

                var constrainedAngle = (constraints.fixedAngle.angle + KhanUtil.findAngle(ref, vertex)) * Math.PI / 180;
                var length = constraints.fixedDistance.dist;
                newCoord[0] = length * Math.cos(constrainedAngle) + distPoint[0];
                newCoord[1] = length * Math.sin(constrainedAngle) + distPoint[1];

            // angle is constrained
            } else if (typeof constraints.fixedAngle.angle === "number") {
                var vertex = constraints.fixedAngle.vertex.coord || constraints.fixedAngle.vertex;
                var ref = constraints.fixedAngle.ref.coord || constraints.fixedAngle.ref;

                // constrainedAngle is the angle from vertex to the point with reference to the screen
                var constrainedAngle = (constraints.fixedAngle.angle + KhanUtil.findAngle(ref, vertex)) * Math.PI / 180;
                // angle is the angle from vertex to the mouse with reference to the screen
                var angle = KhanUtil.findAngle(coord, vertex) * Math.PI / 180;
                var distance = KhanUtil.getDistance(coord, vertex);
                var length = distance * Math.cos(constrainedAngle - angle);
                length = length < 1.0 ? 1.0 : length;
                newCoord[0] = length * Math.cos(constrainedAngle) + vertex[0];
                newCoord[1] = length * Math.sin(constrainedAngle) + vertex[1];

            // distance is constrained
            } else if (typeof constraints.fixedDistance.dist === "number") {
                var distPoint = constraints.fixedDistance.point.coord || constraints.fixedDistance.point;

                var angle = KhanUtil.findAngle(coord, distPoint);
                var length = constraints.fixedDistance.dist;
                angle = angle * Math.PI / 180;
                newCoord[0] = length * Math.cos(angle) + distPoint[0];
                newCoord[1] = length * Math.sin(angle) + distPoint[1];

            // point is fixed
            } else if (constraints.fixed) {
                newCoord = movablePoint.coord;
            }
            return newCoord;
        };

        movablePoint.coord = applySnapAndConstraints(movablePoint.coord);

        if (movablePoint.visible) {
            graph.style(movablePoint.normalStyle, function() {
                movablePoint.visibleShape = graph.ellipse(movablePoint.coord, [movablePoint.pointSize / graph.scale[0], movablePoint.pointSize / graph.scale[1]]);
            });
        }
        movablePoint.normalStyle.scale = 1;
        movablePoint.highlightStyle.scale = 2;

        if (movablePoint.vertexLabel) {
            movablePoint.labeledVertex = this.label([0, 0], "", "center", movablePoint.labelStyle);
        }

        movablePoint.drawLabel = function() {
            if (movablePoint.vertexLabel) {
                movablePoint.graph.labelVertex({
                    vertex: movablePoint.coord,
                    label: movablePoint.labeledVertex,
                    text: movablePoint.vertexLabel,
                    style: movablePoint.labelStyle
                });
            }
        };

        movablePoint.drawLabel();

        movablePoint.grab = function() {
            $(document).bind("vmousemove.point vmouseup.point", function(event) {
                event.preventDefault();
                movablePoint.dragging = true;
                KhanUtil.dragging = true;

                var coord = graph.getMouseCoord(event);

                coord = applySnapAndConstraints(coord);
                var coordX = coord[0];
                var coordY = coord[1];
                var mouseX;
                var mouseY;

                if (event.type === "vmousemove") {
                    var doMove = true;
                    // The caller has the option of adding an onMove() method to the
                    // movablePoint object we return as a sort of event handler
                    // By returning false from onMove(), the move can be vetoed,
                    // providing custom constraints on where the point can be moved.
                    // By returning array [x, y], the move can be overridden
                    if (_.isFunction(movablePoint.onMove)) {
                        var result = movablePoint.onMove(coordX, coordY);
                        if (result === false) {
                            doMove = false;
                        }
                        if (_.isArray(result)) {
                            coordX = result[0];
                            coordY = result[1];
                        }
                    }
                    // coord{X|Y} may have been modified by constraints or onMove handler; adjust mouse{X|Y} to match
                    mouseX = (coordX - graph.range[0][0]) * graph.scale[0];
                    mouseY = (-coordY + graph.range[1][1]) * graph.scale[1];

                    if (doMove) {
                        movablePoint.visibleShape.attr("cx", mouseX);
                        movablePoint.mouseTarget.attr("cx", mouseX);
                        movablePoint.visibleShape.attr("cy", mouseY);
                        movablePoint.mouseTarget.attr("cy", mouseY);
                        movablePoint.coord = [coordX, coordY];
                        movablePoint.updateLineEnds();
                        $(movablePoint).trigger("move");
                    }

                    movablePoint.drawLabel();

                } else if (event.type === "vmouseup") {
                    $(document).unbind(".point");
                    movablePoint.dragging = false;
                    KhanUtil.dragging = false;
                    if (_.isFunction(movablePoint.onMoveEnd)) {
                        var result = movablePoint.onMoveEnd(coordX, coordY);
                        if (_.isArray(result)) {
                            coordX = result[0];
                            coordY = result[1];
                            mouseX = (coordX - graph.range[0][0]) * graph.scale[0];
                            mouseY = (-coordY + graph.range[1][1]) * graph.scale[1];
                            movablePoint.visibleShape.attr("cx", mouseX);
                            movablePoint.mouseTarget.attr("cx", mouseX);
                            movablePoint.visibleShape.attr("cy", mouseY);
                            movablePoint.mouseTarget.attr("cy", mouseY);
                            movablePoint.coord = [coordX, coordY];
                        }
                    }
                    if (!movablePoint.highlight) {
                        movablePoint.visibleShape.animate(movablePoint.normalStyle, 50);
                        if (movablePoint.onUnhighlight) {
                            movablePoint.onUnhighlight();
                        }
                    }
                }
            });
        };

        if (movablePoint.visible && !movablePoint.constraints.fixed) {
            // the invisible shape in front of the point that gets mouse events
            if (!movablePoint.mouseTarget) {
                movablePoint.mouseTarget = graph.mouselayer.circle(
                    graph.scalePoint(movablePoint.coord)[0],
                    graph.scalePoint(movablePoint.coord)[1],
                    15
                );
                movablePoint.mouseTarget.attr({fill: "#000", "opacity": 0.0});
            }

            $(movablePoint.mouseTarget[0]).css("cursor", "move");
            $(movablePoint.mouseTarget[0]).bind("vmousedown vmouseover vmouseout", function(event) {
                if (event.type === "vmouseover") {
                    movablePoint.highlight = true;
                    if (!KhanUtil.dragging) {
                        movablePoint.visibleShape.animate(movablePoint.highlightStyle, 50);
                        if (movablePoint.onHighlight) {
                            movablePoint.onHighlight();
                        }
                    }

                } else if (event.type === "vmouseout") {
                    movablePoint.highlight = false;
                    if (!movablePoint.dragging && !KhanUtil.dragging) {
                        movablePoint.visibleShape.animate(movablePoint.normalStyle, 50);
                        if (movablePoint.onUnhighlight) {
                            movablePoint.onUnhighlight();
                        }
                    }

                } else if (event.type === "vmousedown" && (event.which === 1 || event.which === 0)) {
                    event.preventDefault();

                    movablePoint.grab();
                }
            });
        }

        // Method to let the caller animate the point to a new position. Useful
        // as part of a hint to show the user the correct place to put the point.
        movablePoint.moveTo = function(coordX, coordY, updateLines) {
            // find distance in pixels to move
            var distance = KhanUtil.getDistance(this.graph.scalePoint([coordX, coordY]), this.graph.scalePoint(this.coord));

            // 5ms per pixel seems good
            var time = distance * 5;

            var scaled = graph.scalePoint([coordX, coordY]);
            var end = { cx: scaled[0], cy: scaled[1] };
            if (updateLines) {
                var start = {
                    cx: this.visibleShape.attr("cx"),
                    cy: this.visibleShape.attr("cy")
                };
                $(start).animate(end, {
                    duration: time,
                    easing: "linear",
                    step: function(now, fx) {
                        movablePoint.visibleShape.attr(fx.prop, now);
                        movablePoint.mouseTarget.attr(fx.prop, now);
                        if (fx.prop === "cx") {
                            movablePoint.coord[0] = now / graph.scale[0] + graph.range[0][0];
                        } else {
                            movablePoint.coord[1] = graph.range[1][1] - now / graph.scale[1];
                        }
                        movablePoint.updateLineEnds();
                    }
                });

            } else {
                this.visibleShape.animate(end, time);
                this.mouseTarget.animate(end, time);
            }
            this.coord = [coordX, coordY];
            if (_.isFunction(this.onMove)) {
                this.onMove(coordX, coordY);
            }
        };


        // After moving the point, call this to update all line segments terminating at the point
        movablePoint.updateLineEnds = function() {
            $(this.lineStarts).each(function() {
                this.coordA = movablePoint.coord;
                this.transform();
            });
            $(this.lineEnds).each(function() {
                this.coordZ = movablePoint.coord;
                this.transform();
            });
            $(this.polygonVertices).each(function() {
                this.transform();
            });
        };

        // Put the point at a new position without any checks, animation, or callbacks
        movablePoint.setCoord = function(coord) {
            if (this.visible) {
                var scaledPoint = graph.scalePoint(coord);
                this.visibleShape.attr({ cx: scaledPoint[0] });
                this.visibleShape.attr({ cy: scaledPoint[1] });
                if (this.mouseTarget != null) {
                    this.mouseTarget.attr({ cx: scaledPoint[0] });
                    this.mouseTarget.attr({ cy: scaledPoint[1] });
                }
            }
            this.coord = coord.slice();
        };

        // Put the point at the new position, checking that it is within the graph's bounds
        movablePoint.setCoordConstrained = function(coord) {
            this.setCoord(applySnapAndConstraints(coord));
        };

        // Change z-order to back
        movablePoint.toBack = function() {
            if (this.visible) {
                if (this.mouseTarget != null) {
                    this.mouseTarget.toBack();
                }
                this.visibleShape.toBack();
            }
        };

        // Change z-order to front
        movablePoint.toFront = function() {
            if (this.visible) {
                if (this.mouseTarget != null) {
                    this.mouseTarget.toFront();
                }
                this.visibleShape.toFront();
            }
        };

        movablePoint.remove = function() {
            if (this.visibleShape) {
                this.visibleShape.remove();
            }
            if (this.mouseTarget) {
                this.mouseTarget.remove();
            }
            if (this.labeledVertex) {
                this.labeledVertex.remove();
            }
        };

        return movablePoint;
    },

    // Plot a function that allows the user to mouse over points on the function.
    // * currently, the function must be continuous
    //
    // The return value is an object:
    //   By adding an onMove() method to the returned object, you can install an
    //   event handler that gets called every time the user moves the mouse over
    //   the function.
    //
    //   By adding an onLeave() method to the returned object, you can install an
    //   event handler that gets called when the mouse moves away from the function.
    //
    addInteractiveFn: function(fn, options) {
        var graph = this;
        options = $.extend({
            graph: graph,
            snap: 0,
            range: [graph.range[0][0], graph.range[0][1]]
        }, options);
        var interactiveFn = {
            highlight: false
        };

        // Plot the function
        graph.style({
            stroke: KhanUtil.INTERACTIVE
        }, function() {
            interactiveFn.visibleShape = graph.plot(fn, options.range, options.swapAxes);
        });

        // Draw a circle that will be used to highlight the point on the function the mouse is closest to
        graph.style({
            fill: KhanUtil.INTERACTIVE,
            stroke: KhanUtil.INTERACTIVE
        }, function() {
            interactiveFn.cursorPoint = graph.ellipse([0, fn(0)], [4 / graph.scale[0], 4 / graph.scale[1]]);
        });
        // Hide the point for now
        interactiveFn.cursorPoint.attr("opacity", 0.0);

        // We want the mouse target to be much wider than the line itself, so you don't
        // have to hit a 2px target. Ideally, this would be done with an invisible
        // line following the same path, but with a really big strokeWidth. That
        // mostly works, but unfortunately there seem to be some bugs in Firefox
        // where it gets a bit confused about whether the mouse is or isn't over
        // a really thick curved line :(
        //
        // So instead, we have to use a polygon.
        var mouseAreaWidth = 30;
        var points = [];
        var step = (options.range[1] - options.range[0]) / 100;

        var addScaledPoint = function(x, y) {
            if (options.swapAxes) {
                points.push([(y - graph.range[0][0]) * graph.scale[0], (graph.range[1][1] - x) * graph.scale[1]]);
            } else {
                points.push([(x - graph.range[0][0]) * graph.scale[0], (graph.range[1][1] - y) * graph.scale[1]]);
            }
        };

        // Draw a curve parallel to, but (mouseAreaWidth/2 pixels) above the function
        for (var x = options.range[0]; x <= options.range[1]; x += step) {
            var ddx = (fn(x - 0.001) - fn(x + 0.001)) / 0.002;
            var x1 = x;
            var y1 = fn(x) + (mouseAreaWidth / (2 * graph.scale[1]));

            if (ddx !== 0) {
                var normalslope = (-1 / (ddx * (graph.scale[1] / graph.scale[0]))) / (graph.scale[1] / graph.scale[0]);
                if (ddx < 0) {
                    x1 = x - Math.cos(-Math.atan(normalslope * (graph.scale[1] / graph.scale[0]))) * mouseAreaWidth / (2 * graph.scale[0]);
                    y1 = normalslope * (x - x1) + fn(x);
                } else if (ddx > 0) {
                    x1 = x + Math.cos(-Math.atan(normalslope * (graph.scale[1] / graph.scale[0]))) * mouseAreaWidth / (2 * graph.scale[0]);
                    y1 = normalslope * (x - x1) + fn(x);
                }
            }
            addScaledPoint(x1, y1);
        }
        // Draw a curve parallel to, but (mouseAreaWidth/2 pixels) below the function
        for (var x = options.range[1]; x >= options.range[0]; x -= step) {
            var ddx = (fn(x - 0.001) - fn(x + 0.001)) / 0.002;
            var x1 = x;
            var y1 = fn(x) - (mouseAreaWidth / (2 * graph.scale[1]));

            if (ddx !== 0) {
                var normalslope = (-1 / (ddx * (graph.scale[1] / graph.scale[0]))) / (graph.scale[1] / graph.scale[0]);
                if (ddx < 0) {
                    x1 = x + Math.cos(-Math.atan(normalslope * (graph.scale[1] / graph.scale[0]))) * mouseAreaWidth / (2 * graph.scale[0]);
                    y1 = normalslope * (x - x1) + fn(x);
                } else if (ddx > 0) {
                    x1 = x - Math.cos(-Math.atan(normalslope * (graph.scale[1] / graph.scale[0]))) * mouseAreaWidth / (2 * graph.scale[0]);
                    y1 = normalslope * (x - x1) + fn(x);
                }
            }
            addScaledPoint(x1, y1);
        }

        // plot the polygon and make it invisible
        interactiveFn.mouseTarget = graph.mouselayer.path(KhanUtil.unscaledSvgPath(points));
        interactiveFn.mouseTarget.attr({ fill: "#000", "opacity": 0.0 });

        // Add mouse handlers to the polygon
        $(interactiveFn.mouseTarget[0]).bind("vmouseover vmouseout vmousemove", function(event) {
            event.preventDefault();
            var mouseX = event.pageX - $(graph.raphael.canvas.parentNode).offset().left;
            var mouseY = event.pageY - $(graph.raphael.canvas.parentNode).offset().top;
            // can't go beyond 10 pixels from the edge
            mouseX = Math.max(10, Math.min(graph.xpixels - 10, mouseX));
            mouseY = Math.max(10, Math.min(graph.ypixels - 10, mouseY));
            // snap to grid
            if (options.snap) {
                mouseX = Math.round(mouseX / (graph.scale[0] * options.snap)) * (graph.scale[0] * options.snap);
            }
            // coord{X|Y} are the scaled coordinate values
            var coordX = mouseX / graph.scale[0] + graph.range[0][0];
            var coordY = graph.range[1][1] - mouseY / graph.scale[1];

            // Find the closest point on the curve to the mouse (by brute force)
            var findDistance = function(coordX, coordY) {
                var closestX = 0;
                var minDist = Math.sqrt((coordX) * (coordX) + (coordY) * (coordY));
                for (var x = options.range[0]; x < options.range[1]; x += ((options.range[1] - options.range[0]) / graph.xpixels)) {
                    if (Math.sqrt((x - coordX) * (x - coordX) + (fn(x) - coordY) * (fn(x) - coordY)) < minDist) {
                        closestX = x;
                        minDist = Math.sqrt((x - coordX) * (x - coordX) + (fn(x) - coordY) * (fn(x) - coordY));
                    }
                }
                return closestX;
            };

            if (options.swapAxes) {
                var closestX = findDistance(coordY, coordX);
                coordX = fn(closestX);
                coordY = closestX;
            } else {
                var closestX = findDistance(coordX, coordY);
                coordX = closestX;
                coordY = fn(closestX);
            }

            interactiveFn.cursorPoint.attr("cx", (graph.range[0][1] + coordX) * graph.scale[0]);
            interactiveFn.cursorPoint.attr("cy", (graph.range[1][1] - coordY) * graph.scale[1]);

            // If the caller wants to be notified when the user points to the function
            if (_.isFunction(interactiveFn.onMove)) {
                interactiveFn.onMove(coordX, coordY);
            }

            if (event.type === "vmouseover") {
                interactiveFn.cursorPoint.animate({ opacity: 1.0 }, 50);
                interactiveFn.highlight = true;

            } else if (event.type === "vmouseout") {
                interactiveFn.highlight = false;
                interactiveFn.cursorPoint.animate({ opacity: 0.0 }, 50);
                // If the caller wants to be notified when the user stops pointing to the function
                if (_.isFunction(interactiveFn.onLeave)) {
                    interactiveFn.onLeave(coordX, coordY);
                }
            }
        });

        interactiveFn.mouseTarget.toBack();
        return interactiveFn;
    },


    // MovableLineSegment is a line segment that can be dragged around the
    // screen. By attaching a smartPoint to each (or one) end, the ends can be
    // manipulated individually.
    //
    // To use with smartPoints, add the smartPoints first, then:
    //   addMovableLineSegment({ pointA: smartPoint1, pointZ: smartPoint2 });
    // Or just one end:
    //   addMovableLineSegment({ pointA: smartPoint, coordZ: [0, 0] });
    //
    // Include "fixed: true" in the options if you don't want the entire line
    // to be draggable (you can still use points to make the endpoints
    // draggable)
    //
    // The returned object includes the following properties/methods:
    //
    //   - lineSegment.coordA / lineSegment.coordZ
    //         The coordinates of each end of the line segment
    //
    //   - lineSegment.transform(syncToPoints)
    //         Repositions the line segment. Call after changing coordA and/or
    //         coordZ, or pass syncToPoints = true to use the current position
    //         of the corresponding smartPoints, if the segment was defined using
    //         smartPoints
    //
    addMovableLineSegment: function(options) {
        var lineSegment = $.extend({
            graph: this,
            coordA: [0, 0],
            coordZ: [1, 1],
            snapX: 0,
            snapY: 0,
            fixed: false,
            ticks: 0,
            normalStyle: {},
            highlightStyle: {
                "stroke": KhanUtil.INTERACTING,
                "stroke-width": 6
            },
            labelStyle: {
                "stroke": KhanUtil.INTERACTIVE,
                "color": KhanUtil.INTERACTIVE
            },
            highlight: false,
            dragging: false,
            tick: [],
            extendLine: false,
            extendRay: false,
            constraints: {
                fixed: false,
                constrainX: false,
                constrainY: false
            },
            sideLabel: "",
            vertexLabels: [],
            numArrows: 0,
            numTicks: 0,
            movePointsWithLine: false
        }, options);

        var normalColor = (lineSegment.fixed) ? KhanUtil.DYNAMIC
                                              : KhanUtil.INTERACTIVE;
        lineSegment.normalStyle = _.extend({}, {
            "stroke-width": 2,
            "stroke": normalColor
        }, options.normalStyle);
        // arrowStyle should be kept in sync with styling of the line
        lineSegment.arrowStyle = _.extend({}, lineSegment.normalStyle, {
            "color": lineSegment.normalStyle.stroke
        });

        // If the line segment is defined by movablePoints, coordA/coordZ are
        // owned by the points, otherwise they're owned by us
        if (options.pointA !== undefined) {
            lineSegment.coordA = options.pointA.coord;
            lineSegment.pointA.lineStarts.push(lineSegment);
        } else if (options.coordA !== undefined) {
            lineSegment.coordA = options.coordA.slice();
        }

        if (options.pointZ !== undefined) {
            lineSegment.coordZ = options.pointZ.coord;
            lineSegment.pointZ.lineEnds.push(lineSegment);
        } else if (options.coordA !== undefined) {
            lineSegment.coordA = lineSegment.coordA.slice();
        }

        var graph = lineSegment.graph;

        graph.style(lineSegment.normalStyle);
        for (var i = 0; i < lineSegment.ticks; ++i) {
            lineSegment.tick[i] = KhanUtil.bogusShape;
        }
        var path = KhanUtil.unscaledSvgPath([[0, 0], [1, 0]]);
        for (var i = 0; i < lineSegment.ticks; ++i) {
            var tickoffset = 0.5 - ((lineSegment.ticks - 1) + (i * 2)) / graph.scale[0];
            path += KhanUtil.unscaledSvgPath([[tickoffset, -7], [tickoffset, 7]]);
        }
        lineSegment.visibleLine = graph.raphael.path(path);
        lineSegment.visibleLine.attr(lineSegment.normalStyle);
        // Clip the line 5px from the edge of the graphie to allow for
        // arrowheads
        if (lineSegment.extendLine || lineSegment.extendRay) {
            lineSegment.visibleLine.attr({
                "clip-rect": "5 5 " + (graph.dimensions[0] - 10) + " " +
                    (graph.dimensions[1] - 10)
            });
        }
        if (!lineSegment.fixed) {
            lineSegment.mouseTarget = graph.mouselayer.rect(0, -15, 1, 30);
            lineSegment.mouseTarget.attr({fill: "#000", "opacity": 0.0});
        }

        // Reposition the line segment. Call after changing coordA and/or
        // coordZ, or pass syncToPoints = true to use the current position of
        // the corresponding movablePoints, if the segment was defined using
        // movablePoints
        lineSegment.transform = function(syncToPoints) {
            if (syncToPoints) {
                if (typeof this.pointA === "object") {
                    this.coordA = this.pointA.coord;
                }
                if (typeof this.pointZ === "object") {
                    this.coordZ = this.pointZ.coord;
                }
            }
            var scaledA = graph.scalePoint(this.coordA);
            var scaledZ = graph.scalePoint(this.coordZ);
            var angle = KhanUtil.findAngle(scaledZ, scaledA);
            var lineLength = KhanUtil.getDistance(scaledZ, scaledA);

            var elements = [this.visibleLine];
            if (!this.fixed) {
                elements.push(this.mouseTarget);
            }
            _.each(elements, function(element) {
                element.translate(scaledA[0] - element.attr("translation").x,
                        scaledA[1] - element.attr("translation").y);
                element.rotate(angle, scaledA[0], scaledA[1]);
                if (this.extendLine) {
                    element.translate(-0.5, 0);
                    lineLength = graph.dimensions[0] + graph.dimensions[1];
                    lineLength = 2 * lineLength;
                } else if (this.extendRay) {
                    lineLength = graph.dimensions[0] + graph.dimensions[1];
                }
                element.scale(lineLength, 1, scaledA[0], scaledA[1]);
            }, this);

            // Temporary objects: array of SVG nodes that get recreated on drag
            _.invoke(this.temp, "remove");
            this.temp = [];

            // Given `coord` and `angle`, find the point where a line extended
            // from `coord` in the direction of `angle` would be clipped by the
            // edge of the graphie canvas. Then draw an arrowhead at that point
            // pointing in the direction of `angle`.
            var drawArrowAtClipPoint = function(coord, angle) {
                var graph = lineSegment.graph;
                // Actually put the arrowheads 4px from the edge so they have
                // a bit of room
                var xExtent = graph.range[0][1] - graph.range[0][0];
                var yExtent = graph.range[1][1] - graph.range[1][0];

                // shoot a point off into the distance ...
                var distance = xExtent + yExtent;
                // we need to scale the point according to the scale of the axes
                var angleVec = graph.unscaleVector(
                    kvector.cartFromPolarDeg([1, angle])
                );
                var distVec = kvector.scale(
                    kvector.normalize(angleVec),
                    distance
                );
                var farCoord = kvector.add(coord, distVec);
                var scaledAngle = kvector.polarDegFromCart(angleVec)[1];
                // ... and then bring it back
                var clipPoint = graph.constrainToBoundsOnAngle(farCoord, 4,
                                              scaledAngle * Math.PI / 180);
                clipPoint = graph.scalePoint(clipPoint);

                var arrowHead = graph.raphael.path("M-3 4 C-2.75 2.5 0 0.25 0.75 0C0 -0.25 -2.75 -2.5 -3 -4");
                arrowHead.rotate(360 - angle, 0.75, 0)
                    .scale(1.4, 1.4, 0.75, 0)
                    .translate(clipPoint[0], clipPoint[1])
                    .attr(lineSegment.arrowStyle)
                    .attr({ "stroke-linejoin": "round", "stroke-linecap": "round", "stroke-dasharray": "" });

                return arrowHead;
            };

            if (this.extendLine) {
                this.temp.push(drawArrowAtClipPoint(this.coordA, 360 - angle));
                this.temp.push(drawArrowAtClipPoint(this.coordZ, (540 - angle) % 360));
            } else if (this.extendRay) {
                this.temp.push(drawArrowAtClipPoint(this.coordA, 360 - angle));
            }

            // Labels are always above line, unless vertical (if so, on right)
            // probably want to add an option to flip this at will!
            var isClockwise = (this.coordA[0] < this.coordZ[0]) ||
                (this.coordA[0] === this.coordZ[0] &&
                this.coordA[1] > this.coordZ[1]);

            // Update side label
            if (this.sideLabel) {
                this.temp.push(this.graph.labelSide({
                    point1: this.coordA,
                    point2: this.coordZ,
                    label: this.labeledSide,
                    text: this.sideLabel,
                    numArrows: this.numArrows,
                    numTicks: this.numTicks,
                    clockwise: isClockwise,
                    style: this.labelStyle
                }));
            }

            // Update vertex labels
            if (this.vertexLabels.length) {
                this.graph.labelVertex({
                    vertex: this.coordA,
                    point3: this.coordZ,
                    label: this.labeledVertices[0],
                    text: this.vertexLabels[0],
                    clockwise: isClockwise,
                    style: this.labelStyle
                });

                this.graph.labelVertex({
                    point1: this.coordA,
                    vertex: this.coordZ,
                    label: this.labeledVertices[1],
                    text: this.vertexLabels[1],
                    clockwise: isClockwise,
                    style: this.labelStyle
                });
            }

            this.temp = _.flatten(this.temp);
        };

        // Change z-order to back;
        lineSegment.toBack = function() {
            if (!lineSegment.fixed) {
                lineSegment.mouseTarget.toBack();
            }
            lineSegment.visibleLine.toBack();
        };

        // Change z-order to front
        lineSegment.toFront = function() {
            if (!lineSegment.fixed) {
                lineSegment.mouseTarget.toFront();
            }
            lineSegment.visibleLine.toFront();
        };

        lineSegment.remove = function() {
            if (!lineSegment.fixed) {
                lineSegment.mouseTarget.remove();
            }
            lineSegment.visibleLine.remove();
            if (lineSegment.labeledSide) {
                lineSegment.labeledSide.remove();
            }
            if (lineSegment.labeledVertices) {
                _.invoke(lineSegment.labeledVertices, "remove");
            }
            if (lineSegment.temp.length) {
                _.invoke(lineSegment.temp, "remove");
            }
        };

        lineSegment.hide = function() {
            lineSegment.visibleLine.hide();
            if (lineSegment.temp.length) {
                _.invoke(lineSegment.temp, "hide");
            }
        };

        lineSegment.show = function() {
            lineSegment.visibleLine.show();
            if (lineSegment.temp.length) {
                _.invoke(lineSegment.temp, "show");
            }
        };

        if (lineSegment.sideLabel) {
            lineSegment.labeledSide = this.label([0, 0], "", "center", lineSegment.labelStyle);
        }

        if (lineSegment.vertexLabels.length) {
            lineSegment.labeledVertices = _.map(lineSegment.vertexLabels, function(label) {
                return this.label([0, 0], "", "center", lineSegment.labelStyle);
            }, this);
        }

        if (!lineSegment.fixed && !lineSegment.constraints.fixed) {
            $(lineSegment.mouseTarget[0]).css("cursor", "move");
            $(lineSegment.mouseTarget[0]).bind("vmousedown vmouseover vmouseout", function(event) {
                if (event.type === "vmouseover") {
                    if (!KhanUtil.dragging) {
                        lineSegment.highlight = true;
                        lineSegment.visibleLine.animate(lineSegment.highlightStyle, 50);
                        lineSegment.arrowStyle = _.extend({}, lineSegment.arrowStyle, {
                            "color": lineSegment.highlightStyle.stroke,
                            "stroke": lineSegment.highlightStyle.stroke
                        });
                        lineSegment.transform();
                    }

                } else if (event.type === "vmouseout") {
                    lineSegment.highlight = false;
                    if (!lineSegment.dragging) {
                        lineSegment.visibleLine.animate(lineSegment.normalStyle, 50);
                        lineSegment.arrowStyle = _.extend({}, lineSegment.arrowStyle, {
                            "color": lineSegment.normalStyle.stroke,
                            "stroke": lineSegment.normalStyle.stroke
                        });
                        lineSegment.transform();
                    }

                } else if (event.type === "vmousedown" && (event.which === 1 || event.which === 0)) {
                    event.preventDefault();
                    // coord{X|Y} are the scaled coordinate values of the mouse position
                    var coordX = (event.pageX - $(graph.raphael.canvas.parentNode).offset().left) / graph.scale[0] + graph.range[0][0];
                    var coordY = graph.range[1][1] - (event.pageY - $(graph.raphael.canvas.parentNode).offset().top) / graph.scale[1];
                    if (lineSegment.snapX > 0) {
                        coordX = Math.round(coordX / lineSegment.snapX) * lineSegment.snapX;
                    }
                    if (lineSegment.snapY > 0) {
                        coordY = Math.round(coordY / lineSegment.snapY) * lineSegment.snapY;
                    }
                    // Offsets between the mouse and each end of the line segment
                    var mouseOffsetA = [lineSegment.coordA[0] - coordX, lineSegment.coordA[1] - coordY];
                    var mouseOffsetZ = [lineSegment.coordZ[0] - coordX, lineSegment.coordZ[1] - coordY];

                    // Figure out how many pixels of the bounding box of the line segment lie to each direction of the mouse
                    var offsetLeft = -Math.min(graph.scaleVector(mouseOffsetA)[0], graph.scaleVector(mouseOffsetZ)[0]);
                    var offsetRight = Math.max(graph.scaleVector(mouseOffsetA)[0], graph.scaleVector(mouseOffsetZ)[0]);
                    var offsetTop = Math.max(graph.scaleVector(mouseOffsetA)[1], graph.scaleVector(mouseOffsetZ)[1]);
                    var offsetBottom = -Math.min(graph.scaleVector(mouseOffsetA)[1], graph.scaleVector(mouseOffsetZ)[1]);

                    $(document).bind("vmousemove.lineSegment vmouseup.lineSegment", function(event) {
                        event.preventDefault();
                        lineSegment.dragging = true;
                        KhanUtil.dragging = true;

                        // mouse{X|Y} are in pixels relative to the SVG
                        var mouseX = event.pageX - $(graph.raphael.canvas.parentNode).offset().left;
                        var mouseY = event.pageY - $(graph.raphael.canvas.parentNode).offset().top;
                        // no part of the line segment can go beyond 10 pixels from the edge
                        mouseX = Math.max(offsetLeft + 10, Math.min(graph.xpixels - 10 - offsetRight, mouseX));
                        mouseY = Math.max(offsetTop + 10, Math.min(graph.ypixels - 10 - offsetBottom, mouseY));

                        // coord{X|Y} are the scaled coordinate values
                        var coordX = mouseX / graph.scale[0] + graph.range[0][0];
                        var coordY = graph.range[1][1] - mouseY / graph.scale[1];
                        if (lineSegment.snapX > 0) {
                            coordX = Math.round(coordX / lineSegment.snapX) * lineSegment.snapX;
                        }
                        if (lineSegment.snapY > 0) {
                            coordY = Math.round(coordY / lineSegment.snapY) * lineSegment.snapY;
                        }

                        if (event.type === "vmousemove") {
                            if (lineSegment.constraints.constrainX) {
                                coordX = lineSegment.coordA[0] - mouseOffsetA[0];
                            }
                            if (lineSegment.constraints.constrainY) {
                                coordY = lineSegment.coordA[1] - mouseOffsetA[1];
                            }
                            var dX = coordX + mouseOffsetA[0] - lineSegment.coordA[0];
                            var dY = coordY + mouseOffsetA[1] - lineSegment.coordA[1];
                            lineSegment.coordA = [coordX + mouseOffsetA[0], coordY + mouseOffsetA[1]];
                            lineSegment.coordZ = [coordX + mouseOffsetZ[0], coordY + mouseOffsetZ[1]];
                            lineSegment.transform();

                            if (lineSegment.movePointsWithLine) {
                                // If the points are movablePoints, adjust
                                // their coordinates when the line itself is
                                // dragged
                                if (typeof lineSegment.pointA === "object") {
                                    lineSegment.pointA.setCoord([
                                            lineSegment.pointA.coord[0] + dX,
                                            lineSegment.pointA.coord[1] + dY
                                    ]);
                                }
                                if (typeof lineSegment.pointZ === "object") {
                                    lineSegment.pointZ.setCoord([
                                            lineSegment.pointZ.coord[0] + dX,
                                            lineSegment.pointZ.coord[1] + dY
                                    ]);
                                }
                            }

                            if (_.isFunction(lineSegment.onMove)) {
                                lineSegment.onMove(dX, dY);
                            }

                        } else if (event.type === "vmouseup") {
                            $(document).unbind(".lineSegment");
                            lineSegment.dragging = false;
                            KhanUtil.dragging = false;
                            if (!lineSegment.highlight) {
                                lineSegment.visibleLine.animate(lineSegment.normalStyle, 50);
                                lineSegment.arrowStyle = _.extend({}, lineSegment.arrowStyle, {
                                    "color": lineSegment.normalStyle.stroke,
                                    "stroke": lineSegment.normalStyle.stroke
                                });
                                lineSegment.transform();
                            }
                            if (_.isFunction(lineSegment.onMoveEnd)) {
                                lineSegment.onMoveEnd();
                            }

                        }

                        $(lineSegment).trigger("move");
                    });
                }
            });
        }


        if (lineSegment.pointA !== undefined) {
            lineSegment.pointA.toFront();
        }
        if (lineSegment.pointZ !== undefined) {
            lineSegment.pointZ.toFront();
        }
        lineSegment.transform();
        return lineSegment;
    },

    // MovablePolygon is a polygon that can be dragged around the screen.
    // By attaching a smartPoint to each vertex, the points can be
    // manipulated individually.
    //
    // To use with smartPoints, add the smartPoints first, then:
    //   addMovablePolygon({points: [...]});
    //
    // Include "fixed: true" in the options if you don't want the entire
    // polygon to be draggable (you can still use points to make the
    // vertices draggable)
    //
    // The returned object includes the following properties/methods:
    //
    //   - polygon.points
    //         The polygon's dynamic smartPoints and static coordinates, mixed.
    //
    //   - polygon.coords
    //         The polygon's current coordinates (generated, don't edit).
    //
    //   - polygon.transform()
    //         Repositions the polygon. Call after changing any points.
    //
    addMovablePolygon: function(options) {
        var graphie = this;

        var polygon = $.extend({
            snapX: 0,
            snapY: 0,
            fixed: false,
            constrainToGraph: true,
            normalStyle: {},
            highlightStyle: {
                "stroke": KhanUtil.INTERACTING,
                "stroke-width": 2,
                "fill": KhanUtil.INTERACTING,
                "fill-opacity": 0.05
            },
            pointHighlightStyle: {
                "fill": KhanUtil.INTERACTING,
                "stroke": KhanUtil.INTERACTING
            },
            labelStyle: {
                "stroke": KhanUtil.DYNAMIC,
                "stroke-width": 1,
                "color": KhanUtil.DYNAMIC
            },
            angleLabels: [],
            showRightAngleMarkers: [],
            sideLabels: [],
            vertexLabels: [],
            numArcs: [],
            numArrows: [],
            numTicks: [],
            updateOnPointMove: true,
            closed: true
        }, _.omit(options, "points"));

        var normalColor = (polygon.fixed) ? KhanUtil.DYNAMIC
                                          : KhanUtil.INTERACTIVE;
        polygon.normalStyle = _.extend(polygon.normalStyle, {
            "stroke-width": 2,
            "fill-opacity": 0,
            "fill": normalColor,
            "stroke": normalColor
        }, options.normalStyle);

        // don't deep copy the points array with $.extend;
        // we may want to append to it later for click-to-add-points
        polygon.points = options.points;

        var isPoint = function(coordOrPoint) {
            return !_.isArray(coordOrPoint);
        };

        polygon.update = function() {
            var n = polygon.points.length;

            // Update coords
            polygon.coords = _.map(polygon.points, function(coordOrPoint, i) {
                if (isPoint(coordOrPoint)) {
                    return coordOrPoint.coord;
                } else {
                    return coordOrPoint;
                }
            });

            // Calculate bounding box
            polygon.left = _.min(_.pluck(polygon.coords, 0));
            polygon.right = _.max(_.pluck(polygon.coords, 0));
            polygon.top = _.max(_.pluck(polygon.coords, 1));
            polygon.bottom = _.min(_.pluck(polygon.coords, 1));

            // Calculate scaled coords
            var scaledCoords = _.map(polygon.coords, function(coord) {
                return graphie.scalePoint(coord);
            });

            // Create path
            if (polygon.closed) {
                scaledCoords.push(true);
            } else {
                // For open polygons, concatenate a reverse of the path,
                // to remove the inside area of the path, which would
                // otherwise be clickable (even if the closing line segment
                // wasn't drawn
                scaledCoords = scaledCoords.concat(
                    _.clone(scaledCoords).reverse()
                );
            }
            polygon.path = KhanUtil.unscaledSvgPath(scaledCoords);

            // Temporary objects
            _.invoke(polygon.temp, "remove");
            polygon.temp = [];

            // Check which direction coordinates wind
            var isClockwise = clockwise(polygon.coords);

            // Update angle labels
            if (polygon.angleLabels.length ||
                    polygon.showRightAngleMarkers.length) {
                _.each(polygon.labeledAngles, function(label, i) {
                    polygon.temp.push(graphie.labelAngle({
                        point1: polygon.coords[(i - 1 + n) % n],
                        vertex: polygon.coords[i],
                        point3: polygon.coords[(i + 1) % n],
                        label: label,
                        text: polygon.angleLabels[i],
                        showRightAngleMarker: polygon.showRightAngleMarkers[i],
                        numArcs: polygon.numArcs[i],
                        clockwise: isClockwise,
                        style: polygon.labelStyle
                    }));
                });
            }

            // Update side labels
            if (polygon.sideLabels.length) {
                _.each(polygon.labeledSides, function(label, i) {
                    polygon.temp.push(graphie.labelSide({
                        point1: polygon.coords[i],
                        point2: polygon.coords[(i + 1) % n],
                        label: label,
                        text: polygon.sideLabels[i],
                        numArrows: polygon.numArrows[i],
                        numTicks: polygon.numTicks[i],
                        clockwise: isClockwise,
                        style: polygon.labelStyle
                    }));
                });
            }

            // Update vertex labels
            if (polygon.vertexLabels.length) {
                _.each(polygon.labeledVertices, function(label, i) {
                    graphie.labelVertex({
                        point1: polygon.coords[(i - 1 + n) % n],
                        vertex: polygon.coords[i],
                        point3: polygon.coords[(i + 1) % n],
                        label: label,
                        text: polygon.vertexLabels[i],
                        clockwise: isClockwise,
                        style: polygon.labelStyle
                    });
                });
            }

            polygon.temp = _.flatten(polygon.temp);
        };

        polygon.transform = function() {
            polygon.update();

            polygon.visibleShape.attr({path: polygon.path});

            if (!polygon.fixed) {
                polygon.mouseTarget.attr({path: polygon.path});
            }
        };

        polygon.remove = function() {
            polygon.visibleShape.remove();

            if (!polygon.fixed) {
                polygon.mouseTarget.remove();
            }

            if (polygon.labeledAngles) {
                _.invoke(polygon.labeledAngles, "remove");
            }

            if (polygon.labeledSides) {
                _.invoke(polygon.labeledSides, "remove");
            }

            if (polygon.labeledVertices) {
                _.invoke(polygon.labeledVertices, "remove");
            }

            if (polygon.temp.length) {
                _.invoke(polygon.temp, "remove");
            }
        };

        polygon.toBack = function() {
            if (!polygon.fixed) {
                polygon.mouseTarget.toBack();
            }

            polygon.visibleShape.toBack();
        };

        polygon.toFront = function() {
            if (!polygon.fixed) {
                polygon.mouseTarget.toFront();
            }

            polygon.visibleShape.toFront();
        };

        // Setup

        if (polygon.updateOnPointMove) {
            _.each(_.filter(polygon.points, isPoint), function(coordOrPoint) {
                coordOrPoint.polygonVertices.push(polygon);
            });
        }

        polygon.coords = new Array(polygon.points.length);

        if (polygon.angleLabels.length) {
            polygon.labeledAngles = _.times(Math.max(
                        polygon.angleLabels.length,
                        polygon.showRightAngleMarkers.length
                    ), function() {
                return this.label([0, 0], "", "center", polygon.labelStyle);
            }, this);
        }

        if (polygon.sideLabels.length) {
            polygon.labeledSides = _.map(polygon.sideLabels, function(label) {
                return this.label([0, 0], "", "center", polygon.labelStyle);
            }, this);
        }

        if (polygon.vertexLabels.length) {
            polygon.labeledVertices = _.map(polygon.vertexLabels, function(label) {
                return this.label([0, 0], "", "center", polygon.labelStyle);
            }, this);
        }

        polygon.update();

        polygon.visibleShape = graphie.raphael.path(polygon.path);
        polygon.visibleShape.attr(polygon.normalStyle);

        if (!polygon.fixed) {
            polygon.mouseTarget = graphie.mouselayer.path(polygon.path);
            polygon.mouseTarget.attr({fill: "#000", opacity: 0, cursor: "move"});

            $(polygon.mouseTarget[0]).bind("vmousedown vmouseover vmouseout", function(event) {
                if (event.type === "vmouseover") {
                    if (!KhanUtil.dragging || polygon.dragging) {
                        polygon.highlight = true;
                        polygon.visibleShape.animate(polygon.highlightStyle, 50);
                        _.each(_.filter(polygon.points, isPoint), function(point) {
                            point.visibleShape.animate(polygon.pointHighlightStyle, 50);
                        });
                    }

                } else if (event.type === "vmouseout") {
                    polygon.highlight = false;
                    if (!polygon.dragging) {
                        polygon.visibleShape.animate(polygon.normalStyle, 50);
                        var points = _.filter(polygon.points, isPoint);
                        if (!_.any(_.pluck(points, "dragging"))) {
                            _.each(points, function(point) {
                                point.visibleShape.animate(point.normalStyle, 50);
                            });
                        }
                    }

                } else if (event.type === "vmousedown" && (event.which === 1 || event.which === 0)) {
                    event.preventDefault();

                    _.each(_.filter(polygon.points, isPoint), function(point) {
                        point.dragging = true;
                    });

                    // start{X|Y} are the scaled coordinate values of the starting mouse position
                    var startX = (event.pageX - $(graphie.raphael.canvas.parentNode).offset().left) / graphie.scale[0] + graphie.range[0][0];
                    var startY = graphie.range[1][1] - (event.pageY - $(graphie.raphael.canvas.parentNode).offset().top) / graphie.scale[1];
                    if (polygon.snapX > 0) {
                        startX = Math.round(startX / polygon.snapX) * polygon.snapX;
                    }
                    if (polygon.snapY > 0) {
                        startY = Math.round(startY / polygon.snapY) * polygon.snapY;
                    }
                    var lastX = startX;
                    var lastY = startY;

                    var polygonCoords = polygon.coords.slice();

                    // Figure out how many pixels of the bounding box of the polygon lie to each direction of the mouse
                    var offsetLeft = (startX - polygon.left) * graphie.scale[0];
                    var offsetRight = (polygon.right - startX) * graphie.scale[0];
                    var offsetTop = (polygon.top - startY) * graphie.scale[1];
                    var offsetBottom = (startY - polygon.bottom) * graphie.scale[1];

                    $(document).bind("vmousemove.polygon vmouseup.polygon", function(event) {
                        event.preventDefault();

                        polygon.dragging = true;
                        KhanUtil.dragging = true;

                        // mouse{X|Y} are in pixels relative to the SVG
                        var mouseX = event.pageX - $(graphie.raphael.canvas.parentNode).offset().left;
                        var mouseY = event.pageY - $(graphie.raphael.canvas.parentNode).offset().top;

                        // no part of the polygon can go beyond 10 pixels from the edge
                        if (polygon.constrainToGraph) {
                            mouseX = Math.max(
                                offsetLeft + 10,
                                Math.min(
                                    graphie.xpixels - 10 - offsetRight,
                                    mouseX
                                )
                            );
                            mouseY = Math.max(
                                offsetTop + 10,
                                Math.min(
                                    graphie.ypixels - 10 - offsetBottom,
                                    mouseY
                                )
                            );
                        }

                        // current{X|Y} are the scaled coordinate values of the current mouse position
                        var currentX = mouseX / graphie.scale[0] + graphie.range[0][0];
                        var currentY = graphie.range[1][1] - mouseY / graphie.scale[1];
                        if (polygon.snapX > 0) {
                            currentX = Math.round(currentX / polygon.snapX) * polygon.snapX;
                        }
                        if (polygon.snapY > 0) {
                            currentY = Math.round(currentY / polygon.snapY) * polygon.snapY;
                        }

                        if (event.type === "vmousemove") {
                            var dX = currentX - startX;
                            var dY = currentY - startY;

                            // The caller has the option of adding an onMove()
                            // method to the movablePolygon object we return as
                            // a sort of event handler. By returning false from
                            // onMove(), the move can be vetoed, providing
                            // custom constraints on where the point can be
                            // moved. By returning array [dX, dY], the move can
                            // be overridden.
                            var doMove = true;
                            if (_.isFunction(polygon.onMove)) {
                                var onMoveResult = polygon.onMove(dX, dY);
                                if (onMoveResult === false) {
                                    doMove = false;
                                } else if (_.isArray(onMoveResult)) {
                                    dX = onMoveResult[0];
                                    dY = onMoveResult[1];
                                    currentX = startX + dX;
                                    currentY = startY + dY;
                                }
                            }

                            var increment = function(i) {
                                return [
                                    polygonCoords[i][0] + dX,
                                    polygonCoords[i][1] + dY
                                ];
                            };

                            if (doMove) {
                                _.each(polygon.points, function(coordOrPoint, i) {
                                    if (isPoint(coordOrPoint)) {
                                        coordOrPoint.setCoord(increment(i));
                                    } else {
                                        polygon.points[i] = increment(i);
                                    }
                                });

                                polygon.transform();

                                $(polygon).trigger("move");

                                lastX = currentX;
                                lastY = currentY;
                            }

                        } else if (event.type === "vmouseup") {
                            $(document).unbind(".polygon");

                            var points = _.filter(polygon.points, isPoint);
                            _.each(points, function(point) {
                                point.dragging = false;
                            });

                            polygon.dragging = false;
                            KhanUtil.dragging = false;
                            if (!polygon.highlight) {
                                polygon.visibleShape.animate(polygon.normalStyle, 50);

                                _.each(points, function(point) {
                                    point.visibleShape.animate(point.normalStyle, 50);
                                });
                            }
                            if (_.isFunction(polygon.onMoveEnd)) {
                                polygon.onMoveEnd(lastX - startX, lastY - startY);
                            }
                        }
                    });
                }
            });
        }

        // Bring any movable points to the front
        _.invoke(_.filter(polygon.points, isPoint), "toFront");

        return polygon;
    },

    /**
     * Constrain a point to be within the graph (including padding).
     * If outside graph, point's x and y coordinates are clamped within
     * the graph.
     */
    constrainToBounds: function(point, padding) {
        var lower = this.unscalePoint([padding, this.ypixels - padding]);
        var upper = this.unscalePoint([this.xpixels - padding, padding]);
        var coordX = Math.max(lower[0], Math.min(upper[0], point[0]));
        var coordY = Math.max(lower[1], Math.min(upper[1], point[1]));
        return [coordX, coordY];
    },

    /**
     * Constrain a point to be within the graph (including padding).
     * If outside graph, point is moved along the ray specified by angle
     * until inside graph.
     */
    constrainToBoundsOnAngle: function(point, padding, angle) {
        var lower = this.unscalePoint([padding, this.ypixels - padding]);
        var upper = this.unscalePoint([this.xpixels - padding, padding]);

        var result = point.slice();

        if (result[0] < lower[0]) {
            result = [lower[0], result[1] + (lower[0] - result[0]) * Math.tan(angle)];
        } else if (result[0] > upper[0]) {
            result = [upper[0], result[1] - (result[0] - upper[0]) * Math.tan(angle)];
        }

        if (result[1] < lower[1]) {
            result = [result[0] + (lower[1] - result[1]) / Math.tan(angle), lower[1]];
        } else if (result[1] > upper[1]) {
            result = [result[0] - (result[1] - upper[1]) / Math.tan(angle), upper[1]];
        }

        return result;
    },

    // MovableAngle is an angle that can be dragged around the screen.
    // By attaching a smartPoint to the vertex and ray control points, the
    // rays can be manipulated individually.
    //
    // Use only with smartPoints; add the smartPoints first, then:
    //   addMovableAngle({points: [...]});
    //
    // The rays can be controlled to snap on degrees (more useful than snapping
    // on coordinates) by setting snapDegrees to a positive integer.
    //
    // The returned object includes the following properties/methods:
    //
    //   - movableAngle.points
    //         The movableAngle's dynamic smartPoints.
    //
    //   - movableAngle.coords
    //         The movableAngle's current coordinates (generated, don't edit).
    //
    addMovableAngle: function(options) {
        return new MovableAngle(this, options);
    },

    addArrowWidget: function(options) {
        var arrowWidget = $.extend({
            graph: this,
            direction: "up",
            coord: [0, 0],
            onClick: function() {}
        }, options);
        var graph = arrowWidget.graph;

        if (arrowWidget.direction === "up") {
            arrowWidget.visibleShape = graph.path([
                    [arrowWidget.coord[0], arrowWidget.coord[1] - 4 / graph.scale[1]],
                    [arrowWidget.coord[0] - 4 / graph.scale[0], arrowWidget.coord[1] - 4 / graph.scale[1]],
                    [arrowWidget.coord[0], arrowWidget.coord[1] + 4 / graph.scale[1]],
                    [arrowWidget.coord[0] + 4 / graph.scale[0], arrowWidget.coord[1] - 4 / graph.scale[1]],
                    [arrowWidget.coord[0], arrowWidget.coord[1] - 4 / graph.scale[1]]
                    ], { stroke: "", fill: KhanUtil.INTERACTIVE });
        } else if (arrowWidget.direction === "down") {
            arrowWidget.visibleShape = graph.path([
                    [arrowWidget.coord[0], arrowWidget.coord[1] + 4 / graph.scale[1]],
                    [arrowWidget.coord[0] - 4 / graph.scale[0], arrowWidget.coord[1] + 4 / graph.scale[1]],
                    [arrowWidget.coord[0], arrowWidget.coord[1] - 4 / graph.scale[1]],
                    [arrowWidget.coord[0] + 4 / graph.scale[0], arrowWidget.coord[1] + 4 / graph.scale[1]],
                    [arrowWidget.coord[0], arrowWidget.coord[1] + 4 / graph.scale[1]]
                    ], { stroke: "", fill: KhanUtil.INTERACTIVE });
        }

        // You might think we JUST NOW set the style when we drew this. But
        // does IE8 care? No! Of course not! It was too busy being slow and
        // obnoxious. So apparently we have to set the style again, later, when
        // it's paying attention. Or something.
        _.defer(function() {
            arrowWidget.visibleShape.attr({stroke: "", fill: KhanUtil.INTERACTIVE});
        });

        arrowWidget.mouseTarget = graph.mouselayer.circle(
                graph.scalePoint(arrowWidget.coord)[0], graph.scalePoint(arrowWidget.coord)[1], 15);
        arrowWidget.mouseTarget.attr({fill: "#000", "opacity": 0.0});

        $(arrowWidget.mouseTarget[0]).css("cursor", "pointer");
        $(arrowWidget.mouseTarget[0]).bind("vmousedown vmouseover vmouseout", function(event) {
            if (event.type === "vmouseover") {
                arrowWidget.visibleShape.animate({ scale: 2, fill: KhanUtil.INTERACTING }, 20);
            } else if (event.type === "vmouseout") {
                arrowWidget.visibleShape.animate({ scale: 1, fill: KhanUtil.INTERACTING }, 20);
            } else if (event.type === "vmousedown" && (event.which === 1 || event.which === 0)) {
                if (!arrowWidget.hidden) {
                    arrowWidget.onClick();
                }
                return false;
            }
        });

        arrowWidget.hide = function() {
            arrowWidget.visibleShape.hide();
            arrowWidget.hidden = true;
            $(arrowWidget.mouseTarget[0]).css("cursor", "default");
        };

        arrowWidget.show = function() {
            arrowWidget.visibleShape.show();
            arrowWidget.hidden = false;
            $(arrowWidget.mouseTarget[0]).css("cursor", "pointer");
        };

        return arrowWidget;
    },


    addRectGraph: function(options) {
        // settings
        var rect = $.extend(true, {
            x: 0,
            y: 0,
            width: 1,
            height: 1,
            normalStyle: {
                points: {
                    stroke: KhanUtil.INTERACTIVE,
                    fill: KhanUtil.INTERACTIVE,
                    opacity: 1
                },
                edges: {
                    stroke: KhanUtil.INTERACTIVE,
                    opacity: 1,
                    "stroke-width": 1
                },
                area: {
                    fill: KhanUtil.INTERACTIVE,
                    "fill-opacity": 0.1,
                    "stroke-width": 0
                }
            },
            hoverStyle: {
                points: {
                    color: KhanUtil.INTERACTING,
                    opacity: 1,
                    width: 2
                },
                edges: {
                    stroke: KhanUtil.INTERACTING,
                    opacity: 1,
                    "stroke-width": 1
                },
                area: {
                    fill: KhanUtil.INTERACTING,
                    "fill-opacity": 0.2,
                    "stroke-width": 0
                }
            },
            fixed: {
                // if true, users cannot move the edge independently
                edges: [false, false, false, false],

                // if true, users cannot move the point independently
                points: [false, false, false, false]
            },
            constraints: {
                constrainX: false, // limit movement to y axis
                constrainY: false, // limit movement to x axis

                // bounds for translations
                xmin: null,
                xmax: null,
                ymin: null,
                ymax: null
            },
            snapX: 0,
            snapY: 0,

            // this function will be called whenever .translate(), .snap(), or
            // .moveTo() are called
            onMove: function() {}
        }, options);


        // functions
        rect = $.extend({
            initialized: function() {
                return rect.points && rect.points.length;
            },
            x2: function() {
                return this.x + this.width;
            },
            y2: function() {
                return this.y + this.height;
            },
            getX: function() {
                if (rect.initialized()) {
                    return rect.points[0].coord[0];
                }
                return rect.x;
            },
            getY: function() {
                if (rect.initialized()) {
                    return rect.points[0].coord[1];
                }
                return rect.y;
            },
            getX2: function() {
                return rect.getX() + rect.getWidth();
            },
            getY2: function() {
                return rect.getY() + rect.getHeight();
            },
            getXLims: function() {
                var x = rect.getX();
                return [x, x + rect.getWidth()];
            },
            getYLims: function() {
                var y = rect.getY();
                return [y, y + rect.getHeight()];
            },
            getWidth: function() {
                if (rect.initialized()) {
                    var x0 = rect.points[1].coord[0];
                    var x1 = rect.points[2].coord[0];
                    return x1 - x0;
                }
                return rect.width;
            },
            getHeight: function() {
                if (rect.initialized()) {
                    var y0 = rect.points[0].coord[1];
                    var y1 = rect.points[1].coord[1];
                    return y1 - y0;
                }
                return rect.height;
            },
            getCoord: function() {
                return [rect.getX(), rect.getY()];
            },
            getRaphaelParamsArr: function() {
                var width = rect.getWidth();
                var height = rect.getHeight();
                var x = rect.getX();
                var y = rect.getY();
                var point = graphie.scalePoint([x, y + height]);
                var dims = graphie.scaleVector([width, height]);
                return point.concat(dims);
            },
            getRaphaelParams: function() {
                var arr = rect.getRaphaelParamsArr();
                return {
                    x: arr[0],
                    y: arr[1],
                    width: arr[2],
                    height: arr[3]
                };
            }
        }, rect);

        var graphie = this;



        // ADD RECTANGLE AND MOUSE TARGET

        rect.fillArea = graphie.rect().attr(rect.normalStyle.area);
        rect.mouseTarget = graphie.mouselayer.rect()
            .attr({
                fill: "#000",
                opacity: 0,
                "fill-opacity": 0
            });

        rect.render = function() {
            rect.fillArea.attr(rect.getRaphaelParams());
            rect.mouseTarget.attr(rect.getRaphaelParams());
        };

        rect.render(); // initialize



        // ADD POINTS

        rect.points = [];

        var coords = [[rect.x, rect.y], [rect.x, rect.y2()], [rect.x2(), rect.y2()], [rect.x2(), rect.y]];
        var sames = [[1, 3], [0, 2], [3, 1], [2, 0]];
        var moveLimits = [[1, 1], [1, 0], [0, 0], [0, 1]];


        function adjustNeighboringPoints(x, y, sameX, sameY) {
            rect.points[sameX].setCoord([x, rect.points[sameX].coord[1]]);
            rect.points[sameY].setCoord([rect.points[sameY].coord[0], y]);
            rect.points[sameX].updateLineEnds();
            rect.points[sameY].updateLineEnds();
        }

        function coordInBounds(limit, newVal, checkIsGreater) {
            return checkIsGreater ? newVal < limit : newVal > limit;
        }

        function moveIsInBounds(index, newX, newY) {
            var xlims = rect.getXLims();
            var ylims = rect.getYLims();

            var i = moveLimits[index];

            var xInBounds = coordInBounds(xlims[i[0]], newX, i[0] === 1);
            var yInBounds = coordInBounds(ylims[i[1]], newY, i[1] === 1);

            return xInBounds && yInBounds;
        }

        _.times(4, function(i) {
            var sameX = sames[i][0];
            var sameY = sames[i][1];
            var coord = coords[i];

            var point = graphie.addMovablePoint({
                graph: graphie,
                coord: coord,
                normalStyle: rect.normalStyle.points,
                hoverStyle: rect.hoverStyle.points,
                snapX: rect.snapX,
                snapY: rect.snapY,
                visible: !rect.fixed.points[i],
                constraints: {
                    fixed: rect.fixed.points[i]
                },
                onMove: function(x, y) {
                    if (!moveIsInBounds(i, x, y)) {
                        return false;
                    }
                    adjustNeighboringPoints(x, y, sameX, sameY);
                    rect.render();
                }
            });

            rect.points.push(point);
        });



        // ADD EDGES

        rect.edges = [];

        rect.moveEdge = function(dx, dy, edgeIndex) {
            var a = rect.edges[edgeIndex].pointA;
            var z = rect.edges[edgeIndex].pointZ;
            a.setCoord([a.coord[0] + dx, a.coord[1] + dy]);
            z.setCoord([z.coord[0] + dx, z.coord[1] + dy]);
            a.updateLineEnds();
            z.updateLineEnds();
        };

        _.times(4, function(i) {
            var pointA = rect.points[i];
            var pointZ = rect.points[(i + 1) % 4]; // next point
            var constrainX = (i % 2); // odd edges have X constrained
            var constrainY = ((i + 1) % 2); // even edges have Y constrained

            var edge = graphie.addMovableLineSegment({
                graph: graphie,
                pointA: pointA,
                pointZ: pointZ,
                normalStyle: rect.normalStyle.edges,
                hoverStyle: rect.hoverStyle.edges,
                snapX: rect.snapX,
                snapY: rect.snapY,
                fixed: rect.fixed.edges[i],
                constraints: {
                    constrainX: constrainX,
                    constrainY: constrainY
                },
                onMove: function(dx, dy) {
                    rect.moveEdge(dx, dy, i);
                    rect.render();
                }
            });

            rect.edges.push(edge);
        });



        // CREATE COLLECTION OF ALL ELEMENTS (used in toFront)
        var elems = [rect.fillArea, rect.mouseTarget];
        rect.elems = elems.concat(rect.edges).concat(rect.points);



        // MOVING FUNCTIONS

        function constrainTranslation(dx, dy) {
            var xC = rect.constraints.constrainX;
            var xLT = rect.getX() + dx < rect.constraints.xmin;
            var xGT = rect.getX2() + dx > rect.constraints.xmax;
            var yC = rect.constraints.constrainY;
            var yLT = rect.getY() + dy < rect.constraints.ymin;
            var yGT = rect.getY2() + dy > rect.constraints.ymax;

            dx = xC || xLT || xGT ? 0 : dx;
            dy = yC || yLT || yGT ? 0 : dy;

            return [dx, dy];
        }

        rect.translate = function(dx, dy) {
            if (rect.constraints.constrainX && rect.constraints.constrainY) {
                return;
            }
            var d = constrainTranslation(dx, dy);
            dx = d[0];
            dy = d[1];

            _.each(rect.points, function(point, i) {
                var x = point.coord[0] + dx;
                var y = point.coord[1] + dy;
                // move points
                point.setCoord([x, y]);
                // move edges
                point.updateLineEnds();
            });

            // move rectangle & mouseTarget
            rect.render();

            // fire "on move" event with the new xlims and ylims
            rect.onMove(dx, dy);
        };

        rect.moveTo = function(x, y) {
            var dx = x - rect.getX();
            var dy = y - rect.getY();
            rect.translate(dx, dy);
        };

        rect.snap = function() {
            var dx;
            var dy;
            _.each(rect.points, function(point, i) {
                var x0 = point.coord[0];
                var y0 = point.coord[1];
                var x1 = x0;
                var y1 = y0;

                if (rect.snapX) {
                    x1 = KhanUtil.roundToNearest(rect.snapX, x0);
                }
                if (rect.snapY) {
                    y1 = KhanUtil.roundToNearest(rect.snapY, y0);
                }

                if (!dx || !dy) {
                    dx = x1 - x0;
                    dy = y1 - y0;
                }

                // move points
                point.setCoord([x1, y1]);
                // move edges
                point.updateLineEnds();
            });

            // move rectangle & mouseTarget
            rect.render();

            // fire "on move" event with the new xlims and ylims
            rect.onMove(dx, dy);
        };

        // TODO(stephanie): confirm this works
        rect.toFront = function() {
            _.each(rect.elems, function(elem) {
                elem.toFront();
            });
        };

        rect.hide = function(speed) {
            if (rect.hidden) {
                return;
            }

            speed = speed || 100;

            rect.fillArea.animate({
                "fill-opacity": 0
            }, speed);
            $(rect.mouseTarget[0]).css("display", "none");

            rect.hidden = true;
        };

        rect.show = function(speed) {
            if (!rect.hidden) {
                return;
            }

            speed = speed || 100;

            rect.fillArea.animate(rect.normalStyle.area, speed);
            $(rect.mouseTarget[0]).css("display", "block");

            rect.hidden = false;
        };

        rect.enableHoverStyle = function() {
            rect.highlight = true;
            if (!KhanUtil.dragging) {
                rect.fillArea.animate(rect.hoverStyle.area, 100);
            }
        };

        rect.enableNormalStyle = function() {
            rect.highlight = false;
            if (!rect.dragging) {
                rect.fillArea.animate(rect.normalStyle.area, 100);
            }
        };

        // tie actual translation events to the translate function
        var bindTranslation = function() {
            $(rect.mouseTarget[0]).css("cursor", "move");
            $(rect.mouseTarget[0]).on(
                "vmouseover vmouseout vmousedown", function(event) {
                    if (event.type === "vmouseover") {
                        rect.enableHoverStyle();

                    } else if (event.type === "vmouseout") {
                        rect.enableNormalStyle();

                    } else if (event.type === "vmousedown" &&
                            (event.which === 1 || event.which === 0)) {
                        event.preventDefault();
                        rect.toFront();
                        rect.prevCoord = graphie.getMouseCoord(event);

                        rect.enableHoverStyle();

                        $(document).on("vmousemove vmouseup", function(event) {
                            event.preventDefault();
                            rect.dragging = true;
                            KhanUtil.dragging = true;

                            if (event.type === "vmousemove") {
                                var currCoord = graphie.getMouseCoord(event);

                                if (rect.prevCoord && rect.prevCoord.length === 2) {
                                    var diff = KhanUtil.coordDiff(rect.prevCoord, currCoord);
                                    rect.translate(diff[0], diff[1]);
                                }

                                rect.prevCoord = currCoord;

                            } else if (event.type === "vmouseup") {
                                $(document).off("vmousemove vmouseup");
                                rect.dragging = false;
                                KhanUtil.dragging = false;

                                var currCoord = graphie.getMouseCoord(event);
                                if (currCoord[0] < rect.getX() ||
                                    currCoord[0] > rect.getX2() ||
                                    currCoord[1] < rect.getY() ||
                                    currCoord[1] > rect.getY2()) {
                                        rect.enableNormalStyle();
                                }

                                // snap to grid
                                rect.snap();
                            }
                        });
                    }
            });
        };

        bindTranslation();

        return rect;
    },

    // center: movable point
    // radius: int
    // circ: graphie circle
    // perim: invisible mouse target for dragging/changing radius
    addCircleGraph: function(options) {
        var graphie = this;
        var circle = $.extend({
            center: [0, 0],
            radius: 2,
            snapX: 0.5,
            snapY: 0.5,
            snapRadius: 0.5,
            minRadius: 1,
            centerConstraints: {},
            centerNormalStyle: {},
            centerHighlightStyle: {
                stroke: KhanUtil.INTERACTING,
                fill: KhanUtil.INTERACTING
            },
            circleNormalStyle: {
                stroke: KhanUtil.INTERACTIVE,
                "fill-opacity": 0
            },
            circleHighlightStyle: {
                stroke: KhanUtil.INTERACTING,
                fill: KhanUtil.INTERACTING,
                "fill-opacity": 0.05
            }
        }, options);

        // Set normal styling based on interactability
        var normalColor = (circle.centerConstraints.fixed) ?
                                  KhanUtil.DYNAMIC
                                : KhanUtil.INTERACTIVE;
        var centerNormalStyle = (options) ? options.centerNormalStyle : null;
        circle.centerNormalStyle = _.extend({}, {
            "fill": normalColor,
            "stroke": normalColor
        }, centerNormalStyle);

        circle.centerPoint = graphie.addMovablePoint({
            graph: graphie,
            coord: circle.center,
            normalStyle: circle.centerNormalStyle,
            snapX: circle.snapX,
            snapY: circle.snapY,
            constraints: circle.centerConstraints
        });
        circle.circ = graphie.circle(circle.center, circle.radius,
                circle.circleNormalStyle);
        circle.perim = graphie.mouselayer.circle(
            graphie.scalePoint(circle.center)[0],
            graphie.scalePoint(circle.center)[1],
            graphie.scaleVector(circle.radius)[0]).attr({
                "stroke-width": 20,
                "opacity": 0.002  // This is as close to 0 as MSIE will allow
            });

        // Highlight circle circumference on center point hover
        if (!circle.centerConstraints.fixed) {
            $(circle.centerPoint.mouseTarget[0]).on("vmouseover vmouseout",
                    function(event) {
                if (circle.centerPoint.highlight ||
                        circle.centerPoint.dragging) {
                    circle.circ.animate(circle.circleHighlightStyle, 50);
                } else {
                    circle.circ.animate(circle.circleNormalStyle, 50);
                }
            });
        }

        circle.toFront = function() {
            circle.circ.toFront();
            circle.perim.toFront();
            circle.centerPoint.visibleShape.toFront();
            if (!circle.centerConstraints.fixed) {
                circle.centerPoint.mouseTarget.toFront();
            }
        };

        circle.centerPoint.onMove = function(x, y) {
            circle.toFront();
            circle.circ.attr({
                cx: graphie.scalePoint(x)[0],
                cy: graphie.scalePoint(y)[1]
            });
            circle.perim.attr({
                cx: graphie.scalePoint(x)[0],
                cy: graphie.scalePoint(y)[1]
            });
            if (circle.onMove) {
                circle.onMove(x, y);
            }
        };

        $(circle.centerPoint).on("move", function() {
            circle.center = this.coord;
            $(circle).trigger("move");
        });

        // circle.setCenter(x, y) moves the circle to the specified
        // x, y coordinate as if the user had dragged it there.
        circle.setCenter = function(x, y) {
            circle.centerPoint.setCoord([x, y]);
            circle.centerPoint.onMove(x, y);
            circle.center = [x, y];
        };

        // circle.setRadius(r) sets the circle's radius to the specified
        // value as if the user had dragged it there.
        circle.setRadius = function(r) {
            circle.radius = r;

            circle.perim.attr({
                r: graphie.scaleVector(r)[0]
            });
            circle.circ.attr({
                rx: graphie.scaleVector(r)[0],
                ry: graphie.scaleVector(r)[1]
            });
        };

        circle.remove = function() {
            circle.centerPoint.remove();
            circle.circ.remove();
            circle.perim.remove();
        };

        $(circle.perim[0]).css("cursor", "move");
        $(circle.perim[0]).on(
            "vmouseover vmouseout vmousedown", function(event) {
                if (event.type === "vmouseover") {
                    circle.highlight = true;
                    if (!KhanUtil.dragging) {
                        // TODO(jack): Figure out why this doesn't work
                        // for circleHighlightStyle's that change
                        // stroke-dasharray
                        circle.circ.animate(circle.circleHighlightStyle, 50);
                        circle.centerPoint.visibleShape.animate(
                            circle.centerHighlightStyle,
                            50
                        );
                    }

                } else if (event.type === "vmouseout") {
                    circle.highlight = false;
                    if (!circle.dragging && !circle.centerPoint.dragging) {
                        circle.circ.animate(circle.circleNormalStyle, 50);
                        circle.centerPoint.visibleShape.animate(
                            circle.centerNormalStyle,
                            50
                        );
                    }

                } else if (event.type === "vmousedown" &&
                        (event.which === 1 || event.which === 0)) {
                    event.preventDefault();
                    circle.toFront();
                    var startRadius = circle.radius;

                    $(document).on("vmousemove vmouseup", function(event) {
                        event.preventDefault();
                        circle.dragging = true;
                        KhanUtil.dragging = true;

                        if (event.type === "vmousemove") {
                            // can't go beyond 10 pixels from the edge
                            // coord is the scaled coordinate
                            var coord = graphie.constrainToBounds(
                                graphie.getMouseCoord(event), 10);

                            var radius = KhanUtil.getDistance(
                                circle.centerPoint.coord, coord);
                            radius = Math.max(circle.minRadius,
                                Math.round(radius / circle.snapRadius) *
                                circle.snapRadius);
                            var oldRadius = circle.radius;
                            var doResize = true;
                            if (circle.onResize) {
                                var onResizeResult = circle.onResize(radius, oldRadius);
                                if (_.isNumber(onResizeResult)) {
                                    radius = onResizeResult;
                                } else if (onResizeResult === false) {
                                    doResize = false;
                                }
                            }
                            if (doResize) {
                                circle.setRadius(radius);
                                $(circle).trigger("move");
                            }
                        } else if (event.type === "vmouseup") {
                            $(document).off("vmousemove vmouseup");
                            circle.dragging = false;
                            KhanUtil.dragging = false;
                            if (circle.onResizeEnd) {
                                circle.onResizeEnd(circle.radius, startRadius);
                            }
                        }
                    });
                }
        });

        return circle;
    },

    interactiveEllipse: function(options) {
        var graphie = this;
        var ellipse = $.extend({
            center: [0, 0],
            radius: 2,
            xRadius: 2,
            yRadius: 2,
            ellipseNormalStyle: {
                stroke: KhanUtil.INTERACTIVE,
                "fill-opacity": 0
            },
            ellipseBoundaryHideStyle: {
                "fill-opacity": 0,
                "stroke-width": 0
            },
            ellipseBoundaryShowStyle: {
                "fill-opacity": 1,
                fill: KhanUtil.INTERACTIVE
            },
            onMove: function(coordX, coordY) { /* Here to be overriden */ },
            onLeave: function(coordX, coordY) { /* Here to be overriden */ }
        }, options);

        ellipse.circ = graphie.ellipse(ellipse.center, [ellipse.xRadius, ellipse.yRadius], ellipse.ellipseNormalStyle);
        ellipse.perim = graphie.mouselayer.ellipse(
            graphie.scalePoint(ellipse.center)[0],
            graphie.scalePoint(ellipse.center)[1],
            graphie.scaleVector(ellipse.xRadius)[0],
            graphie.scaleVector(ellipse.yRadius)[0]).attr({
                "stroke-width": 30,
                "opacity": 0.002  // This is as close to 0 as MSIE will allow
        });

        ellipse.boundaryPoint = graphie.circle(ellipse.center, 0.4, ellipse.ellipseBoundaryHideStyle);

        ellipse.remove = function() {
            ellipse.circ.remove();
            ellipse.perim.remove();
        };

        ellipse.showPoint = function(event) {
            // Fix to ellipse boundary by finding angle and adjusting the radius
            var coord = graphie.constrainToBounds(graphie.getMouseCoord(event), 10);
            var dx = ellipse.yRadius * (ellipse.center[0] - coord[0]);
            var dy = ellipse.xRadius * (ellipse.center[1] - coord[1]);
            var angle = Math.atan2(dy, dx);

            coord[0] = ellipse.center[0] - ellipse.xRadius * Math.cos(angle);
            coord[1] = ellipse.center[1] - ellipse.yRadius * Math.sin(angle);

            var scaledPoint = graphie.scalePoint(coord);
            ellipse.boundaryPoint.attr({ cx: scaledPoint[0] });
            ellipse.boundaryPoint.attr({ cy: scaledPoint[1] });
            ellipse.boundaryPoint.animate(ellipse.ellipseBoundaryShowStyle, 50);

            ellipse.onMove(coord[0], coord[1]);
        };

        $(ellipse.perim[0]).on(
            "vmouseover vmouseout vmousemove", function(event) {
                if (event.type === "vmouseover") {
                    ellipse.showPoint(event);
                } else if (event.type === "vmouseout") {
                    ellipse.boundaryPoint.animate(ellipse.ellipseBoundaryHideStyle, 50);
                    ellipse.onLeave();
                } else if (event.type === "vmousemove") {
                    ellipse.showPoint(event);
                }
        });

        return ellipse;
    },

    addRotateHandle: (function() {
        var drawRotateHandle = function(graphie, center, radius, halfWidth,
                lengthAngle, angle, interacting) {
            // Get a point on the arrow, given an angle offset and a distance
            // from the "midline" of the arrow (ROTATE_HANDLE_DIST away from
            // the rotation point).
            var getRotateHandlePoint = function(offset,
                    distanceFromArrowMidline) {
                var distFromRotationCenter = radius + distanceFromArrowMidline;
                var vec = KhanUtil.kvector.cartFromPolarDeg([
                    distFromRotationCenter,
                    angle + offset
                ]);
                var absolute = KhanUtil.kvector.add(center, vec);
                var pixels = graphie.scalePoint(absolute);
                return pixels[0] + "," + pixels[1];
            };

            // Inner and outer radii for the curved part of the arrow
            var innerR = graphie.scaleVector(radius - halfWidth);
            var outerR = graphie.scaleVector(radius + halfWidth);

            // Draw the double-headed arrow thing that shows users where to
            // click and drag to rotate
            return graphie.raphael.path(
                // upper arrowhead
                " M" + getRotateHandlePoint(lengthAngle, -halfWidth) +
                " L" + getRotateHandlePoint(lengthAngle, -3 * halfWidth) +
                " L" + getRotateHandlePoint(2 * lengthAngle, 0) +
                " L" + getRotateHandlePoint(lengthAngle, 3 * halfWidth) +
                " L" + getRotateHandlePoint(lengthAngle, halfWidth) +
                // outer arc
                " A" + outerR[0] + "," + outerR[1] + ",0,0,1," +
                    getRotateHandlePoint(-lengthAngle, halfWidth) +
                // lower arrowhead
                " L" + getRotateHandlePoint(-lengthAngle, 3 * halfWidth) +
                " L" + getRotateHandlePoint(-2 * lengthAngle, 0) +
                " L" + getRotateHandlePoint(-lengthAngle, -3 * halfWidth) +
                " L" + getRotateHandlePoint(-lengthAngle, -halfWidth) +
                // inner arc
                " A" + innerR[0] + "," + innerR[1] + ",0,0,0," +
                    getRotateHandlePoint(lengthAngle, -halfWidth) +
                " Z"
            ).attr({
                stroke: null,
                fill: (interacting) ? KhanUtil.INTERACTING
                                    : KhanUtil.INTERACTIVE
            });
        };

        return function(options) {
            var graph = this;

            var rotatePoint = options.center;
            var radius = options.radius;
            var lengthAngle = options.lengthAngle || 30;
            var hideArrow = options.hideArrow || false;
            var mouseTarget = options.mouseTarget;
            var id = _.uniqueId("rotateHandle");

            // Normalize rotatePoint into something that always looks
            // like a movablePoint
            if (_.isArray(rotatePoint)) {
                rotatePoint = {
                    coord: rotatePoint
                };
            }

            var rotateHandle = graph.addMovablePoint({
                coord: KhanUtil.kpoint.addVector(
                    rotatePoint.coord,
                    KhanUtil.kvector.cartFromPolarDeg(
                        radius,
                        options.angleDeg || 0
                )),
                constraints: {
                    fixedDistance: {
                        dist: radius,
                        point: rotatePoint
                    }
                },
                mouseTarget: mouseTarget
            });

            // move the rotatePoint in front of the rotateHandle to avoid
            // confusing clicking/scaling of the rotateHandle when the user
            // intends to click on the rotatePoint
            rotatePoint.toFront();

            // The logic below in onMove handlers is to make sure we
            // move rotateHandle with rotatePoint
            var rotatePointPrevCoord = rotatePoint.coord;
            var rotateHandlePrevCoord = rotateHandle.coord;
            var rotateHandleStartCoord = rotateHandlePrevCoord;
            var isRotating = false;
            var isHovering = false;
            var drawnRotateHandle;

            var redrawRotateHandle = function(handleCoord) {
                if (hideArrow) {
                    return; // Don't draw anything!
                }

                var handleVec = KhanUtil.kvector.subtract(handleCoord,
                        rotatePoint.coord);
                var handlePolar = KhanUtil.kvector.polarDegFromCart(handleVec);
                var angle = handlePolar[1];

                if (drawnRotateHandle) {
                    drawnRotateHandle.remove();
                }

                drawnRotateHandle = drawRotateHandle(
                    graph,
                    rotatePoint.coord,
                    options.radius,
                    (isRotating || isHovering ?
                        options.hoverWidth / 2 :
                        options.width / 2
                    ),
                    lengthAngle,
                    angle,
                    isRotating || isHovering
                );
            };


            // when the rotation center moves, we need to move
            // the rotationHandle as well, or it will end up out
            // of sync
            $(rotatePoint).on("move." + id, function() {
                var delta = KhanUtil.kvector.subtract(
                    rotatePoint.coord,
                    rotatePointPrevCoord
                );

                rotateHandle.setCoord(KhanUtil.kvector.add(
                    rotateHandle.coord,
                    delta
                ));

                redrawRotateHandle(rotateHandle.coord);

                rotatePointPrevCoord = rotatePoint.coord;
                rotateHandle.constraints.fixedDistance.point = rotatePoint;
                rotateHandlePrevCoord = rotateHandle.coord;
            });

            // Rotate polygon with rotateHandle
            rotateHandle.onMove = function(x, y) {
                if (!isRotating) {
                    rotateHandleStartCoord = rotateHandlePrevCoord;
                    isRotating = true;
                }

                var coord = [x, y];

                if (options.onMove) {
                    var oldPolar = KhanUtil.kvector.polarDegFromCart(
                        KhanUtil.kvector.subtract(
                            rotateHandlePrevCoord,
                            rotatePoint.coord
                        )
                    );
                    var newPolar = KhanUtil.kvector.polarDegFromCart(
                        KhanUtil.kvector.subtract(coord, rotatePoint.coord)
                    );

                    var oldAngle = oldPolar[1];
                    var newAngle = newPolar[1];
                    var result = options.onMove(newAngle, oldAngle);
                    if (result != null && result !== true) {
                        if (result === false) {
                            result = oldAngle;
                        }
                        coord = KhanUtil.kvector.add(
                            rotatePoint.coord,
                            KhanUtil.kvector.cartFromPolarDeg(
                                [oldPolar[0], result]
                            )
                        );
                    }
                }

                redrawRotateHandle(coord);

                rotateHandlePrevCoord = coord;
                return coord;
            };

            rotateHandle.onMoveEnd = function() {
                isRotating = false;
                redrawRotateHandle(rotateHandle.coord);
                if (options.onMoveEnd) {
                    var oldPolar = KhanUtil.kvector.polarDegFromCart(
                        KhanUtil.kvector.subtract(
                            rotateHandleStartCoord,
                            rotatePoint.coord
                        )
                    );
                    var newPolar = KhanUtil.kvector.polarDegFromCart(
                        KhanUtil.kvector.subtract(
                            rotateHandle.coord,
                            rotatePoint.coord
                        )
                    );
                    options.onMoveEnd(newPolar[1], oldPolar[1]);
                }
            };

            // Remove the default dot added by the movablePoint since we have
            // our double-arrow thing
            rotateHandle.visibleShape.remove();

            if (!mouseTarget) {
                // Make the default mouse target bigger to encompass the whole
                // area around the double-arrow thing
                rotateHandle.mouseTarget.attr({scale: 2});
            }

            // Make the arrow-thing grow and shrink with mouseover/out
            $(rotateHandle.mouseTarget[0]).bind("vmouseover", function(e) {
                isHovering = true;
                redrawRotateHandle(rotateHandle.coord);
            });
            $(rotateHandle.mouseTarget[0]).bind("vmouseout", function(e) {
                isHovering = false;
                redrawRotateHandle(rotateHandle.coord);
            });

            redrawRotateHandle(rotateHandle.coord);

            var oldRemove = rotateHandle.remove;
            rotateHandle.remove = function() {
                oldRemove.call(rotateHandle);
                if (drawnRotateHandle) {
                    drawnRotateHandle.remove();
                }
                $(rotatePoint).off("move." + id);
            };

            rotateHandle.update = function() {
                redrawRotateHandle(rotateHandle.coord);
            };

            return rotateHandle;
        };
    })(),

    addReflectButton: (function() {
        var drawButton = function(
                graphie,
                buttonCoord,
                lineCoords,
                size,
                distanceFromCenter,
                leftStyle,
                rightStyle) {

            // Avoid invalid lines
            if (kpoint.equal(lineCoords[0], lineCoords[1])) {
                lineCoords = [
                    lineCoords[0],
                    kpoint.addVector(lineCoords[0], [1, 1])
                ];
            }

            var lineDirection = kvector.normalize(
                kvector.subtract(lineCoords[1], lineCoords[0])
            );

            var lineVec = kvector.scale(
                lineDirection,
                size/2
            );

            // Calculate the offset the center points should be placed at
            var centerVec = kvector.scale(lineDirection, distanceFromCenter);
            var leftCenterVec = kvector.rotateDeg(centerVec, 90);
            var rightCenterVec = kvector.rotateDeg(centerVec, -90);

            // Calculate the offsets for the far points
            var negLineVec = kvector.negate(lineVec);
            var leftVec = kvector.rotateDeg(lineVec, 90);
            var rightVec = kvector.rotateDeg(lineVec, -90);

            // Calculate the center point locations
            var leftCenter = kpoint.addVectors(buttonCoord, leftCenterVec);
            var rightCenter = kpoint.addVectors(buttonCoord, rightCenterVec);

            // Calculate the far point locations
            var leftCoord1 = kpoint.addVectors(buttonCoord, leftCenterVec, lineVec, leftVec);
            var leftCoord2 = kpoint.addVectors(buttonCoord, leftCenterVec, negLineVec, leftVec);
            var rightCoord1 = kpoint.addVectors(buttonCoord, rightCenterVec, lineVec, rightVec);
            var rightCoord2 = kpoint.addVectors(buttonCoord, rightCenterVec, negLineVec, rightVec);

            var leftButton = graphie.path(
                [leftCenter, leftCoord1, leftCoord2, true],
                leftStyle
            );
            var rightButton = graphie.path(
                [rightCenter, rightCoord1, rightCoord2, true],
                rightStyle
            );

            return {
                remove: function() {
                    leftButton.remove();
                    rightButton.remove();
                }
            };
        };

        return function(options) {
            var graphie = this;

            var line = options.line;

            var button = graphie.addMovablePoint({
                constraints: options.constraints,
                coord: kline.midpoint([
                    line.pointA.coord,
                    line.pointZ.coord
                ]),
                snapX: graphie.snap[0],
                snapY: graphie.snap[1],
                onMove: function(x, y) {
                    // Don't allow the button to actually move. This is a hack
                    // around the inability to both set a point as fixed AND
                    // allow it to be clicked.
                    return false;
                },
                onMoveEnd: function(x, y) {
                    if (options.onMoveEnd) {
                        options.onMoveEnd.call(this, x, y);
                    }
                }
            });

            var isHovering = false;
            var isFlipped = false;
            var currentlyDrawnButton;

            var isHighlight = function() {
                return isHovering;
            };

            var styles = _.map([0, 1], function(isHighlight) {
                var baseStyle = isHighlight ?
                        options.highlightStyle :
                        options.normalStyle;

                return _.map([0, 1], function(opacity) {
                    return _.defaults({
                        "fill-opacity": opacity
                    }, baseStyle);
                });
            });

            var getStyle = function(isRight) {
                if (isFlipped) {
                    isRight = !isRight;
                }
                return styles[+isHighlight()][+isRight];
            };

            var redraw = function(coord, lineCoords) {
                if (currentlyDrawnButton) {
                    currentlyDrawnButton.remove();
                }
                currentlyDrawnButton = drawButton(
                    graphie,
                    coord,
                    lineCoords,
                    isHighlight() ? options.size * 1.5 : options.size,
                    isHighlight() ? options.size * 0.125 : 0.25,
                    getStyle(0),
                    getStyle(1)
                );
            };

            // Keep the button's position in-sync with the line
            var update = function(coordA, coordZ) {
                coordA = coordA || line.pointA.coord;
                coordZ = coordZ || line.pointZ.coord;

                var buttonCoord = kline.midpoint([coordA, coordZ]);
                button.setCoord(buttonCoord);

                redraw(buttonCoord, [coordA, coordZ]);
            };

            $(line).on("move", _.bind(update, button, null, null));

            // Add click handling
            $(button.mouseTarget[0]).on("vclick", function() {
                var result = options.onClick();
                if (result !== false) {
                    isFlipped = !isFlipped;
                    redraw(button.coord,
                        [line.pointA.coord, line.pointZ.coord]);
                }
            });

            // Bring the reflection line handles in front of the button, so
            // that if we drag the reflectPoints really close together, we can
            // still move the handles away from each other, rather than only
            // being able to apply the reflection.
            line.pointA.toFront();
            line.pointZ.toFront();

            // Replace the visual point with the double triangle thing
            button.visibleShape.remove();
            // Resize the hidden point to cover the size of the visual point
            var pointScale = graphie.scaleVector(options.size)[0] / 20;
            button.mouseTarget.attr({scale: 1.5 * pointScale});
            $(button.mouseTarget[0]).css("cursor", "pointer");

            // Make the arrow-thing grow and shrink with mouseover/out
            $(button.mouseTarget[0]).bind("vmouseover", function(e) {
                isHovering = true;
                redraw(button.coord, [line.pointA.coord, line.pointZ.coord]);
            });
            $(button.mouseTarget[0]).bind("vmouseout", function(e) {
                isHovering = false;
                redraw(button.coord, [line.pointA.coord, line.pointZ.coord]);
            });

            var oldButtonRemove = button.remove;
            button.remove = function() {
                currentlyDrawnButton.remove();
                oldButtonRemove.call(button);
            };

            button.update = update;
            button.isFlipped = function() {
                return isFlipped;
            };

            update();
            return button;
        };
    })(),

    protractor: function(center) {
        return new Protractor(this, center);
    },

    ruler: function(options) {
        return new Ruler(this, options || {});
    },

    addPoints: addPoints
});


function Protractor(graph, center) {
    this.set = graph.raphael.set();

    this.cx = center[0];
    this.cy = center[1];
    var pro = this;

    var r = graph.unscaleVector(180.5)[0];
    var imgPos = graph.scalePoint([this.cx - r, this.cy + r - graph.unscaleVector(10.5)[1]]);
    this.set.push(graph.mouselayer.image(
            "https://ka-perseus-graphie.s3.amazonaws.com/e9d032f2ab8b95979f674fbfa67056442ba1ff6a.png",
            imgPos[0], imgPos[1], 360, 180));


    // Customized polar coordinate thingie to make it easier to draw the double-headed arrow thing.
    // angle is what you'd expect -- use that big protractor on your screen :)
    // pixels from edge is relative to the edge of the protractor; it's not the full radius
    var arrowHelper = function(angle, pixelsFromEdge) {
        var scaledRadius = graph.scaleVector(r);
        scaledRadius[0] -= 16;
        scaledRadius[1] -= 16;
        var scaledCenter = graph.scalePoint(center);
        var x = Math.sin((angle + 90) * Math.PI / 180) * (scaledRadius[0] + pixelsFromEdge) + scaledCenter[0];
        var y = Math.cos((angle + 90) * Math.PI / 180) * (scaledRadius[1] + pixelsFromEdge) + scaledCenter[1];
        return x + "," + y;
    };

    // Draw the double-headed arrow thing that shows users where to click and drag to rotate
    var arrow = graph.raphael.path(
        " M" + arrowHelper(180, 6) +
        " L" + arrowHelper(180, 2) +
        " L" + arrowHelper(183, 10) +
        " L" + arrowHelper(180, 18) +
        " L" + arrowHelper(180, 14) +
        " A" + (graph.scaleVector(r)[0] + 10) + "," + (graph.scaleVector(r)[1] + 10) + ",0,0,1," + arrowHelper(170, 14) +
        " L" + arrowHelper(170, 18) +
        " L" + arrowHelper(167, 10) +
        " L" + arrowHelper(170, 2) +
        " L" + arrowHelper(170, 6) +
        " A" + (graph.scaleVector(r)[0] + 10) + "," + (graph.scaleVector(r)[1] + 10) + ",0,0,0," + arrowHelper(180, 6) +
        " Z"
    ).attr({
        "stroke": null,
        "fill": KhanUtil.INTERACTIVE
    });

    // add it to the set so it translates with everything else
    this.set.push(arrow);

    this.centerPoint = graph.addMovablePoint({
        coord: center,
        visible: false
    });

    // Use a movablePoint for rotation
    this.rotateHandle = graph.addMovablePoint({
        coord: [
            Math.sin(275 * Math.PI / 180) * (r + 0.5) + this.cx,
            Math.cos(275 * Math.PI / 180) * (r + 0.5) + this.cy
        ],
        onMove: function(x, y) {
            var angle = Math.atan2(pro.centerPoint.coord[1] - y, pro.centerPoint.coord[0] - x) * 180 / Math.PI;
            pro.rotate(-angle - 5, true);
        }
    });

    // Add a constraint so the point moves in a circle
    this.rotateHandle.constraints.fixedDistance.dist = r + 0.5;
    this.rotateHandle.constraints.fixedDistance.point = this.centerPoint;

    // Remove the default dot added by the movablePoint since we have our double-arrow thing
    this.rotateHandle.visibleShape.remove();
    // Make the mouse target bigger to encompass the whole area around the double-arrow thing
    this.rotateHandle.mouseTarget.attr({ scale: 2.0 });

    // Make the arrow-thing grow and shrink with mouseover/out
    var isDragging = false;
    var isHovering = false;
    var isHighlight = function() {
        return isHovering || isDragging;
    };

    var self = this;
    $(self.rotateHandle.mouseTarget[0]).bind("vmousedown", function(event) {
        isDragging = true;
        arrow.animate({ scale: 1.5, fill: KhanUtil.INTERACTING }, 50);

        $(document).bind("vmouseup.rotateHandle", function(event) {
            isDragging = false;

            if (!isHighlight()) {
                arrow.animate({ scale: 1.0, fill: KhanUtil.INTERACTIVE }, 50);
            }

            $(document).unbind("vmouseup.rotateHandle");
        });
    });

    $(self.rotateHandle.mouseTarget[0]).bind("vmouseover", function(event) {
        isHovering = true;
        arrow.animate({ scale: 1.5, fill: KhanUtil.INTERACTING }, 50);
    });
    $(self.rotateHandle.mouseTarget[0]).bind("vmouseout", function(event) {
        isHovering = false;
        if (!isHighlight()) {
            arrow.animate({ scale: 1.0, fill: KhanUtil.INTERACTIVE }, 50);
        }
    });

    var setNodes = $.map(this.set, function(el) { return el.node; });
    this.makeTranslatable = function makeTranslatable() {
        $(setNodes).css("cursor", "move");

        $(setNodes).bind("vmousedown", function(event) {
            event.preventDefault();
            var startx = event.pageX - $(graph.raphael.canvas.parentNode).offset().left;
            var starty = event.pageY - $(graph.raphael.canvas.parentNode).offset().top;

            $(document).bind("vmousemove.protractor", function(event) {
                // mouse{X|Y} are in pixels relative to the SVG
                var mouseX = event.pageX - $(graph.raphael.canvas.parentNode).offset().left;
                var mouseY = event.pageY - $(graph.raphael.canvas.parentNode).offset().top;
                // can't go beyond 10 pixels from the edge
                mouseX = Math.max(10, Math.min(graph.xpixels - 10, mouseX));
                mouseY = Math.max(10, Math.min(graph.ypixels - 10, mouseY));

                var dx = mouseX - startx;
                var dy = mouseY - starty;

                $.each(pro.set.items, function() {
                    this.translate(dx, dy);
                });
                pro.centerPoint.setCoord([pro.centerPoint.coord[0] + dx / graph.scale[0], pro.centerPoint.coord[1] - dy / graph.scale[1]]);
                pro.rotateHandle.setCoord([pro.rotateHandle.coord[0] + dx / graph.scale[0], pro.rotateHandle.coord[1] - dy / graph.scale[1]]);
                startx = mouseX;
                starty = mouseY;
            });

            $(document).one("vmouseup", function(event) {
                $(document).unbind("vmousemove.protractor");
            });
        });
    };


    this.rotation = 0;

    this.rotate = function(offset, absolute) {
        var center = graph.scalePoint(this.centerPoint.coord);

        if (absolute) {
            this.rotation = 0;
        }

        this.set.rotate(this.rotation + offset, center[0], center[1]);
        this.rotation = this.rotation + offset;

        return this;
    };

    this.moveTo = function moveTo(x, y) {
        var start = graph.scalePoint(pro.centerPoint.coord);
        var end = graph.scalePoint([x, y]);
        var time = KhanUtil.getDistance(start, end) * 2;  // 2ms per pixel

        $({ x: start[0], y: start[1] }).animate({ x: end[0], y: end[1] }, {
            duration: time,
            step: function(now, fx) {
                var dx = 0;
                var dy = 0;
                if (fx.prop === "x") {
                    dx = now - graph.scalePoint(pro.centerPoint.coord)[0];
                } else if (fx.prop === "y") {
                    dy = now - graph.scalePoint(pro.centerPoint.coord)[1];
                }
                $.each(pro.set.items, function() {
                    this.translate(dx, dy);
                });
                pro.centerPoint.setCoord([pro.centerPoint.coord[0] + dx / graph.scale[0], pro.centerPoint.coord[1] - dy / graph.scale[1]]);
                pro.rotateHandle.setCoord([pro.rotateHandle.coord[0] + dx / graph.scale[0], pro.rotateHandle.coord[1] - dy / graph.scale[1]]);
            }
        });
    };

    this.rotateTo = function rotateTo(angle) {
        if (Math.abs(this.rotation - angle) > 180) {
            this.rotation += 360;
        }
        var time = Math.abs(this.rotation - angle) * 5;  // 5ms per deg
        $({ 0: this.rotation }).animate({ 0: angle }, {
            duration: time,
            step: function(now, fx) {
                pro.rotate(now, true);
                pro.rotateHandle.setCoord([
                    Math.sin((now + 275) * Math.PI / 180) * (r + 0.5) + pro.centerPoint.coord[0],
                    Math.cos((now + 275) * Math.PI / 180) * (r + 0.5) + pro.centerPoint.coord[1]
                ]);
            }
        });
    };

    this.remove = function() {
        this.set.remove();
    };

    this.makeTranslatable();
    return this;
}

function Ruler(graphie, options) {
    _.defaults(options, {
        center: [0, 0],
        pixelsPerUnit: 40,
        ticksPerUnit: 10,   // 10 or power of 2
        units: 10,          // the length the ruler can measure
        label: "",          // e.g "cm" (the shorter, the better)
        style: {
            fill: null,
            stroke: KhanUtil.GRAY
        }
    });

    var light = _.extend({}, options.style, {strokeWidth: 1});
    var bold  = _.extend({}, options.style, {strokeWidth: 2});

    // Ruler dimensions in pixels
    var width = options.units * options.pixelsPerUnit;
    var height = 50;        // arbitrary, but looks good

    // Bottom left corner of the ruler in graphie units
    var leftBottom = graphie.unscalePoint(
        kvector.subtract(
            graphie.scalePoint(options.center),
            kvector.scale([width, -height], 0.5)
        )
    );

    var graphieUnitsPerUnit = options.pixelsPerUnit / graphie.scale[0];
    var graphieUnitsHeight = height / graphie.scale[0];

    // Top right corner of the ruler in graphie units
    var rightTop = kvector.add(
        leftBottom,
        [options.units * graphieUnitsPerUnit, graphieUnitsHeight]
    );

    var tickHeight = 1.0;   // percent of ruler height
    var tickHeightMap;      // mapping of tick frequency to tick height
                            // {n: h} means every n-th tick will have height h

    if (options.ticksPerUnit === 10) {
        // decimal, as on a centimeter ruler
        tickHeightMap = {
            10: tickHeight,
            5:  tickHeight * 0.55,
            1:  tickHeight * 0.35
        };
    } else {
        // powers of 2, as on an inch ruler
        var sizes = [1, 0.6, 0.45, 0.3];

        tickHeightMap = {};
        for (var i = options.ticksPerUnit; i >= 1; i /= 2) {
            tickHeightMap[i] = tickHeight * (sizes.shift() || 0.2);
        }
    }

    var tickFrequencies = _.keys(tickHeightMap).sort(function(a, b) {
        return b - a;
    });

    function getTickHeight(i) {
        for (var k = 0; k < tickFrequencies.length; k++) {
            var key = tickFrequencies[k];
            if (i % key === 0) {
                return tickHeightMap[key];
            }
        }
    }

    // Draw the ruler
    var left = leftBottom[0];
    var bottom = leftBottom[1];
    var right = rightTop[0];
    var top = rightTop[1];

    var numTicks = options.units * options.ticksPerUnit + 1;

    var set = graphie.raphael.set();

    var px = 1 / graphie.scale[0]; // one pixel
    set.push(graphie.line([left - px, bottom], [right + px, bottom], bold));
    set.push(graphie.line([left - px, top], [right + px, top], bold));

    _.times(numTicks, function(i) {
        var n = i / options.ticksPerUnit;
        var x = left + n * graphieUnitsPerUnit;
        var height = getTickHeight(i) * graphieUnitsHeight;

        var style = (i === 0 || i === numTicks - 1) ? bold : light;
        set.push(graphie.line([x, bottom], [x, bottom + height], style));

        if (n % 1 === 0) {
            // Graphie labels are difficult to rotate in IE8,
            // so use raphael.text() instead
            var coord = graphie.scalePoint([x, top]);
            var text;
            var offset;

            if (n === 0) {
                // Unit label
                text = options.label;
                offset = {
                    mm: 13,
                    cm: 11,
                    m: 8,
                    km: 11,
                    in: 8,
                    ft: 8,
                    yd: 10,
                    mi: 10
                }[text] || (3 * text.toString().length);
            } else {
                // Tick label
                text = n;
                offset = -3 * (n.toString().length + 1);
            }
            var label = graphie.raphael.text(
                coord[0] + offset,
                coord[1] + 10,
                text
            );
            label.attr({
                "font-family": "katex_main",
                "font-size": "12px",
                "color": "#444"
            });
            set.push(label);
        }
    });

    // Add a mouse target
    var mouseTarget = graphie.mouselayer.path(KhanUtil.svgPath([
        leftBottom, [left, top], rightTop, [right, bottom], /* closed */ true
    ]));
    mouseTarget.attr({
        fill: "#000",
        opacity: 0,
        stroke: "#000",
        "stroke-width": 2
    });
    set.push(mouseTarget);

    var setNodes = $.map(set, function(el) { return el.node; });
    $(setNodes).css("cursor", "move");

    $(setNodes).bind("vmousedown", function(event) {
        event.preventDefault();
        var startx = event.pageX - $(graphie.raphael.canvas.parentNode).offset().left;
        var starty = event.pageY - $(graphie.raphael.canvas.parentNode).offset().top;

        $(document).bind("vmousemove.ruler", function(event) {
            // mouse{X|Y} are in pixels relative to the SVG
            var mouseX = event.pageX - $(graphie.raphael.canvas.parentNode).offset().left;
            var mouseY = event.pageY - $(graphie.raphael.canvas.parentNode).offset().top;
            // can't go beyond 10 pixels from the edge
            mouseX = Math.max(10, Math.min(graphie.xpixels - 10, mouseX));
            mouseY = Math.max(10, Math.min(graphie.ypixels - 10, mouseY));

            var dx = mouseX - startx;
            var dy = mouseY - starty;

            set.translate(dx, dy);
            leftBottomHandle.setCoord([leftBottomHandle.coord[0] + dx / graphie.scale[0], leftBottomHandle.coord[1] - dy / graphie.scale[1]]);
            rightBottomHandle.setCoord([rightBottomHandle.coord[0] + dx / graphie.scale[0], rightBottomHandle.coord[1] - dy / graphie.scale[1]]);

            startx = mouseX;
            starty = mouseY;
        });

        $(document).one("vmouseup", function(event) {
            $(document).unbind("vmousemove.ruler");
        });
    });

    // Handles for rotation
    var leftBottomHandle = graphie.addMovablePoint({
        coord: leftBottom,
        normalStyle: {
            fill: KhanUtil.INTERACTIVE,
            "fill-opacity": 0,
            stroke: KhanUtil.INTERACTIVE
        },
        highlightStyle: {
            fill: KhanUtil.INTERACTING,
            "fill-opacity": 0.1,
            stroke: KhanUtil.INTERACTING
        },
        pointSize: 6, // or 8 maybe?
        onMove: function(x, y) {
            var dy = rightBottomHandle.coord[1] - y;
            var dx = rightBottomHandle.coord[0] - x;
            var angle = Math.atan2(dy, dx) * 180 / Math.PI;
            var center = kvector.scale(kvector.add([x, y], rightBottomHandle.coord), 0.5);
            var scaledCenter = graphie.scalePoint(center);
            var oldCenter = kvector.scale(kvector.add(leftBottomHandle.coord, rightBottomHandle.coord), 0.5);
            var scaledOldCenter = graphie.scalePoint(oldCenter);
            var diff = kvector.subtract(scaledCenter, scaledOldCenter);
            set.rotate(-angle, scaledOldCenter[0], scaledOldCenter[1]);
            set.translate(diff[0], diff[1]);
        }
    });
    var rightBottomHandle = graphie.addMovablePoint({
        coord: [right, bottom],
        normalStyle: {
            fill: KhanUtil.INTERACTIVE,
            "fill-opacity": 0,
            stroke: KhanUtil.INTERACTIVE
        },
        highlightStyle: {
            fill: KhanUtil.INTERACTING,
            "fill-opacity": 0.1,
            stroke: KhanUtil.INTERACTING
        },
        pointSize: 6, // or 8 maybe?
        onMove: function(x, y) {
            var dy = y - leftBottomHandle.coord[1];
            var dx = x - leftBottomHandle.coord[0];
            var angle = Math.atan2(dy, dx) * 180 / Math.PI;
            var center = kvector.scale(kvector.add([x, y], leftBottomHandle.coord), 0.5);
            var scaledCenter = graphie.scalePoint(center);
            var oldCenter = kvector.scale(kvector.add(leftBottomHandle.coord, rightBottomHandle.coord), 0.5);
            var scaledOldCenter = graphie.scalePoint(oldCenter);
            var diff = kvector.subtract(scaledCenter, scaledOldCenter);
            set.rotate(-angle, scaledOldCenter[0], scaledOldCenter[1]);
            set.translate(diff[0], diff[1]);
        }
    });

    // Make each handle rotate the ruler about the other one
    leftBottomHandle.constraints.fixedDistance.dist = width / graphie.scale[0];
    leftBottomHandle.constraints.fixedDistance.point = rightBottomHandle;
    rightBottomHandle.constraints.fixedDistance.dist = width / graphie.scale[0];
    rightBottomHandle.constraints.fixedDistance.point = leftBottomHandle;

    this.remove = function() {
        set.remove();
        leftBottomHandle.remove();
        rightBottomHandle.remove();
    };

    return this;
}

function MovableAngle(graphie, options) {
    this.graphie = graphie;

    // TODO(alex): Move standard colors from math.js to somewhere else
    // so that they are available when this file is first parsed
    _.extend(this, options);
    _.defaults(this, {
        normalStyle: {
            "stroke": KhanUtil.INTERACTIVE,
            "stroke-width": 2,
            "fill": KhanUtil.INTERACTIVE
        },
        highlightStyle: {
            "stroke": KhanUtil.INTERACTING,
            "stroke-width": 2,
            "fill": KhanUtil.INTERACTING
        },
        labelStyle: {
            "stroke": KhanUtil.DYNAMIC,
            "stroke-width": 1,
            "color": KhanUtil.DYNAMIC
        },
        angleStyle: {
            "stroke": KhanUtil.DYNAMIC,
            "stroke-width": 1,
            "color": KhanUtil.DYNAMIC
        },
        allowReflex: true // not on MovableAngle.prototype so that
                          // it is not overridden by undefined
    });

    if (!this.points || this.points.length !== 3) {
        throw new Error("MovableAngle requires 3 points");
    }

    // Handle coordinates that are not MovablePoints (i.e. [2, 4])
    this.points = _.map(options.points, function(point) {
        if (_.isArray(point)) {
            return graphie.addMovablePoint({
                coord: point,
                visible: false,
                constraints: {
                    fixed: true
                },
                normalStyle: this.normalStyle
            });
        } else {
            return point;
        }
    }, this);
    this.coords = _.pluck(this.points, "coord");
    if (this.reflex == null) {
        if (this.allowReflex) {
            this.reflex = (this._getClockwiseAngle(this.coords) > 180);
        } else {
            this.reflex = false;
        }
    }

    this.rays = _.map([0, 2], function(i) {
        return graphie.addMovableLineSegment({
            pointA: this.points[1],
            pointZ: this.points[i],
            fixed: true,
            extendRay: true
        });
    }, this);

    this.temp = [];
    this.labeledAngle = graphie.label([0, 0], "", "center", this.labelStyle);

    if (!this.fixed) {
        this.addMoveHandlers();
        this.addHighlightHandlers();
    }
    this.update();
}

_.extend(MovableAngle.prototype, {
    points: [],
    snapDegrees: 0,
    snapOffsetDeg: 0,
    angleLabel: "",
    numArcs: 1,
    pushOut: 0,
    fixed: false,

    addMoveHandlers: function() {
        var graphie = this.graphie;

        function tooClose(point1, point2) {
            // Vertex and ray points can't be closer than this many pixels
            var safeDistance = 30;
            var distance = KhanUtil.getDistance(
                graphie.scalePoint(point1),
                graphie.scalePoint(point2)
            );
            return distance < safeDistance;
        }

        var points = this.points;

        // Drag the vertex to move the entire angle
        points[1].onMove = function(x, y) {
            var oldVertex = points[1].coord;
            var newVertex = [x, y];
            var delta = addPoints(newVertex, reverseVector(oldVertex));

            var valid = true;
            var newPoints = {};
            _.each([0, 2], function(i) {
                var oldPoint = points[i].coord;
                var newPoint = addPoints(oldPoint, delta);

                // Constrain ray points to stay the same angle from vertex
                var angle = KhanUtil.findAngle(newVertex, newPoint);
                angle *= Math.PI / 180;
                newPoint = graphie.constrainToBoundsOnAngle(newPoint, 10, angle);
                newPoints[i] = newPoint;

                if (tooClose(newVertex, newPoint)) {
                    valid = false;
                }
            });

            // Only move points if all new positions are valid
            if (valid) {
                _.each(newPoints, function(newPoint, i) {
                    points[i].setCoord(newPoint);
                });
            }
            return valid;
        };

        var snap = this.snapDegrees;
        var snapOffset = this.snapOffsetDeg;

        // Drag ray control points to move each ray individually
        _.each([0, 2], function(i) {
            points[i].onMove = function(x, y) {
                var newPoint = [x, y];
                var vertex = points[1].coord;

                if (tooClose(vertex, newPoint)) {
                    return false;
                } else if (snap) {
                    var angle = KhanUtil.findAngle(newPoint, vertex);
                    angle = Math.round((angle - snapOffset) / snap) * snap +
                            snapOffset;
                    var distance = KhanUtil.getDistance(newPoint, vertex);
                    return addPoints(vertex, graphie.polar(distance, angle));
                } else {
                    return true;
                }
            };
        });

        // Expose only a single move event
        $(points).on("move", function() {
            this.update();
            $(this).trigger("move");
        }.bind(this));
    },

    addHighlightHandlers: function() {
        var vertex = this.points[1];

        vertex.onHighlight = function() {
            _.each(this.points, function(point) {
                point.visibleShape.animate(this.highlightStyle, 50);
            }, this);
            _.each(this.rays, function(ray) {
                ray.visibleLine.animate(this.highlightStyle, 50);
                ray.arrowStyle = _.extend({}, ray.arrowStyle, {
                    "color": this.highlightStyle.stroke,
                    "stroke": this.highlightStyle.stroke
                });
            }, this);

            this.angleStyle = _.extend({}, this.angleStyle, {
                "color": this.highlightStyle.stroke,
                "stroke": this.highlightStyle.stroke
            });
            this.update();

        }.bind(this);

        vertex.onUnhighlight = function() {
            _.each(this.points, function(point) {
                point.visibleShape.animate(this.normalStyle, 50);
            }, this);
            _.each(this.rays, function(ray) {
                ray.visibleLine.animate(ray.normalStyle, 50);
                ray.arrowStyle = _.extend({}, ray.arrowStyle, {
                    "color": ray.normalStyle.stroke,
                    "stroke": ray.normalStyle.stroke
                });
            }, this);

            this.angleStyle = _.extend({}, this.angleStyle, {
                "color": KhanUtil.DYNAMIC,
                "stroke": KhanUtil.DYNAMIC
            });
            this.update();

        }.bind(this);
    },

    /**
     * Returns the angle in [0, 360) degrees created by the
     * coords when interpreted in a clockwise direction.
     */
    _getClockwiseAngle: function(coords) {
        // TODO(jack): Add this to a kangle.js
        var clockwiseAngle = (KhanUtil.findAngle(
            // The order of these is "weird" to match what a clockwise
            // order is in graphie.labelAngle
            coords[2], // from the second point
            coords[0], // clockwise to the first point
            coords[1] // the vertex parameter is last
        ) + 360) % 360;

        return clockwiseAngle;
    },

    isReflex: function() {
        return this.reflex;
    },

    isClockwise: function() {
        var clockwiseReflexive = (this._getClockwiseAngle(this.coords) > 180);
        return clockwiseReflexive === this.reflex;
    },

    getClockwiseCoords: function() {
        if (this.isClockwise()) {
            return _.clone(this.coords);
        } else {
            return _.clone(this.coords).reverse();
        }
    },

    update: function(shouldChangeReflexivity) {
        // Update coords
        var prevCoords = this.coords;
        this.coords = _.pluck(this.points, "coord");

        // Update lines
        _.invoke(this.points, "updateLineEnds");

        var prevAngle = this._getClockwiseAngle(prevCoords);
        var angle = this._getClockwiseAngle(this.coords);
        var prevClockwiseReflexive = (prevAngle > 180);
        var clockwiseReflexive = (angle > 180);

        if (this.allowReflex) {
            if (shouldChangeReflexivity == null) {
                shouldChangeReflexivity =
                        (prevClockwiseReflexive !== clockwiseReflexive) &&
                        (Math.abs(angle - prevAngle) < 180);
            }

            if (shouldChangeReflexivity) {
                this.reflex = !this.reflex;
            }
        }

        _.invoke(this.temp, "remove");
        this.temp = this.graphie.labelAngle({
            point1: this.coords[0],
            vertex: this.coords[1],
            point3: this.coords[2],
            label: this.labeledAngle,
            text: this.angleLabel,
            numArcs: this.numArcs,
            pushOut: this.pushOut,
            clockwise: this.reflex === clockwiseReflexive,
            style: this.angleStyle
        });
    },

    remove: function() {
        _.invoke(this.rays, "remove");
        _.invoke(this.temp, "remove");
        this.labeledAngle.remove();
    }
});

});

define('utils/graphie-helpers.js',['require','./math-format.js'],function(require) {

require("./math-format.js");

// Temporary not really following convention file, see #160

window.numberLine = function(start, end, step, x, y, denominator) {
    step = step || 1;
    x = x || 0;
    y = y || 0;
    var decPlaces = (step + "").length - (step + "").indexOf(".") - 1;
    if ((step + "").indexOf(".") < 0) {
        decPlaces = 0;
    }
    var graph = KhanUtil.currentGraph;
    var set = graph.raphael.set();
    set.push(graph.line([x, y], [x + end - start, y]));
    set.labels = [];
    for (var i = 0; i <= end - start; i += step) {
        set.push(graph.line([x + i, y - 0.2], [x + i, y + 0.2]));

        if (denominator) {
            var base = KhanUtil.roundTowardsZero(start + i + 0.001);
            var frac = start + i - base;
            var lab = base;

            if (! (Math.abs(Math.round(frac * denominator)) === denominator || Math.round(frac * denominator) === 0)) {
                if (base === 0) {
                    lab = KhanUtil.fraction(Math.round(frac * denominator), denominator, false, false, true);
                }
                else {
                    lab = base + "\\frac{" + Math.abs(Math.round(frac * denominator)) + "}{" + denominator + "}";
                }
            }
            var label = graph.label([x + i, y - 0.2], "\\small{" + lab + "}",
                "below", { labelDistance: 3 });
            set.labels.push(label);
            set.push(label);
        }
        else {
            var label = graph.label([x + i, y - 0.2],
                "\\small{" + KhanUtil.localeToFixed(start + i, decPlaces) + "}",
                "below", { labelDistance: 3 });
            set.labels.push(label);
            set.push(label);
        }
    }
    return set;
};

window.piechart = function(divisions, colors, radius, strokeColor, x, y) {
    var graph = KhanUtil.currentGraph;
    var set = graph.raphael.set();
    var arcColor = strokeColor || "none";
    var lineColor = strokeColor || "#fff";
    x = x || 0;
    y = y || 0;

    var sum = 0;
    $.each(divisions, function(i, slice) {
        sum += slice;
    });

    var partial = 0;
    $.each(divisions, function(i, slice) {
        if (slice === sum) {
            set.push(graph.ellipse([x, y], [radius, radius], {
                stroke: arcColor,
                fill: colors[i]
            }));
        } else {
            set.push(graph.arc([x, y], radius, partial * 360 / sum, (partial + slice) * 360 / sum, true, {
                stroke: arcColor,
                fill: colors[i]
            }));
        }
        partial += slice;
    });

    for (var i = 0; i < sum; i++) {
        var p = graph.polar(radius, i * 360 / sum);
        set.push(graph.line([x, y], [x + p[0], y + p[1]], { stroke: lineColor }));
    }

    return set;
};

// Shade a rectangular area with diagonal stripes. We need to use clipRect so
// that the ends of the diagonal lines are beveled at each end such that they
// conform to the overall area of the rectangle being shaded. So this actually
// draws the diagonal stripes over the entire graphie area and uses clipRect to
// only show them where desired.
//
// The pad argument is an optional number of pixels of padding. Positive
// numbers make the shaded area smaller.
window.shadeRect = function(x, y, width, height, pad) {
    var graph = KhanUtil.currentGraph;
    var set = graph.raphael.set();
    var x2 = graph.range[0][0];
    var y1 = graph.range[1][0];
    var y2 = graph.range[1][1];
    var x1 = x2 - (y2 - y1) * graph.scale[1] / graph.scale[0];
    var step = 8 / graph.scale[0];
    var xpad = (pad || 0) / graph.scale[0];
    var ypad = (pad || 0) / graph.scale[1];

    while (x1 < graph.range[0][1]) {
        set.push(graph.line([x1, y1], [x2, y2], {
            clipRect: [[x + xpad, y + ypad],
                      [width - 2 * xpad, height - 2 * ypad]]
        }));
        x1 += step;
        x2 += step;
    }
    return set;
};

window.rectchart = function(divisions, fills, y, strokes, shading) {
    var graph = KhanUtil.currentGraph;
    var set = graph.raphael.set();

    y = y || 0;

    var sum = 0;
    $.each(divisions, function(i, slice) {
        sum += slice;
    });

    var unit = graph.unscaleVector([1, 1]);
    var partial = 0;
    $.each(divisions, function(i, slice) {
        var fill = fills[i];
        // If no stroke is provided, match the fill color so the rectangle
        // appears to be the same size
        var stroke = strokes && strokes[i] || fill;

        for (var j = 0; j < slice; j++) {
            var x = partial / sum, w = 1 / sum;
            set.push(graph.path(
                [
                    [x + 2 * unit[0], y + 2 * unit[1]],
                    [x + w - 2 * unit[0], y + 2 * unit[1]],
                    [x + w - 2 * unit[0], y + 1 - 2 * unit[1]],
                    [x + 2 * unit[0], y + 1 - 2 * unit[1]],
                    true
                ],
                {
                    stroke: stroke,
                    fill: fill
                }
            ));
            if (shading && shading[i]) {
                graph.style({
                    stroke: "#000",
                    strokeWidth: 2,
                    strokeOpacity: 0.5,
                    fillOpacity: 0,
                    fill: null
                }, function() {
                    // We add or subtract a pixel of padding depending on
                    // whether there's a stroke. If there is, we only shade
                    // inside, otherwise we shade over the whole area. That's
                    // why the last argument to shadeRect is 1 or -1 (the width
                    // of the stroke is assumed to be 2)
                    set.push(shadeRect(
                        x + 2 * unit[0], y + 2 * unit[1],
                        w - 4 * unit[0], 1 - 4 * unit[1],
                        (strokes && strokes[i]) ? 1 : -1));
                });
            }
            partial += 1;
        }
    });

    return set;
};

window.Parabola = function(lc, x, y) {
    var leadingCoefficient = lc;
    var x1 = x;
    var y1 = y;
    var raphaelObjects = [];

    this.graphieFunction = function(x) {
        return (leadingCoefficient * (x - x1) * (x - x1)) + y1;
    };

    this.plot = function(fShowFocusDirectrix) {
        var graph = KhanUtil.currentGraph;
        raphaelObjects.push(graph.plot(this.graphieFunction, [-10, 10]));
        if (fShowFocusDirectrix) {
            var focusX = this.getFocusX();
            var focusY = this.getFocusY();
            var directrixK = this.getDirectrixK();

            graph.style({
                fill: "#6495ED"
            }, function() {
                raphaelObjects.push(graph.circle([focusX, focusY], 0.1));
                raphaelObjects.push(graph.line([-10, directrixK], [10, directrixK]));
            });
        }
    };

    this.redraw = function(fShowFocusDirectrix) {
        $.each(raphaelObjects, function(i, el) {
            el.remove();
        });
        raphaelObjects = [];
        this.plot(fShowFocusDirectrix);
    };

    this.update = function(newLC, newX, newY) {
        leadingCoefficient = newLC;
        x1 = newX;
        y1 = newY;
    };

    this.delta = function(deltaLC, deltaX, deltaY) {
        this.update(leadingCoefficient + deltaLC, x1 + deltaX, y1 + deltaY);
    };

    this.deltaFocusDirectrix = function(deltaX, deltaY, deltaK) {
        var focusY = this.getFocusY() + deltaY;
        var k = this.getDirectrixK() + deltaK;

        if (focusY === k) {
            focusY += deltaY;
            k += deltaK;
        }
        var newVertexY = (focusY + k) / 2;
        var newLeadingCoefficient = 1 / (2 * (focusY - k));

        this.update(newLeadingCoefficient, this.getVertexX() + deltaX, newVertexY);
    };

    this.getVertexX = function() {
        return x1;
    };

    this.getVertexY = function() {
        return y1;
    };

    this.getLeadingCoefficient = function() {
        return leadingCoefficient;
    };

    this.getFocusX = function() {
        return x1;
    };

    this.getFocusY = function() {
        return y1 + (1 / (4 * leadingCoefficient));
    };

    this.getDirectrixK = function() {
        return y1 - (1 / (4 * leadingCoefficient));
    };
};

window.redrawParabola = function(fShowFocusDirectrix) {
    var graph = KhanUtil.currentGraph;
    var storage = graph.graph;
    var currParabola = storage.currParabola;
    currParabola.redraw(fShowFocusDirectrix);

    var leadingCoefficient = currParabola.getLeadingCoefficient();
    var vertexX = currParabola.getVertexX();
    var vertexY = currParabola.getVertexY();

    if (fShowFocusDirectrix) {
        $("#focus-x-label").html("<code>" + currParabola.getFocusX() + "</code>").runModules();
        $("#focus-y-label").html("<code>" + KhanUtil.localeToFixed(currParabola.getFocusY(), 2) + "</code>").runModules();
        $("#directrix-label").html("<code>" + "y = " + KhanUtil.localeToFixed(currParabola.getDirectrixK(), 2) + "</code>").runModules();
    } else {
        var equation = "y - " + vertexY + "=" + leadingCoefficient + "(x - " + vertexX + ")^{2}";
        equation = KhanUtil.cleanMath(equation);
        $("#equation-label").html("<code>" + equation + "</code>").runModules();
    }
    $("#leading-coefficient input").val(leadingCoefficient);
    $("#vertex-x input").val(vertexX);
    $("#vertex-y input").val(vertexY);
};

window.updateParabola = function(deltaA, deltaX, deltaY, fShowFocusDirectrix) {
    KhanUtil.currentGraph.graph.currParabola.delta(deltaA, deltaX, deltaY);
    redrawParabola(fShowFocusDirectrix);
};

window.updateFocusDirectrix = function(deltaX, deltaY, deltaK) {
    KhanUtil.currentGraph.graph.currParabola.deltaFocusDirectrix(deltaX, deltaY, deltaK);
    redrawParabola(true);
};

window.ParallelLineMarkers = function(x, y) {
    var graph = KhanUtil.currentGraph;
    var s = graph.scaleVector([1, 1]);
    var x2 = x + 5 / s[0];
    var pmarkW = 5 / s[0];
    var pmarkH = 5 / s[1];
    graph.path([[x - pmarkW, y + pmarkH], [x, y], [x - pmarkW, y - pmarkH]]);
    graph.path([[x2 - pmarkW, y + pmarkH], [x2, y], [x2 - pmarkW, y - pmarkH]]);
};

window.ParallelLines = function(x1, y1, x2, y2, distance) {
    var lowerIntersection;
    var upperIntersection;
    var anchorAngle;

    function stretch(coordArr, dy) {
        return $.map(coordArr, function(coord, index) {
            if (index === 0) {
                var dx = dy / Math.tan(KhanUtil.toRadians(anchorAngle));
                coord += dx;
            }
            if (index === 1) {
                coord += dy;
            }
            return coord;
        });
    }

    function labelAngle(coordArr, angles, color, label) {
        var graph = KhanUtil.currentGraph;
        var measure = (angles[1] - angles[0]);
        var bisect = (angles[0] + angles[1]) / 2;

        var radius = 0.6;

        if (measure < 60) { // control for angle label getting squeezed between intersecting lines
            radius /= Math.sin(KhanUtil.toRadians(measure));
        }

        var coords = $.map(coordArr, function(coord, index) {
            if (index === 0) { // x-coordinate
                return coord + radius * Math.cos(KhanUtil.toRadians(bisect));
            } else { // y-coordinate
                return coord + radius * Math.sin(KhanUtil.toRadians(bisect));
            }
        });

        graph.label(coords, label.text, label.placement, { color: color });
    }

    this.draw = function() {
        var graph = KhanUtil.currentGraph;
        graph.line([x1, y1], [x2, y2]);
        graph.line([x1, y1 + distance], [x2, y2 + distance]);
    };

    this.drawMarkers = function(position) {
        var graph = KhanUtil.currentGraph;
        var pmarkX = (x2 - x1) / 2 + x1;
        if (position === "right" || (position >= 40 && position <= 140)) {
            pmarkX = x2 - 55 / graph.scaleVector([1, 1])[0];
        } else if (position === "left") {
            pmarkX = x1 + 50 / graph.scaleVector([1, 1])[0];
        }
        ParallelLineMarkers(pmarkX, y1);
        ParallelLineMarkers(pmarkX, y1 + distance);
    };

    this.drawTransverse = function(angleDeg) {
        anchorAngle = angleDeg;
        var graph = KhanUtil.currentGraph;
        var width = distance / Math.tan(KhanUtil.toRadians(anchorAngle));
        var lowerX = x1 + ((x2 - x1) - width) / 2;
        var upperX = lowerX + width;
        lowerIntersection = [lowerX, y1];
        upperIntersection = [upperX, y1 + distance];
        graph.line(stretch(lowerIntersection, -0.8), stretch(upperIntersection, 0.8));
    };

    this.drawAngle = function(index, label, color) {

        var graph = KhanUtil.currentGraph,
            radius = 0.5,
            args, angles;

        color = color || KhanUtil.BLUE;
        index = (index + 8) % 8;
        if (index < 4) {
            args = [lowerIntersection, radius];
        } else {
            args = [upperIntersection, radius];
        }

        var labelPlacement;
        switch (index % 4) {
            case 0: // Quadrant 1
                angles = [0, anchorAngle];
                labelPlacement = "right";
                break;
            case 1: // Quadrant 2
                angles = [anchorAngle, 180];
                labelPlacement = "left";
                break;
            case 2: // Quadrant 3
                angles = [180, 180 + anchorAngle];
                labelPlacement = "left";
                break;
            case 3: // Quadrant 4
                angles = [180 + anchorAngle, 360];
                labelPlacement = "right";
                break;
        }
        $.merge(args, angles);

        graph.style({ stroke: color}, function() {
            graph.arc.apply(graph, args);
            if (label) {
                var labelOptions = { text: label, placement: labelPlacement};

                if (typeof label === "boolean") {
                    labelOptions.text = (angles[1] - angles[0]) + "^\\circ";
                }

                labelAngle(args[0], angles, color, labelOptions);
            }
        });
    };

    this.drawVerticalAngle = function(index, label, color) {
        index = (index + 8) % 8;
        var vert = (index + 2) % 4;
        if (index >= 4) {
            vert += 4;
        }
        this.drawAngle(vert, label, color);
    };

    this.drawAdjacentAngles = function(index, label, color) {
        index = (index + 8) % 8;
        var adj1 = (index + 1) % 4;
        var adj2 = (index + 3) % 4;
        if (index >= 4) {
            adj1 += 4;
            adj2 += 4;
        }
        this.drawAngle(adj1, label, color);
        this.drawAngle(adj2, label, color);
    };
};

window.drawComplexChart = function(radius, denominator) {
    var graph = KhanUtil.currentGraph;
    var safeRadius = radius * Math.sqrt(2);
    var color = "#ddd";

    // Draw lines of complex numbers with same angle and
    // circles of complex numbers with same radius to help the intuition.

    graph.style({
        strokeWidth: 1.0
    });

    for (var i = 1; i <= safeRadius; i++) {
        graph.circle([0, 0], i, {
            fill: "none",
            stroke: color
        });
    }

    for (var i = 0; i < denominator; i++) {
        var angle = i * 2 * Math.PI / denominator;
        if (denominator % 4 === 0 && i % (denominator / 4) !== 0) { // Don't draw over axes.
            graph.line([0, 0], [Math.sin(angle) * safeRadius, Math.cos(angle) * safeRadius], {
                stroke: color
            });
        }
    }

    graph.label([radius, 0.5], "Re", "left");
    graph.label([0.5, radius - 1], "Im", "right");
};

window.ComplexPolarForm = function(angleDenominator, maxRadius, euler) {
    var denominator = angleDenominator;
    var maximumRadius = maxRadius;
    var angle = 0, radius = 1;
    var circle;
    var useEulerForm = euler;

    this.update = function(newAngle, newRadius) {
        angle = newAngle;
        while (angle < 0) {
            angle += denominator;
        }
        angle %= denominator;

        radius = Math.max(1, Math.min(newRadius, maximumRadius)); // keep between 0 and maximumRadius...

        this.redraw();
    };

    this.delta = function(deltaAngle, deltaRadius) {
        this.update(angle + deltaAngle, radius + deltaRadius);
    };

    this.getAngleNumerator = function() {
        return angle;
    };

    this.getAngleDenominator = function() {
        return denominator;
    };

    this.getAngle = function() {
        return angle * 2 * Math.PI / denominator;
    };

    this.getRadius = function() {
        return radius;
    };

    this.getRealPart = function() {
        return Math.cos(this.getAngle()) * radius;
    };

    this.getImaginaryPart = function() {
        return Math.sin(this.getAngle()) * radius;
    };

    this.getUseEulerForm = function() {
        return useEulerForm;
    };

    this.plot = function() {
        circle = KhanUtil.currentGraph.circle([this.getRealPart(), this.getImaginaryPart()], 1 / 4, {
            fill: KhanUtil.ORANGE,
            stroke: "none"
        });
    };

    this.redraw = function() {
        if (circle) {
            circle.remove();
        }
        this.plot();
    };
};

window.updateComplexPolarForm = function(deltaAngle, deltaRadius) {
    KhanUtil.currentGraph.graph.currComplexPolar.delta(deltaAngle, deltaRadius);
    redrawComplexPolarForm();
};

window.redrawComplexPolarForm = function(angle, radius) {
    var graph = KhanUtil.currentGraph;
    var storage = graph.graph;
    var point = storage.currComplexPolar;
    point.redraw();

    if (typeof radius === "undefined") {
        radius = point.getRadius();
    }
    if (typeof angle === "undefined") {
        angle = point.getAngleNumerator();
    }

    angle *= 2 * Math.PI / point.getAngleDenominator();

    var equation = KhanUtil.polarForm(radius, angle, point.getUseEulerForm());

    $("#number-label").html("<code>" + equation + "</code>").runModules();
    $("#current-radius").html("<code>" + radius + "</code>").runModules();
    $("#current-angle").html("<code>" + KhanUtil.piFraction(angle, true) + "</code>").runModules();
};

window.labelDirection = function(angle) {
    angle = angle % 360;
    if (angle === 0) {
        return "right";
    } else if (angle > 0 && angle < 90) {
        return "above right";
    } else if (angle === 90) {
        return "above";
    } else if (angle > 90 && angle < 180) {
        return "above left";
    } else if (angle === 180) {
        return "left";
    } else if (angle > 180 && angle < 270) {
        return "below left";
    } else if (angle === 270) {
        return "below";
    } else if (angle > 270 && angle < 360) {
        return "below right";
    }
};

// arc orientation is "top"|"left"|"bottom"|"right".
// arrow direction is clockwise (true) or counter-clockwise (false)
window.curvyArrow = function(center, radius, arcOrientation, arrowDirection, styles) {
    styles = styles || {};
    var graph = KhanUtil.currentGraph;
    var set = graph.raphael.set();
    var angles;
    if (arcOrientation === "left") {
        angles = [90, 270];
    } else if (arcOrientation === "right") {
        angles = [270, 90];
    } else if (arcOrientation === "top") {
        angles = [0, 180];
    } else if (arcOrientation === "bottom") {
        angles = [180, 0];
    }
    angles.push(styles);
    var arcArgs = [center, radius].concat(angles);
    set.push(graph.arc.apply(graph, arcArgs));

    var offset = graph.unscaleVector([1, 1]);

    // draw Arrows
    var from = _.clone(center);
    var to = _.clone(center);
    if (arcOrientation === "left" || arcOrientation === "right") {
        var left = arcOrientation === "left";
        from[1] = to[1] = to[1] + radius * (arrowDirection === left ? 1 : -1);
        to[0] = from[0] + offset[0] * (left ? 1 : -1);
    } else {
        var bottom = arcOrientation === "bottom";
        from[0] = to[0] = to[0] + radius * (arrowDirection === bottom ? 1 : -1);
        to[1] = from[1] + offset[1] * (bottom ? 1 : -1);
    }
    set.push(graph.line(from, to, _.extend({arrows: "->"}, styles)));
    return set;
};

window.curlyBrace = function(startPointGraph, endPointGraph) {
    var graph = KhanUtil.currentGraph;

    var startPoint = graph.scalePoint(startPointGraph);
    var endPoint = graph.scalePoint(endPointGraph);
    var angle = KhanUtil.findAngle(endPoint, startPoint);
    var length = KhanUtil.getDistance(endPoint, startPoint);
    var midPoint = _.map(startPoint, function(start, i) {
        return (start + endPoint[i]) / 2;
    });

    var specialLen = 16 * 2 + 13 * 2;
    if (length < specialLen) {
        throw new Error("Curly brace length is too short.");
    }
    var straight = (length - specialLen) / 2;
    var half = length / 2;

    var firstHook = "c 1 -3 6 -5 10 -6" +
                    "c 0 0 3 -1 6 -1";

    // Mirror of first hook.
    var secondHook = "c 3 1 6 1 6 1" +
                     "c 4 1 9 3 10 6";

    var straightPart = "l " + straight + " 0";

    var firstMiddle =
            "c 5 0 10 -3 10 -3" +
            "l 3 -4";

    // Mirror of second middle
    var secondMiddle =
            "l 3 4" +
            "c 0 0 5 3 10 3";

    var path = [
        "M -" + half + " 0",
        firstHook,
        straightPart,
        firstMiddle,
        secondMiddle,
        straightPart,
        secondHook
    ].join("");

    var brace = graph.raphael.path(path);
    brace.rotate(angle);
    brace.translate(midPoint[0], midPoint[1]);
    return brace;
};

});

define('utils/congruency.js',['require','./angles.js','./interactive.js','./graphie-helpers.js'],function(require) {

require("./angles.js");
require("./interactive.js");
require("./graphie-helpers.js");

$.extend(KhanUtil, {
    // Add a "congruency" object that stores data about the
    // points, lines, and angles that you added to the congruency
    // figure
    //
    // options that can be added to modify:
    //
    // - x1, y1, x2, y2: the bounds of the object, which controls
    //      where an extended line gets extended to
    addCongruency: function(options) {
        var congruency = $.extend(true, {
            x1: 0,
            x2: 10,
            y1: 0,
            y2: 3
        }, options);

        // ensure that x1 < x2, y1 < y2
        if (congruency.x1 > congruency.x2) {
            var hold = congruency.x1;
            congruency.x1 = congruency.x2;
            congruency.x2 = hold;
        }
        if (congruency.y1 > congruency.y2) {
            var hold = congruency.y1;
            congruency.y1 = congruency.y2;
            congruency.y2 = hold;
        }

        // store the current graph
        var graph = KhanUtil.currentGraph;

        // where the lines, angles, and points are stored
        congruency.lines = {};
        congruency.angles = {};
        congruency.points = {};

        congruency.getPoint = function(pt) {
            if (typeof pt === "string") {
                return congruency.points[pt];
            } else {
                return pt;
            }
        };

        // Add a point to the congruency figure
        //
        // - name is a one-character string
        // - position is a two-element array
        congruency.addPoint = function(name, position) {
            var point = {
                name: name,
                pos: position,
                connected: [],
                arcs: []
            };

            // calculate the angle of the point to another point
            point.angleTo = function(p) {
                p = congruency.getPoint(p);

                return Math.atan2(p.pos[1] - point.pos[1],
                                  p.pos[0] - point.pos[0]);
            };

            // store the point in the congruency variable
            congruency.points[name] = point;

            return point;
        };

        // add a line to the congruency diagram
        //
        // there are two ways to specify the line:
        //
        // - provide a start point and an angle
        //
        //      This creates a line starting at the start
        //      point and extending in the direction of the
        //      given angle for one unit
        //
        // - provide a start and end point
        //
        //      This creates a line starting at the start
        //      point and ending at the end point
        //
        // other options:
        //
        // - extend:
        //      makes the line extend in both directions
        //      until it hits the congruency boundary
        //
        // - clickable:
        //      makes the line able to be clicked on to change
        //      the number of ticks on it
        //
        // - state:
        //      the starting number of ticks on the line
        //
        // - maxState:
        //      the maximum number of ticks that can be added
        //      by clicking
        //
        // - tickDiff:
        //      the distance between the ticks on the line
        //
        // - tickLength:
        //      the length of each tick mark
        //
        // - placeAtStart:
        //      A string name of a point to be placed at the
        //      beginning of the line, after extending
        //
        // - placeAtEnd:
        //      A string name of a point to be placed at the
        //      end of the line, after extending
        congruency.addLine = function(options) {
            var line = $.extend(true, {
                start: [0, 0],
                extend: false,
                clickable: false,
                state: 0,
                maxState: 1,
                tickDiff: 0.15,
                tickLength: 0.2,
                highlighted: false
            }, options);

            // look up the start and end points, if they are
            // given as strings
            if (typeof line.start === "string") {
                line.startPt = congruency.points[line.start];
                line.start = line.startPt.pos;
            }
            if (typeof line.end === "string") {
                line.endPt = congruency.points[line.end];
                line.end = line.endPt.pos;
            }

            // check how the line is defined, and calculate the other
            // variables based on those
            if (line.end != null) {
                line.radAngle = Math.atan2(line.end[1] - line.start[1],
                                           line.end[0] - line.start[0]);
                line.angle = KhanUtil.toDegrees(line.radAngle);
            } else if (line.angle != null) {
                line.radAngle = KhanUtil.toRadians(line.angle);
                line.end = [Math.cos(line.radAngle) + line.start[0],
                            Math.sin(line.radAngle) + line.start[1]];
            }

            // calculate and bound the slope;
            line.slope = (line.end[1] - line.start[1]) /
                         (line.end[0] - line.start[0]);
            line.slope = Math.max(-999999, Math.min(999999, line.slope));

            // a function which represents the line
            line.func = function(x) {
                return line.start[1] + line.slope * (x - line.start[0]);
            };

            // the inverse function of the line
            line.invfunc = function(y) {
                var slope = (line.slope === 0) ? 0.00001 : line.slope;
                return line.start[0] + (y - line.start[1]) / slope;
            };

            // extend the line if specified
            if (line.extend) {
                // check which orientation the points are currently in
                var order = (line.start[0] < line.end[0]);

                // the new 'left' and 'right' points
                var left, right;

                // check to see where the 'left' side of
                // the line intersects
                var y1int = line.func(congruency.x1);

                if (y1int >= congruency.y1 && y1int <= congruency.y2) {
                    left = [congruency.x1, y1int];
                } else if (y1int > congruency.y2) {
                    left = [line.invfunc(congruency.y2), congruency.y2];
                } else {
                    left = [line.invfunc(congruency.y1), congruency.y1];
                }

                // check to see where the 'right' side of
                // the line intersects
                var y2int = line.func(congruency.x2);

                if (y2int >= congruency.y1 && y2int <= congruency.y2) {
                    right = [congruency.x2, y2int];
                } else if (y2int > congruency.y2) {
                    right = [line.invfunc(congruency.y2), congruency.y2];
                } else {
                    right = [line.invfunc(congruency.y1), congruency.y1];
                }

                // re-store the points in the correct positions
                if (order) {
                    line.start = left;
                    line.end = right;
                } else {
                    line.end = left;
                    line.start = right;
                }
            }

            // do placeAtStart and placeAtEnd
            if (line.placeAtStart != null) {
                line.startPt = congruency.addPoint(line.placeAtStart,
                                                   line.start);
            }
            if (line.placeAtEnd != null) {
                line.endPt = congruency.addPoint(line.placeAtEnd, line.end);
            }

            // if startPt and endPt exist (i.e. they are both named
            // points) add the name of our line to the congruency
            if (line.startPt != null &&
                line.endPt != null) {
                congruency.lines[line.startPt.name + line.endPt.name] = line;
                congruency.lines[line.endPt.name + line.startPt.name] = line;
            }

            // if the points are named, add the other end of the line
            // to the connected points, so they can calculate what angles
            // they create
            if (line.startPt != null && line.endPt != null) {
                line.startPt.connected.push(line.endPt);
                line.endPt.connected.push(line.startPt);
            }

            // actually draw the line with the current styles
            line.draw = function() {
                if (this.line != null) {
                    this.line.remove();
                }

                // create a set
                this.line = graph.raphael.set();

                // do a bunch of tick calculations
                var startDiff = this.tickDiff * (this.state - 1) / 2;

                var direction = [Math.cos(this.radAngle), Math.sin(this.radAngle)];
                var normalDir = [-direction[1] * this.tickLength,
                                  direction[0] * this.tickLength];

                var midpoint = [(this.start[0] + this.end[0]) / 2,
                                (this.start[1] + this.end[1]) / 2];

                var startPos = [midpoint[0] - startDiff * direction[0],
                                midpoint[1] - startDiff * direction[1]];

                // add each of the ticks
                for (var curr = 0; curr < this.state; curr += 1) {
                    var currPos = [startPos[0] + curr * direction[0] * this.tickDiff,
                                   startPos[1] + curr * direction[1] * this.tickDiff];
                    var start = [currPos[0] + normalDir[0],
                                 currPos[1] + normalDir[1]];
                    var end = [currPos[0] - normalDir[0],
                               currPos[1] - normalDir[1]];

                    this.line.push(graph.line(start, end));
                }

                // add our line
                this.line.push(graph.line(this.start, this.end));

                // add parallel line marker to horizontal line
                if (direction[1] === 0) {
                    ParallelLineMarkers(this.end[0] - 0.5, this.end[1]);
                }

                // set the attributes
                this.line.attr(this.point.normalStyle);
                this.point.visibleShape = this.line;
            };

            // calculate our midpoint, for where the clickable
            // point should go
            var pointPos = [(line.start[0] + line.end[0]) / 2,
                            (line.start[1] + line.end[1]) / 2];

            // add a movable point
            line.point = graph.addMovablePoint({
                coord: pointPos
            });
            // Make it not move
            line.point.onMove = function(x, y) {
                return false;
            };

            // make the mouse target pretty big
            line.point.mouseTarget.attr({ r: graph.scale[0] * 0.7 });

            // remove the original visible shape
            line.point.visibleShape.remove();

            // the original styles
            line.normal = {
                stroke: "black",
                "stroke-width": 2
            };
            line.hover = {
                stroke: "black",
                "stroke-width": 3
            };
            line.highlight = {};

            // set the styles depending on the state
            line.setStyles = function() {
                if (this.highlighted) {
                    this.point.normalStyle = this.highlight;
                    this.point.highlightStyle = this.highlight;
                } else {
                    this.point.normalStyle = this.normal;
                    this.point.highlightStyle = this.hover;
                }
            };

            // functions to change the styling of the line
            line.setSelectedStyle = function(style) {
                $.extend(true, this.hover, style);
                this.draw();
            };
            line.setUnselectedStyle = function(style) {
                $.extend(true, this.normal, style);
                this.draw();
            };

            // change and set highlight
            line.setHighlighted = function(style) {
                $.extend(true, this.highlight, style);
                this.highlighted = true;
                this.setStyles();
                this.draw();
            };
            line.unsetHighlighted = function() {
                this.highlighted = false;
                this.setStyles();
                this.draw();
            };

            // set the default styles
            line.setStyles();

            // draw the line
            line.draw();

            // function to change the current state
            line.setState = function(state) {
                this.state = state;

                this.draw();
            };

            // make the clickable point change the state
            $(line.point.mouseTarget[0]).bind("vmouseup", function(event) {
                line.setState((line.state === line.maxState) ? 0 : line.state + 1);
            });

            // make the line stick in the state it is in currently,
            // and remove the clickable part
            line.stick = function() {
                line.point.mouseTarget.remove();
            };

            // if we shouldn't be clickable, stick right now
            if (!line.clickable) {
                line.stick();
            }

            return line;
        };

        congruency.addAngle = function(name, options) {
            var angle = $.extend({
                radius: 0.7,
                state: 0,
                maxState: 1,
                shown: false,
                clickable: true,
                arcDiff: 0.15,
                highlighted: false
            }, options);

            angle.center = name[1];
            angle.left = name[0];
            angle.right = name[2];

            angle.centerPt = congruency.getPoint(angle.center);
            angle.leftPt = congruency.getPoint(angle.left);
            angle.rightPt = congruency.getPoint(angle.right);

            angle.pos = angle.centerPt.pos;
            angle.start = KhanUtil.toDegrees(angle.centerPt.angleTo(angle.leftPt));
            angle.end = KhanUtil.toDegrees(angle.centerPt.angleTo(angle.rightPt));

            while (angle.start > angle.end) {
                angle.start -= 360;
            }

            angle.angle = angle.end - angle.start;

            // Add a movable point for clicking
            var aveAngle = KhanUtil.toRadians((angle.start + angle.end) / 2);

            var pointPos = angle.pos.slice();
            pointPos[0] += Math.cos(aveAngle) * angle.radius;
            pointPos[1] += Math.sin(aveAngle) * angle.radius;

            angle.point = graph.addMovablePoint({
                coord: pointPos
            });
            // Make it not move
            angle.point.onMove = function(x, y) {
                return false;
            };

            // Make a clicky pointer
            $(angle.point.mouseTarget[0]).css("cursor", "pointer");

            // Increase the point's size
            var pointRadius = Math.sin(KhanUtil.toRadians(angle.angle) / 2) *
                angle.radius * graph.scale[0];
            angle.point.mouseTarget.attr({ r: pointRadius });

            // Replace the shape with our angle
            angle.point.visibleShape.remove();

            // Styles for different mouse-over states
            angle.unselected = {
                stroke: KhanUtil.GRAY,
                "stroke-width": 2,
                opacity: 0.1
            };
            angle.unselectedHover = {
                stroke: KhanUtil.GRAY,
                "stroke-width": 2,
                opacity: 0.4
            };
            angle.selected = {
                stroke: KhanUtil.BLUE,
                "stroke-width": 3,
                opacity: 0.9
            };
            angle.selectedHover = {
                stroke: KhanUtil.BLUE,
                "stroke-width": 3,
                opacity: 1.0
            };
            angle.highlight = {};

            // Draw the arc(s)
            angle.draw = function() {
                // Remove any left over arcs
                if (this.arc != null) {
                    this.arc.remove();
                }

                // Count how many arcs there should be
                var arcs = (this.state === 0) ? 1 : this.state;
                var startRad = this.radius - this.arcDiff * (arcs - 1) / 2;

                // Create a raphael set
                this.arc = graph.raphael.set();

                // Put all the arcs in the set
                for (var curr = 0; curr < arcs; curr += 1) {
                    var currRad = startRad + this.arcDiff * curr;
                    this.arc.push(graph.arc(this.pos, currRad,
                                            this.start, this.end));
                }
                // Attach it and style correctly
                this.point.visibleShape = this.arc;
                this.arc.attr(this.point.normalStyle);
            };

            // Set the styles according to the current state
            angle.setStyles = function() {
                if (this.highlighted) {
                    this.point.normalStyle = this.highlight;
                    this.point.highlightStyle = this.highlight;
                } else if (this.state === 0) {
                    this.point.normalStyle = this.unselected;
                    this.point.highlightStyle = this.unselectedHover;
                } else {
                    this.point.normalStyle = this.selected;
                    this.point.highlightStyle = this.selectedHover;
                }
            };

            // Set the state of an angle
            angle.setState = function(state) {
                this.state = state;

                this.setStyles();

                this.draw();
            };

            // setup the original styles
            angle.setStyles();

            // Ensure the angle gets drawn on creation
            angle.draw();

            // Bind mouseclick
            $(angle.point.mouseTarget[0]).bind("vmouseup", function(event) {
                angle.setState((angle.state === angle.maxState) ? 0 : angle.state + 1);
            });

            // Make an angle stick in its current state
            // by removing the clicky part
            angle.stick = function() {
                $(this.point.mouseTarget[0]).unbind();
                this.point.mouseTarget.remove();
            };

            if (!angle.clickable) {
                angle.stick();
            }

            // Set the style of angles when state == 0
            angle.setUnselectedStyle = function(style) {
                $.extend(true, this.unselected, style);
                $.extend(true, this.unselectedHover, style);
                this.draw();
            };

            // Set the style of angles when state > 0
            angle.setSelectedStyle = function(style) {
                $.extend(true, this.selected, style);
                $.extend(true, this.selectedHover, style);
                this.draw();
            };

            // Add a highlighting style and highlight an angle
            angle.setHighlighted = function(style) {
                $.extend(true, this.highlight, style);
                this.highlighted = true;
                this.setStyles();
                this.draw();
            };

            // Unhighlight an angle
            angle.unsetHighlighted = function() {
                this.highlighted = false;
                this.setStyles();
                this.draw();
            };

            // add the angle to the angles hash
            var name = angle.left + angle.center + angle.right;
            congruency.angles[name] = angle;

            name = angle.right + angle.center + angle.left;
            congruency.angles[name] = angle;

            return angle;
        };

        // add all of the angles at a specific point
        congruency.addAngles = function(point, options) {
            var pt = congruency.getPoint(point);

            // sort the angles that are coming out of
            // the given point by the angle they make to the point
            var sortConnected = _.sortBy(pt.connected, function(cpt) {
                return pt.angleTo(cpt);
            });

            var numAngs = sortConnected.length;

            // go through the connected points in order and add
            // the angles between them
            for (var i = 0; i < numAngs; i += 1) {
                var pt1 = sortConnected[i];
                var pt2 = sortConnected[(i + 1) % numAngs];

                var ang1 = pt.angleTo(pt1);
                var ang2 = pt.angleTo(pt2);

                // make sure the last angle is correct
                if (i + 1 === numAngs) {
                    ang2 += Math.PI * 2;
                }

                // don't make angles that are more than 180
                if (ang2 - ang1 >= Math.PI) {
                    continue;
                }

                // add the angle
                congruency.addAngle(pt1.name + pt.name + pt2.name, options);
            }
        };

        // intersect two lines, and add a point at the intersection
        // of those two
        congruency.intersect = function(line1, line2, pointName, addAngles) {
            if (line1.slope === line2.slope) {
                return false;
            }

            var point = null;

            var coord = [];

            coord[0] = (line1.slope * line1.start[0] -
                        line2.slope * line2.start[0] +
                        line2.start[1] - line1.start[1]) /
                        (line1.slope - line2.slope);
            coord[1] = line1.func(coord[0]);

            point = congruency.addPoint(pointName, coord);

            point.connected.push(line1.startPt);
            point.connected.push(line1.endPt);
            point.connected.push(line2.startPt);
            point.connected.push(line2.endPt);

            if (addAngles) {
                congruency.addAngles(point.name);
            }
        };

        // add a label next to a point, in the given direction
        congruency.addLabel = function(point, position) {
            var p = congruency.getPoint(point);
            graph.label(p.pos, point, position);
        };

        // get a hash of all states of the arcs and lines,
        // for storage in guesses and lookup
        congruency.getGuess = function() {
            var guess = {};

            // store all the lines' states
            _.each(congruency.lines, function(line, name) {
                guess[name] = line.state;
            });

            // store all the angles' states
            _.each(congruency.angles, function(angle, name) {
                guess[name] = angle.state;
            });

            return guess;
        };

        // take a guess, and reset all of the angles and
        // lines to their states
        congruency.showGuess = function(guess) {
            _.each(guess, function(t, g) {
                if (g.length === 2) {
                    congruency.lines[g].setState(t);
                } else {
                    congruency.angles[g].setState(t);
                }
            });
        };

        return congruency;
    }
});

});

define('utils/kmatrix.js',['require','./expressions.js'],function(require) {

require("./expressions.js");

var kmatrix = KhanUtil.kmatrix = {
    // To add two 2-dimensional matrices, use
    //     deepZipWith(2, function(a, b) { return a + b; }, matrixA, matrixB);
    deepZipWith: function(depth, fn) {
        var arrays = [].slice.call(arguments, 2);

        // if any of the "array" arguments to deepZipWith are null, return null
        var hasNullValue = _.any(arrays, function(array) {
            if (array === null) {
                return true;
            }
        });
        if (hasNullValue) {
            return null;
        }

        if (depth === 0) {
            return fn.apply(null, arrays);
        } else {
            return _.map(_.zip.apply(_, arrays), function(els) {
                return kmatrix.deepZipWith.apply(this, [depth - 1, fn].concat(els));
            });
        }
    },

    matrixCopy: function(mat) {
        return $.extend(true, [], mat);
    },

    /**
     * Apply the given function to each element of the given matrix and return
     * the resulting matrix.
     */
    matrixMap: function(fn, mat) {
        return _.map(mat, function(row, i) {
            return _.map(row, function(elem, j) {
                return fn(elem, i, j);
            });
        });
    },

    /**
     * Given a matrix and list of row-col indices to exclude from masking,
     * return a new matrix with all but the elements in excludeList overwritten
     * by the value "?".
     *
     * @param mat {result of makeMatrix}
     * @param excludeList {array of arrays} List of row-col indices to keep
     *          from being overwritten. Note that these indices start at 1, not
     *          0, to match with common math notation.
     */
    maskMatrix: function(mat, excludeList) {
        var result = [];

        _.times(mat.r, function(i) {
            var row = [];
            _.times(mat.c, function(j) {
                if (KhanUtil.contains(excludeList, [i+1, j+1])) {
                    row.push(mat[i][j]);
                } else {
                    row.push("?");
                }
            });
            result.push(row);
        });
        return result;
    },

    /**
     * Given one or more same-dimension 2d matrices and a function for
     * how to combine and format their elements in the output matrix,
     * return the LaTeX code for rendering the matrix. Inherits syntax from
     * deepZipWith().
     *
     * Example usage:
     *
     * printMatrix(function(a, b) {
     *  return colorMarkup(a, "#FF0000") + "-" + colorMarkup(b, "#00FF00");
     * }, matA, matB);
     *
     */
    printMatrix: function(fn) {
        var args = Array.prototype.slice.call(arguments);
        var mat = kmatrix.deepZipWith.apply(this, [2].concat(args));

        if (!mat) {
            return null;
        }

        var table = _.map(mat, function(row, i) {
                        return row.join(" & ");
                    }).join(" \\\\ ");

        var prefix = "\\left[\\begin{array}";
        var suffix = "\\end{array}\\right]";

        // to generate the alignment info needed for LaTeX table markup
        var alignment = "{";
        var cols = mat[0].length;
        _(cols).times(function (){
            alignment += "r";
        });
        alignment += "}";

        return prefix + alignment + table + suffix;
    },

    /**
     * Given a matrix and a color, format all elements with the given color
     * (if supplied) and return the LaTeX code for rendering the matrix.
     *
     * @param mat {array of arrays} the matrix to format
     * @param color {string}
     */
    printSimpleMatrix: function(mat, color) {
        return kmatrix.printMatrix(function(item) {
            if (color) {
                return KhanUtil.colorMarkup(item, color);
            }
            return item;
        }, mat);
    },

    /**
     * Prints matrix as determinant, like |matrix| rather than [matrix]
     */
    printSimpleMatrixDet: function(mat, color) {
        return kmatrix.printSimpleMatrix(mat,color)
                .replace("left[","left|")
                .replace("right]","right|");
    },

    /**
     * Format the rows or columns of the given matrix with the colors in the
     * given colors array, and return the LaTeX code for rendering the matrix.
     *
     * @param mat {array of arrays} the matrix to format
     * @param colors {array of strings} list of colors
     * @param isRow {bool} whether to apply the colors by row or by column
     */
    printColoredDimMatrix: function(mat, colors, isRow) {
        var matrix = kmatrix.matrixMap(function(item, i, j) {
            var color = colors[isRow ? i : j];
            return KhanUtil.colorMarkup(item, color);
        }, mat);
        return kmatrix.printSimpleMatrix(matrix);
    },

    /**
     * Generate markup for a color-coded matrix illustrating the calculations
     * behind each element in matrix multiplication.
     *
     * @param a {result of makeMatrix} the first matrix
     * @param b {result of makeMatrix} the second matrix
     * @param rowColors {array of strings} list of colors to apply to the
     *                                     rows of the first matrix
     * @param colColors {array of strings} list of colors to apply to the
     *                                     columns of the second matrix
     */
    makeMultHintMatrix: function(a, b, rowColors, colColors) {
        var c = [];
        // create the new matrix
        _.times(a.r, function() {
            c.push([]);
        });

        // perform the multiply
        _.times(a.r, function(i) {
            var c1 = rowColors[i];
            _.times(b.c, function(j) {
                var c2 = colColors[j];
                var temp = "";
                _.times(a.c, function(k) {
                    if (k > 0) {
                        temp += "+";
                    }
                    var elem1 = KhanUtil.colorMarkup(a[i][k], c1);
                    var elem2 = KhanUtil.colorMarkup(b[k][j], c2);
                    temp += elem1 + "\\cdot" + elem2;
                });
                c[i][j] = temp;
            });
        });

        return kmatrix.makeMatrix(c);
    },

    // add matrix properties to a 2d matrix
    //   currently only rows and columns
    makeMatrix: function(mat) {
        mat.r = mat.length;
        mat.c = mat[0].length;

        return mat;
    },

    // remove specified row and column from the matrix
    cropMatrix: function(mat, rowIndex, colIndex) {
        var cropped = kmatrix.matrixCopy(mat);
        cropped.splice(rowIndex, 1);
        _.each(cropped, function(row) {
            row.splice(colIndex, 1);
        });
        return cropped;
    },

    matrix2x2DetHint: function(mat) {
        // if terms in the matrix are letters, omit the dot
        var operator = (typeof mat[0][0] === "string") ? "*" : "dot";
        var termA = [operator, mat[0][0], mat[1][1]];
        var termB = [operator, mat[0][1], mat[1][0]];
        return KhanUtil.expr(["-", termA, termB]);
    },

    matrix3x3DetHint: function(mat, isIntermediate) {
        var tex = "";

        // iterate over columns
        _.times(mat.c, function(j) {
            var hintMat = kmatrix.cropMatrix(mat, 0, j);

            var sign = j % 2 ? "-" : "+";
            sign = j === 0 ? "" : sign;

            var multiplier = mat[0][j];

            var term;
            if (isIntermediate) {
                term = kmatrix.printSimpleMatrixDet(hintMat);
            } else {
                term = kmatrix.matrix2x2DetHint(hintMat);
                term = KhanUtil.exprParenthesize(term);
            }

            tex += sign + multiplier + term;
        });

        return tex;
    },

    // multiply two matrices
    matrixMult: function(a, b) {
        a = kmatrix.makeMatrix(a);
        b = kmatrix.makeMatrix(b);

        var c = [];
        // create the new matrix
        _.times(a.r, function() {
            c.push([]);
        });

        // perform the multiply
        _.times(a.r, function(i) {
            _.times(b.c, function(j) {
                var temp = 0;
                _.times(a.c, function(k) {
                    temp += a[i][k] * b[k][j];
                });
                c[i][j] = temp;
            });
        });

        // add matrix properties to the result
        return kmatrix.makeMatrix(c);
    },

    /**
     * Makes a matrix of minors
     *
     * @param m {result of makeMatrix} the matrix
     */
    matrixMinors: function(mat) {
        mat = kmatrix.makeMatrix(mat);
        if (!mat.r || !mat.c) {
            return null;
        }
        var rr = kmatrix.matrixMap(function(input, row, elem) {
            return kmatrix.cropMatrix(mat, row, elem);
        }, mat);
        return rr;
    },

    /**
     * Find the transpose of a matrix.
     *
     * @param m {result of makeMatrix} the matrix
     */
     matrixTranspose: function(mat) {
        mat = kmatrix.makeMatrix(mat);

        var r = mat.c;
        var c = mat.r;

        if (!r || !c) {
            return null;
        }

        var matT = [];

        _.times(r, function(i) {
            var row = [];
            _.times(c, function(j) {
                row.push(mat[j][i]);
            });
            matT.push(row);
        });

        return kmatrix.makeMatrix(matT);
     },

    /**
     * Find the determinant of a matrix.
     *
     * Note: Only works for 2x2 and 3x3 matrices.
     *
     * @param m {result of makeMatrix} the matrix
     */
    matrixDet: function(mat) {
        mat = kmatrix.makeMatrix(mat);

        // determinant is only defined for a square matrix
        if (mat.r !== mat.c) {
            return null;
        }

        var a, b, c, d, e, f, g, h, k, det;

        // 2x2 case
        // [[a, b], [c, d]]
        if (mat.r === 2) {

            a = mat[0][0];
            b = mat[0][1];
            c = mat[1][0];
            d = mat[1][1];

            det = a*d - b*c;

        // 3x3 case
        // [[a, b, c], [d, e, f], [g, h, k]]
        } else if (mat.r === 3) {

            a = mat[0][0];
            b = mat[0][1];
            c = mat[0][2];
            d = mat[1][0];
            e = mat[1][1];
            f = mat[1][2];
            g = mat[2][0];
            h = mat[2][1];
            k = mat[2][2];

            det = a*(e*k - f*h) - b*(k*d - f*g) + c*(d*h - e*g);
        }

        return det;
    },

    /**
     * Find the adjugate of a matrix.
     *
     * Note: Only works for 2x2 and 3x3 matrices.
     *
     * @param m {result of makeMatrix} the matrix
     */
    matrixAdj: function(mat) {
        mat = kmatrix.makeMatrix(mat);

        var a, b, c, d, e, f, g, h, k;
        var adj;

        // 2x2 case
        // [[a, b], [c, d]]
        if (mat.r === 2) {

            a = mat[0][0];
            b = mat[0][1];
            c = mat[1][0];
            d = mat[1][1];

            adj = [[d, -b], [-c, a]];

        // 3x3 case
        // [[a, b, c], [d, e, f], [g, h, k]]
        } else if (mat.r === 3) {

            a = mat[0][0];
            b = mat[0][1];
            c = mat[0][2];
            d = mat[1][0];
            e = mat[1][1];
            f = mat[1][2];
            g = mat[2][0];
            h = mat[2][1];
            k = mat[2][2];

            var A =  (e*k - f*h);
            var B = -(d*k - f*g);
            var C =  (d*h - e*g);
            var D = -(b*k - c*h);
            var E =  (a*k - c*g);
            var F = -(a*h - b*g);
            var G =  (b*f - c*e);
            var H = -(a*f - c*d);
            var K =  (a*e - b*d);

            adj = [[A, D, G], [B, E, H], [C, F, K]];
        }

        if (adj) {
            adj = kmatrix.makeMatrix(adj);
        }

        return adj;
    },

    /**
     * Find the inverse of a matrix.
     *
     * Note: Only works for 2x2 and 3x3 matrices.
     *
     * @param m {result of makeMatrix} the matrix
     * @param precision {int} number of decimal places to round to (optional)
     */
    matrixInverse: function(mat, precision) {
        var det = kmatrix.matrixDet(mat);

        // if determinant is undefined or 0, inverse does not exist
        if (!det) {
            return null;
        }

        var adj = kmatrix.matrixAdj(mat);

        if (!adj) {
            return null;
        }

        var inv = kmatrix.deepZipWith(2, function(val) {
            val = val / det;
            if (precision) {
                val = KhanUtil.roundTo(precision, val);
            }
            return val;
        }, adj);

        inv = kmatrix.makeMatrix(inv);

        return inv;
    },

    /**
     * Pad (or crop) the given matrix with the given padding value (`padval`)
     * until it is of dimensions `rows` x `cols`
     * @param  {result of makeMatrix} m
     * @param  {int} rows
     * @param  {int} cols
     * @param  {anything} padVal [defaults to "" if not specified]
     * @return {result of makeMatrix}
     */
    matrixPad: function(mat, rows, cols, padVal) {
        if (!mat) {
            return null;
        }

        mat = kmatrix.makeMatrix(mat);
        var matP = kmatrix.matrixCopy(mat);

        var finalCols = Math.max(cols, mat.c);

        if (padVal === undefined) {
            padVal = "";
        }

        // first add padding to the columns
        var dcols = cols - matP.c;
        if (dcols > 0) {
            _.times(matP.r, function(i) {
                _.times(dcols, function() {
                    matP[i].push(padVal);
                });
            });
        }

        // make new rows and fill with padding
        var drows = rows - matP.r;
        if (drows > 0) {
            _.times(drows, function() {
                var row = [];
                _.times(finalCols, function() {
                    row.push(padVal);
                });
                matP.push(row);
            });
        }

        return kmatrix.makeMatrix(matP);
    },

    // convert an array to a column matrix
    arrayToColumn: function(arr) {
        var col = [];

        _.each(arr, function(e) {
            col.push([e]);
        });

        return kmatrix.makeMatrix(col);
    },

    // convert a column matrix to an array
    columnToArray: function(col) {
        var arr = [];

        _.each(col, function(e) {
            arr.push(e[0]);
        });

        return arr;
    }
};

// TODO(jack): This is a hack to keep these functions
// showing up as "globals" in khan-exercises
_.each(kmatrix, function(func, name) {
    KhanUtil[name] = func;
});

return kmatrix;

});

define('utils/constructions.js',['require','./kmatrix.js'],function(require) {

var kmatrix = require("./kmatrix.js");

$.extend(KhanUtil, {
    drawHintLine: function(pt1, pt2, ticks) {
        var graphie = KhanUtil.currentGraph;

        var length = KhanUtil.eDist(pt1, pt2);
        var midpoint = [(pt1[0] + pt2[0]) / 2, (pt1[1] + pt2[1]) / 2];
        var angle = Math.atan2(pt2[1] - pt1[1], pt2[0] - pt1[0]);
        var transform = function(point) {
            var matrix = kmatrix.makeMatrix([
                [Math.cos(angle), -Math.sin(angle), midpoint[0]],
                [Math.sin(angle), Math.cos(angle), midpoint[1]],
                [0, 0, 1]
            ]);
            var vector = kmatrix.makeMatrix([[point[0]], [point[1]], [1]]);
            var prod = kmatrix.matrixMult(matrix, vector);
            return [prod[0], prod[1]];
        };

        var hintLine = graphie.raphael.set();

        hintLine.push(graphie.line(transform([-length / 2, 0]),
            transform([length / 2, 0]), {
                stroke: KhanUtil.BLUE,
                strokeWidth: 1,
                strokeDasharray: "- "
            }));
        graphie.style({
            stroke: KhanUtil.BLUE,
            strokeWidth: 1
        }, function() {
            if (ticks === 1) {
                hintLine.push(graphie.line(
                    transform(graphie.unscaleVector([0, 6])),
                    transform(graphie.unscaleVector([0, -6]))));
            } else if (ticks === 2) {
                hintLine.push(graphie.line(
                    transform(graphie.unscaleVector([-3, 6])),
                    transform(graphie.unscaleVector([-3, -6]))));
                hintLine.push(graphie.line(
                    transform(graphie.unscaleVector([3, 6])),
                    transform(graphie.unscaleVector([3, -6]))));
            } else if (ticks === 3) {
                hintLine.push(graphie.line(
                    transform(graphie.unscaleVector([-6, 6])),
                    transform(graphie.unscaleVector([-6, -6]))));
                hintLine.push(graphie.line(
                    transform(graphie.unscaleVector([0, 6])),
                    transform(graphie.unscaleVector([0, -6]))));
                hintLine.push(graphie.line(
                    transform(graphie.unscaleVector([6, 6])),
                    transform(graphie.unscaleVector([6, -6]))));
            }
        });
        return hintLine;
    },

    construction: {},

    // Useful for diagnostics: type "KhanUtil.showSnapPts()" in the console
    showSnapPts: function() {
        var graphie = KhanUtil.currentGraph;
        var set = graphie.raphael.set();
        _.each(KhanUtil.construction.interPoints, function(pt) {
            set.push(graphie.circle(pt, 0.1, {
                stroke: KhanUtil.PINK,
                fill: KhanUtil.PINK
            }));
        });
        _.each(KhanUtil.construction.snapPoints, function(pt) {
            set.push(graphie.circle(pt.coord, 0.1, {
                stroke: KhanUtil.RED,
                fill: KhanUtil.RED
            }));
        });
        _.delay(function() { set.remove(); }, 500);
    },

    // initialize the construction object, giving it a reference to the
    // graphie it should refer to (so that the KhanUtil.currentGraph
    // pointer can change without screwing everything up)
    addConstruction: function(graphieId) {
        var graphie = $("#" + graphieId).data("graphie");
        var construction = KhanUtil.construction = {
            tools: [], // a list of all compasses/straightedges on the graph
            tool: {}, // the latest tool added
            snapPoints: [], // "special" points all other points should snap to
            interPoints: [], // "special" points all other points should snap to
            snapLines: [] // points should also snap to lines
        };

        // add a compass tool to the graph
        // the compass has the following fields:
        // center: movable point
        // radius: int
        // circ: graphie circle
        // perim: invisible mouse target for dragging/changing radius
        construction.addCompass = function() {
            var start = [Math.random() * 4 - 2, Math.random() * 4 - 2];
            var startRadius = Math.random() + 1.5;
            construction.tool = {
                interType: "circle",
                center: graphie.addMovablePoint({
                        graph: graphie,
                        coord: start,
                        normalStyle: {
                            stroke: KhanUtil.BLUE,
                            fill: KhanUtil.BLUE
                        }
                    }),
                radius: startRadius,
                circ: graphie.circle(start, startRadius, {
                        stroke: KhanUtil.BLUE,
                        strokeDasharray: "- ",
                        fill: KhanUtil.ORANGE,
                        fillOpacity: 0
                    }),
                perim: graphie.mouselayer.circle(
                        graphie.scalePoint(start)[0],
                        graphie.scalePoint(start)[1],
                        graphie.scaleVector(startRadius)[0]).attr({
                            "stroke-width": 20,
                            "opacity": 0.0
                        })
            };

            var t = construction.tool;

            $(t.center.mouseTarget[0]).bind(
                "vmouseover vmouseout", function(event) {
                    if (t.center.highlight) {
                        t.circ.animate({
                            stroke: KhanUtil.ORANGE,
                            "fill-opacity": 0.05
                        }, 50);
                    } else {
                        t.circ.animate({
                            stroke: KhanUtil.BLUE,
                            "fill-opacity": 0
                        }, 50);
                    }
                });

            // add this tool to the graph's set
            construction.tools.push(t);

            // add new points that all other points should snap to
            construction.snapPoints.push(t.center);



            t.center.onMove = function(x, y) {
                t.circ.toFront();
                t.perim.toFront();
                t.center.visibleShape.toFront();
                t.center.mouseTarget.toFront();
                t.circ.attr({
                    cx: graphie.scalePoint(x)[0],
                    cy: graphie.scalePoint(y)[1]
                });
                t.perim.attr({
                    cx: graphie.scalePoint(x)[0],
                    cy: graphie.scalePoint(y)[1]
                });
            };

            t.center.onMoveEnd = function(x, y) {
                _.each(construction.snapLines, function(line) {
                    var distIntersect = KhanUtil.lDist(t.center.coord, line);
                    if (distIntersect[0] < 0.25) {
                        t.center.onMove(distIntersect[1][0],
                            distIntersect[1][1]);
                        t.center.setCoord(distIntersect[1]);
                    }
                });

                // keep track of all the possible snap points,
                // and snap to the closest one
                var myPossibleSnaps = [];
                _.each(construction.snapPoints, function(point) {
                    if (KhanUtil.eDist(t.center.coord, point.coord) < 0.25 &&
                            t.center.coord !== point.coord) {
                        myPossibleSnaps.push(point.coord);
                    }
                });

                // before checking to see if we've moved onto an
                // intersection of lines/circles, update these
                // intersections
                construction.updateIntersections();
                _.each(construction.interPoints, function(point) {
                    if (KhanUtil.eDist(t.center.coord, point) < 0.3 &&
                            t.center.coord !== point) {
                        myPossibleSnaps.push(point);
                    }
                });

                // Now, snap to closest possible snap Point
                var mySnapPoint = [];
                var mySnapDist = null;
                _.each(myPossibleSnaps, function(sCoord) {
                    if (mySnapDist == null ||
                            KhanUtil.eDist(sCoord, t.center.coord) <
                            mySnapDist) {
                        mySnapPoint = sCoord;
                        mySnapDist = KhanUtil.eDist(sCoord, t.center.coord);
                    }
                });

                if (mySnapPoint.length > 0) {
                    t.center.onMove(mySnapPoint[0], mySnapPoint[1]);
                    t.center.setCoord(mySnapPoint);
                }
            };

            t.center.mouseTarget.dblclick(function() {
                construction.removeTool(t, true);
            });

            $(t.perim[0]).css("cursor", "move");
            $(t.perim[0]).bind(
                "vmouseover vmouseout vmousedown", function(event) {
                    if (event.type === "vmouseover") {
                        t.highlight = true;
                        if (!KhanUtil.dragging) {
                            t.circ.animate({
                                stroke: KhanUtil.ORANGE,
                                "fill-opacity": 0.05
                            }, 50);
                            t.center.visibleShape.animate({
                                stroke: KhanUtil.ORANGE,
                                fill: KhanUtil.ORANGE
                            }, 50);
                        }

                    } else if (event.type === "vmouseout") {
                        t.highlight = false;
                        if (!t.dragging) {
                            t.circ.animate({
                                stroke: KhanUtil.BLUE,
                                "fill-opacity": 0
                            }, 50);
                            t.center.visibleShape.animate({
                                stroke: KhanUtil.BLUE,
                                fill: KhanUtil.BLUE
                            }, 50);
                        }

                    } else if (event.type === "vmousedown" &&
                            (event.which === 1 || event.which === 0)) {
                        event.preventDefault();
                        var data = t;
                        data.circ.toFront();
                        data.perim.toFront();
                        data.center.visibleShape.toFront();
                        data.center.mouseTarget.toFront();

                        $(document).bind("vmousemove vmouseup", function(event) {
                            event.preventDefault();
                            data.dragging = true;
                            KhanUtil.dragging = true;

                            if (event.type === "vmousemove") {
                                var mouseX = event.pageX -
                                    $(graphie.raphael.canvas.parentNode).offset().left;
                                var mouseY = event.pageY -
                                    $(graphie.raphael.canvas.parentNode).offset().top;

                                data.radius = KhanUtil.eDist(data.center.coord,
                                    graphie.unscalePoint([mouseX, mouseY]));
                                data.perim.attr({
                                    r: graphie.scaleVector(data.radius)[0]
                                });
                                data.circ.attr({
                                    rx: graphie.scaleVector(data.radius)[0],
                                    ry: graphie.scaleVector(data.radius)[1]
                                });

                            } else if (event.type === "vmouseup") {
                                $(document).unbind("vmousemove vmouseup");
                                data.dragging = false;
                                KhanUtil.dragging = false;
                                construction.updateIntersections();
                            }
                        });
                    }
            });
            construction.updateIntersections();
        };


        construction.mark = function() {
            var x = -1;
            var y = Math.random() * 2;

            construction.tool = {
                interType: "line",
                center: graphie.addMovablePoint({
                        graph: graphie,
                        coordX: x,
                        coordY: y,
                        normalStyle: {
                            stroke: KhanUtil.BLUE,
                            fill: KhanUtil.BLUE
                        }
                    })
            };

            // this is a bit confusing: "graph: graphie" refers
            // to the movableLineSegment's graph field, whereas
            // "construction.tool.etc" refers to the KhanUtil.construction
            // object being built in this util
            construction.tool.line1 = graphie.addMovableLineSegment({
                    graph: graphie,
                    pointA: [x + 0.2, y + 0.2],
                    pointZ: [x - 0.2, y - 0.2],
                    normalStyle: {
                        stroke: KhanUtil.BLUE,
                        "stroke-width": 2
                    },
                    highlightStyle: {
                        stroke: KhanUtil.ORANGE,
                        "stroke-width": 3
                    },
                    movePointsWithLine: true
                });

            construction.tool.line2 = graphie.addMovableLineSegment({
                    graph: graphie,
                    pointA: [x + 0.2, y - 0.2],
                    pointZ: [x - 0.2, y + 0.2],
                    normalStyle: {
                        stroke: KhanUtil.BLUE,
                        "stroke-width": 2
                    },
                    highlightStyle: {
                        stroke: KhanUtil.ORANGE,
                        "stroke-width": 3
                    },
                    movePointsWithLine: true
                });

            $(construction.tool.center.mouseTarget[0]).bind(
                "vmouseover vmouseout", construction.tool, function(event) {
                    if (event.data.center.highlight) {
                        event.data.line1.visibleLine.animate({
                            stroke: KhanUtil.ORANGE
                        }, 50);
                        event.data.line2.visibleLine.animate({
                            stroke: KhanUtil.ORANGE
                        }, 50);
                    } else {
                        event.data.line1.visibleLine.animate({
                            stroke: KhanUtil.BLUE
                        }, 50);
                        event.data.line2.visibleShape.animate({
                            stroke: KhanUtil.BLUE
                        }, 50);
                    }
                });

            // add new tool object to graph's collection
            construction.tools.push(construction.tool);

            // keep track of all the points/lines that points should snap to
            construction.snapPoints.push(construction.tool.center);

            var t = construction.tool;

            t.center.onMoveEnd = function(dX, dY) {
                t.line1.visibleLine.toFront();
                t.line1.mouseTarget.toFront();
                t.line2.visibleLine.toFront();
                t.line2.mouseTarget.toFront();
                t.center.visibleShape.toFront();
                t.center.mouseTarget.toFront();
                //t.first.onMoveEnd(t.first.coord[0], t.first.coord[1]);
                //t.second.onMoveEnd(t.second.coord[0], t.second.coord[1]);
            };
            
            $(t.center.mouseTarget[0]).bind("dblclick", function() {
                construction.removeTool(t, true);
            });

            construction.updateIntersections();
        };

        // add a straightedge object
        // the straightedge object has the following fields
        // first, second: movable endpoints
        // edge: movable line segment
        construction.addStraightedge = function(extend) {
            extend = extend == null ? true : extend;

            construction.tool = {
                interType: "line",
                first: graphie.addMovablePoint({
                        graph: graphie,
                        coordX: -1, coordY: Math.random() * 2,
                        normalStyle: {
                            stroke: KhanUtil.BLUE,
                            fill: KhanUtil.BLUE
                        }
                    }),
                second: graphie.addMovablePoint({
                        graph: graphie,
                        coordX: 1, coordY: Math.random() * 2,
                        normalStyle: {
                            stroke: KhanUtil.BLUE,
                            fill: KhanUtil.BLUE
                        }
                    })
            };

            // this is a bit confusing: "graph: graphie" refers
            // to the movableLineSegment's graph field, whereas
            // "construction.tool.etc" refers to the KhanUtil.construction
            // object being built in this util
            construction.tool.edge = graphie.addMovableLineSegment({
                    graph: graphie,
                    pointA: construction.tool.first,
                    pointZ: construction.tool.second,
                    normalStyle: {
                        stroke: KhanUtil.BLUE,
                        "stroke-width": 2
                    },
                    highlightStyle: {
                        stroke: KhanUtil.ORANGE,
                        "stroke-width": 3
                    },
                    extendLine: extend,
                    movePointsWithLine: true
                });

            $(construction.tool.first.mouseTarget[0]).bind(
                "vmouseover vmouseout", construction.tool, function(event) {
                    if (event.data.first.highlight) {
                        event.data.edge.visibleLine.animate({
                            stroke: KhanUtil.ORANGE
                        }, 50);
                        event.data.second.visibleShape.animate({
                            stroke: KhanUtil.ORANGE,
                            fill: KhanUtil.ORANGE
                        }, 50);
                    } else {
                        event.data.edge.visibleLine.animate({
                            stroke: KhanUtil.BLUE
                        }, 50);
                        event.data.second.visibleShape.animate({
                            stroke: KhanUtil.BLUE,
                            fill: KhanUtil.BLUE
                        }, 50);
                    }
                });
            $(construction.tool.second.mouseTarget[0]).bind(
                "vmouseover vmouseout", construction.tool, function(event) {
                    if (event.data.second.highlight) {
                        event.data.edge.visibleLine.animate({
                            stroke: KhanUtil.ORANGE
                        }, 50);
                        event.data.first.visibleShape.animate({
                            stroke: KhanUtil.ORANGE,
                            fill: KhanUtil.ORANGE
                        }, 50);
                    } else {
                        event.data.edge.visibleLine.animate({
                            stroke: KhanUtil.BLUE
                        }, 50);
                        event.data.first.visibleShape.animate({
                            stroke: KhanUtil.BLUE,
                            fill: KhanUtil.BLUE
                        }, 50);
                    }
                });
            $(construction.tool.edge.mouseTarget[0]).bind(
                "vmouseover vmouseout", construction.tool, function(event) {
                    if (event.data.edge.highlight) {
                        event.data.first.visibleShape.animate({
                            stroke: KhanUtil.ORANGE,
                            fill: KhanUtil.ORANGE
                        }, 50);
                        event.data.second.visibleShape.animate({
                            stroke: KhanUtil.ORANGE,
                            fill: KhanUtil.ORANGE
                        }, 50);
                    } else {
                        event.data.first.visibleShape.animate({
                            stroke: KhanUtil.BLUE,
                            fill: KhanUtil.BLUE
                        }, 50);
                        event.data.second.visibleShape.animate({
                            stroke: KhanUtil.BLUE,
                            fill: KhanUtil.BLUE
                        }, 50);
                    }
                });

            // add new tool object to graph's collection
            construction.tools.push(construction.tool);

            // keep track of all the points/lines that points
            // should snap to
            construction.snapPoints.push(construction.tool.first);
            construction.snapPoints.push(construction.tool.second);

            construction.snapLines.push(construction.tool.edge);

            var t = construction.tool;

            //t.edge.toBack();

            t.edge.onMoveEnd = function(dX, dY) {
                t.edge.visibleLine.toFront();
                t.edge.mouseTarget.toFront();
                t.first.visibleShape.toFront();
                t.first.mouseTarget.toFront();
                t.second.visibleShape.toFront();
                t.second.mouseTarget.toFront();
                t.first.onMoveEnd(t.first.coord[0], t.first.coord[1]);
                t.second.onMoveEnd(t.second.coord[0], t.second.coord[1]);
            };

            var endpointMoveEnd = function(x, y, end) {
                _.each(construction.snapLines, function(line) {
                    var distIntersect = KhanUtil.lDist(end.coord, line);
                    if (distIntersect[0] < 0.25) {
                        end.setCoord(distIntersect[1]);
                        end.updateLineEnds();
                    }
                });

                // keep track of all the possible snap points,
                // and snap to the closest one
                var myPossibleSnaps = [];
                _.each(construction.snapPoints, function(point) {
                    if (KhanUtil.eDist(end.coord, point.coord) < 0.25 &&
                            end.coord !== point.coord) {
                        myPossibleSnaps.push(point.coord);
                    }
                });

                // before checking to see if we've moved onto an
                // intersection of lines/circles, update these
                // intersections
                construction.updateIntersections();
                _.each(construction.interPoints, function(point) {
                    if (KhanUtil.eDist(end.coord, point) < 0.3 &&
                            end.coord !== point) {
                        myPossibleSnaps.push(point);
                    }
                });

                // Now, snap to closest possible snap Point
                var mySnapPoint = [];
                var mySnapDist = null;
                _.each(myPossibleSnaps, function(sCoord) {
                    if (mySnapDist == null ||
                            KhanUtil.eDist(sCoord, end.coord) < mySnapDist) {
                        mySnapPoint = sCoord;
                        mySnapDist = KhanUtil.eDist(sCoord, end.coord);
                    }
                });

                if (mySnapPoint.length > 0) {
                    end.setCoord(mySnapPoint);
                    end.updateLineEnds();
                }
                t.edge.visibleLine.toFront();
                t.edge.mouseTarget.toFront();
                t.first.visibleShape.toFront();
                t.first.mouseTarget.toFront();
                t.second.visibleShape.toFront();
                t.second.mouseTarget.toFront();
            };

            t.first.onMoveEnd = function(x, y) {
                endpointMoveEnd(x, y, t.first);
            };
            t.second.onMoveEnd = function(x, y) {
                endpointMoveEnd(x, y, t.second);
            };

            $(t.first.mouseTarget[0]).bind("dblclick", function() {
                construction.removeTool(t, true);
            });

            $(t.second.mouseTarget[0]).bind("dblclick", function() {
                construction.removeTool(t, true);
            });

            $(t.edge.mouseTarget[0]).bind("dblclick", function() {
                construction.removeTool(t, true);
            });
            construction.updateIntersections();
        };


        construction.removeTool = function(tool, updateTools) {
            _.each(_.keys(tool), function(key) {
                if (key === "center" || key === "perimeter" ||
                        key === "first" || key === "second") {
                    tool[key].visibleShape.remove();
                    tool[key].visible = false;
                    $(tool[key].mouseTarget[0]).remove();
                } else if (key === "circ") {
                    tool[key].remove();
                } else if (key === "edge") {
                    tool[key].remove();
                }
            });

            if (updateTools) {
                construction.tools.splice(_.indexOf(construction.tools, tool), 1);
            }
        };


        // remove ALL the tools
        construction.removeAllTools = function() {
            var staticTools = [];
            _.each(construction.tools, function(tool) {
                if (tool.dummy) {
                    staticTools.push(tool);
                } else {
                    construction.removeTool(tool, false);
                }
            });

            construction.tools = staticTools;
            construction.snapPoints = [];
            construction.interPoints = [];
            construction.snapLines = [];
        };

        // detect intersections between existing circles,
        // lines, so that new points can snap to these intersections
        construction.updateIntersections = function() {
            construction.interPoints = [];
            _.each(construction.tools, function(tool1) {
                _.each(construction.tools, function(tool2) {
                    if (tool1 !== tool2) {
                        // two lines
                        if (tool1.interType === "line" &&
                            tool2.interType === "line") {
                            construction.interPoints.push(
                                findIntersection([tool1.first.coord,
                                    tool1.second.coord],
                                [tool2.first.coord, tool2.second.coord])
                                .slice(0, 2));
                        }
                        // a line and a circle
                        else if (tool1.interType === "line" &&
                                tool2.interType === "circle") {

                            var m = (tool1.second.coord[1] -
                                    tool1.first.coord[1]) /
                                    (tool1.second.coord[0] -
                                    tool1.first.coord[0]);
                            var yint = tool1.first.coord[1] -
                                    m * tool1.first.coord[0];


                            // solve for x-values of intersections
                            // (x - cX)^2 + (y - cY)^2 = radius
                            var cX = tool2.center.coord[0];
                            var cY = tool2.center.coord[1];
                            var rad = tool2.radius;

                            // baby why you gotta play me like that
                            var a = 1 + Math.pow(m, 2);
                            var b = (-2 * cX + 2 * m * yint - 2 * cY * m);
                            var c = (Math.pow(yint, 2) - 2 * yint * cY +
                                Math.pow(cY, 2) + Math.pow(cX, 2) -
                                Math.pow(rad, 2));

                            var x1 = (-b + Math.sqrt(Math.pow(b, 2) -
                                4 * a * c)) / (2 * a);
                            var x2 = (-b - Math.sqrt(Math.pow(b, 2) -
                                4 * a * c)) / (2 * a);


                            if (!isNaN(x1)) {
                                var y1 = m * x1 + yint;
                                construction.interPoints.push([x1, y1]);
                            }
                            if (!isNaN(x2)) {
                                var y2 = m * x2 + yint;
                                construction.interPoints.push([x2, y2]);
                            }
                        }
						// two circles
                        else if (tool1.center != null && tool2.center != null) {
                            var a = tool1.center.coord[0];
                            var b = tool1.center.coord[1];
                            var c = tool2.center.coord[0];
                            var d = tool2.center.coord[1];
                            var r = tool1.radius;
                            var s = tool2.radius;

                            var e = c - a;
                            var f = d - b;
                            var p = Math.sqrt(Math.pow(e, 2) + Math.pow(f, 2));
                            var k = (Math.pow(p, 2) + Math.pow(r, 2) -
                                    Math.pow(s, 2)) / (2 * p);

                            var x1 = a + e * k / p + (f / p) *
                                Math.sqrt(Math.pow(r, 2) - Math.pow(k, 2));
                            var y1 = b + f * k / p - (e / p) *
                                Math.sqrt(Math.pow(r, 2) - Math.pow(k, 2));

                            var x2 = a + e * k / p - (f / p) *
                                Math.sqrt(Math.pow(r, 2) - Math.pow(k, 2));
                            var y2 = b + f * k / p + (e / p) *
                                Math.sqrt(Math.pow(r, 2) - Math.pow(k, 2));

                            if (!isNaN(x1)) {
                                construction.interPoints.push([x1, y1]);
                            }
                            if (!isNaN(x2)) {
                                construction.interPoints.push([x2, y2]);
                            }
                        }
                    }
                });
            });
        };

    },

    // add non-interactive straightedge
    addDummyStraightedge: function(coord1, coord2, extend) {
        var construction = KhanUtil.construction;
        extend = extend == null ? true : extend;
        construction.tool = {
            interType: "line",
            dummy: true,
            first: {coord: [coord1, coord2]},
            second: {coord: [coord1, coord2]},
            edge: KhanUtil.currentGraph.addMovableLineSegment({
                coordA: coord1,
                coordZ: coord2,
                normalStyle: {stroke: "black", "stroke-width": 2},
                highlightStyle: {stroke: KhanUtil.BLUE, "stroke-width": 3},
                extendLine: extend,
                fixed: true
            })
        };
        // not sure about execution order here (vis-a-vis addConstruction),
        // so be careful
        if (construction.tools == null) {
            construction.tools = [construction.tool];
        } else {
            construction.tools.push(construction.tool);
        }
        if (construction.snapLines == null) {
            construction.snapLines = [construction.tool.edge];
        } else {
            construction.snapLines.push(construction.tool.edge);
        }
        KhanUtil.construction.updateIntersections();
    },

    // add non-interactive circle
    addDummyCircle: function(center, radius) {
        var construction = KhanUtil.construction;
        var dummy = {coord: center};

        KhanUtil.currentGraph.circle(center, {
            r: radius,
            fill: "none",
            stroke: "black",
            "stroke-width": 2
        });

        if (construction.snapPoints == null) {
            construction.snapPoints = [dummy];
        } else {
            construction.snapPoints.push(dummy);
        }
        KhanUtil.construction.updateIntersections();
    },

    // add non-interactive point (can't just use circle or snapping
    // won't work)
    addDummyPoint: function(coordinates) {
        var dummy = {coord: coordinates};
        KhanUtil.currentGraph.circle(coordinates,
                                {r: 0.08, fill: "black", stroke: "none"});

        var construction = KhanUtil.construction;
        if (construction.snapPoints == null) {
            construction.snapPoints = [dummy];
        } else {
            construction.snapPoints.push(dummy);
        }
        KhanUtil.construction.updateIntersections();
    },

    // add non-interactive ray
    addDummyRay: function(end, other) {
        var construction = KhanUtil.construction;
        construction.tool = {interType: "line", dummy: true,
                      first: {coord: end},
                      second: {coord: other},
                      edge: {coordA: end, coordZ: other}};

        KhanUtil.currentGraph.line(end, other,
            {stroke: "black", "stroke-width": 2, arrows: "->"});

        KhanUtil.addDummyPoint(end);

        // not sure about execution order here (vis-a-vis addConstruction),
        // so be careful
        if (construction.tools == null) {
            construction.tools = [construction.tool];
        } else {
            construction.tools.push(construction.tool);
        }
        if (construction.snapLines == null) {
            construction.snapLines = [construction.tool.edge];
        } else {
            construction.snapLines.push(construction.tool.edge);
        }
        KhanUtil.construction.updateIntersections();
    },

    constructionGuess: null,

    // show guess, given pruned tools which
    // only store coordinates of important
    // points
    showConstructionGuess: function(guessTools) {
        var graph = KhanUtil.currentGraph;
        if (KhanUtil.constructionGuess != null) {
            KhanUtil.constructionGuess.remove();
        }
        KhanUtil.constructionGuess = graph.raphael.set();
        _.each(guessTools, function(tool) {
            if (tool.first != null) {
                KhanUtil.constructionGuess.push(graph.addMovableLineSegment({
                    coordA: tool.first.coord,
                    coordZ: tool.second.coord,
                    normalStyle: {
                        stroke: KhanUtil.BLUE,
                        "stroke-width": 2
                    },
                    extendLine: true,
                    fixed: true
                }).visibleLine);
                KhanUtil.constructionGuess.push(graph.circle(
                    tool.first.coord, 0.1, {
                        fill: KhanUtil.BLUE,
                        stroke: null
                    }));
                KhanUtil.constructionGuess.push(graph.circle(
                    tool.second.coord, 0.1, {
                        fill: KhanUtil.BLUE,
                        stroke: null
                    }));
            } else if (tool.center != null) {
                KhanUtil.constructionGuess.push(graph.circle(
                    tool.center.coord, 0.1, {
                        fill: KhanUtil.BLUE,
                        stroke: null
                    }));
                KhanUtil.constructionGuess.push(graph.circle(
                    tool.center.coord, tool.radius, {
                        fill: "none",
                        stroke: KhanUtil.BLUE,
                        strokeDasharray: "- "
                    }));
            }
        });
    },

    // shorthand for euclidean distance
    // maybe I value brevity too much?
    eDist: function(coords1, coords2) {
        return Math.sqrt(Math.pow(coords1[0] - coords2[0], 2) +
                Math.pow(coords1[1] - coords2[1], 2));
    },

    // distance from a point to a line, measured
    // as the distance along a perpendicular
    lDist: function(coord, line) {
        var slope = (line.coordZ[1] - line.coordA[1]) /
                (line.coordZ[0] - line.coordA[0]);
        var perpSlope = slope === 0 ? "vert" : -1 / slope;
        var coord2;
        if (perpSlope === "vert") {
            coord2 = [coord[0], coord[1] + 1];
        } else {
            coord2 = [coord[0] + 1, coord[1] + perpSlope];
        }

        var intersect = findIntersection([coord, coord2],
                                     [line.coordA, line.coordZ]);

        return [KhanUtil.eDist(intersect, coord), intersect];
    },

    // Find whether two points are a given distance apart
    // given a certain precision
    distEqual: function(p1, p2, distance, precision) {
        precision = precision || 0.5;
        return Math.abs(KhanUtil.eDist(p1, p2) - distance) < precision;

    },

    // Find whether a line has a given angle
    // to a certain precision (in degrees)
    angleEqual: function(line, angle, precision) {
        var ang = Math.atan2(line.second.coord[1] - line.first.coord[1],
                             line.second.coord[0] - line.first.coord[0]);

        ang *= 180 / Math.PI;
        if (ang < 0) {
            ang += 180;
        }
        return Math.abs(angle - ang) < precision;
    },

    // Given an array of construction tools, return an array
    // with either coordinates of a line and the center and
    // radius of a circle.
    // Submitted as the guess for a construction problem
    getToolProperties: function (construction) {
        return _.map(_.filter(construction.tools, function(tool) {
            return tool.dummy !== true;
        }), function(tool) {
            if (tool.first != null) {
                return {
                    first: {
                        coord: [
                            tool.first.coord[0],
                            tool.first.coord[1]
                        ]
                    },
                    second: {
                        coord: [
                            tool.second.coord[0],
                            tool.second.coord[1]
                        ]
                    }
                };
            } else if (tool.center != null) {
                return {
                    center: {
                        coord: [
                            tool.center.coord[0],
                            tool.center.coord[1]
                        ]
                    },
                    radius: tool.radius
                };
            }
        });
    },

    findCompass: function (guess, properties) {
        var testFunctions = [];

        if (properties.radius != null) {
            testFunctions.push(function (tool) {
                return Math.abs(tool.radius - properties.radius) < 0.5;
            });
        }

        if (properties.cx != null) {
            testFunctions.push(function (tool) {
                return Math.abs(tool.center.coord[0] - properties.cx) < 0.5;
            });
        }

        if (properties.cy != null) {
            testFunctions.push(function (tool) {
                return Math.abs(tool.center.coord[1] - properties.cy) < 0.5;
            });
        }

        if (properties.center != null) {
            testFunctions.push(function (tool) {
                return Math.abs(tool.center.coord[0] - properties.center[0]) < 0.5 &&
                    Math.abs(tool.center.coord[1] - properties.center[1]) < 0.5;
            });
        }

        return _.filter(guess, function(tool) {
            if (tool.center != null) {
                for (var i = 0; i < testFunctions.length; i++) {
                    if (!testFunctions[i](tool)) {
                        return false;
                    }
                }
                return true;
            }
        });
    },

    // Given a set of tools (guess), a circle and a number of sides
    // return the lines that form an inscribed shape with n sides
    findInscribedPolygon: function (guess, center, radius, n) {
        var interiorAngle = 2 * Math.PI / n;
        var sideLength = 2 * radius * Math.sin(interiorAngle / 2);

        // Get array of line of the correct length and with end points on the circle
        var lines = _.filter(guess, function(tool) {
            return tool.first != null &&
                KhanUtil.distEqual(tool.first.coord, tool.second.coord, sideLength, 0.3) &&
                KhanUtil.distEqual(tool.first.coord, center, radius, 0.3) &&
                KhanUtil.distEqual(tool.second.coord, center, radius, 0.3);
        });

        if (lines.length < n) {
            return false;
        }

        // Find one angle so we can find the offset
        var offsetAngle = 180 + Math.atan2(lines[0].first.coord[1], lines[0].first.coord[0]) * 180 / Math.PI;

        // Find angles to line points
        var angles = [];
        _.map(lines, function(tool) {
            var angle1 = Math.atan2(tool.first.coord[1], tool.first.coord[0]) * 180 / Math.PI; 
            var angle2 = Math.atan2(tool.second.coord[1], tool.second.coord[0]) * 180 / Math.PI; 
            angles.push((angle1 - offsetAngle + 540 + 180 / n) % 360);
            angles.push((angle2 - offsetAngle + 540 + 180 / n) % 360);
        });

        // Get an object of the angles we expect vertices to be at
        // Plus half the base angle so it's easier to compare differences from angles
        // e.g. [0 + 45, 90 + 45, 180 + 45, 270 + 45] for a square
        // Mean we can count them - there should be two each
        var targetAngles = {};
        for (var i = 0; i < n; i++) {
            targetAngles[(i + 0.5) * 360 / n] = 0;
        }

        // Go through all angles and see if they are with +/-4 degrees of the target angles
        var threshold = 4;
        _.map(angles, function(angle) {
            for (var i = 0; i < n; i++) {
                var targetAngle = (i + 0.5) * 360 / n;
                if (Math.abs(angle - targetAngle) < threshold) {
                    targetAngles[targetAngle]++;
                    break;
                }
            }
        });

        //console.log(targetAngles);

        // Check that each angles occurs twice
        for (var angle in targetAngles) {
            if (targetAngles[angle] !== 2) {
                return false;
            }
        }

        return lines;
    }
});

});

define('utils/convert-values.js',['require'],function(require) {

$.extend(KhanUtil, {
    trigFunc: {
        csc: {name: "csc", print: function(angle) {
            return KhanUtil.trigFunc.sec.print(90 - angle);
        },
        convertsTo: ["sin"],
        convertTo: function(type, angle) {
            if (type.name === "sin") {
                var cscv = KhanUtil.trigFunc.csc.print(angle);
                var sinv = KhanUtil.trigFunc.sin.print(angle);
                var toReturn = [];
                toReturn.push("\\csc x = \\frac{1}{\\sin x}");
                toReturn.push("\\csc x = " + cscv);
                toReturn.push("\\frac{1}{\\sin x} = " + cscv);
                toReturn.push("\\sin x = " + sinv);
                return toReturn;
            }

        }
    },
    sec: {name: "sec", print: function(angle) {
        if (angle === 0) {
            return 1;
        }
        else if (angle === 30) {
            return "\\frac{2 \\sqrt 3}{3}";
        }
        else if (angle === 45) {
            return "\\sqrt 2";
        }
        else if (angle === 60) {
            return "2";
        }
        else if (angle === 90) {
            return "undefined";
        }
        return "undef";
    },
    convertsTo: ["cos", "tan"],
    convertTo: function(type, angle) {
        if (type.name === "cos") {
            var cosv = KhanUtil.trigFunc.cos.print(angle);
            var secv = KhanUtil.trigFunc.sec.print(angle);
            var toReturn = [];
            toReturn.push("\\sec x = \\frac{1}{\\cos x}");
            toReturn.push("\\sec x = " + secv);
            toReturn.push("\\frac{1}{\\cos x} = " + secv);
            toReturn.push("\\cos x = " + cosv);
            return toReturn;
        }
        else if (type.name === "tan") {
            var tanv = KhanUtil.trigFunc.tan.print(angle);
            var secv = KhanUtil.trigFunc.sec.print(angle);
            var toReturn = [];
            toReturn.push("\\sin^2 x + \\cos^2 x = 1");
            toReturn.push("\\frac{\\sin^2 x}{\\cos^2 x} + \\frac{\\cos^2 x}{\\cos^2 x} = \\frac{1}{\\cos^2 x}");
            toReturn.push("\\tan^2 x + 1 = \\sec^2 x");
            toReturn.push("\\tan^2 x + 1 = (" + secv + ")^2");
            toReturn.push("\\tan^2 x = (" + secv + ")^2 - 1");
            toReturn.push("\\tan x = \\sqrt { " + secv + "  ^2 - 1 }");
            toReturn.push("\\tan x = " + tanv);
            return toReturn;
        }
    }
},
tan: {name: "tan", print: function(angle) {
    if (angle === 0) {
        return 0;
    }
    else if (angle === 30) {
        return "\\frac{\\sqrt 3}{3}";
    }
    else if (angle === 45) {
        return "1";
    }
    else if (angle === 60) {
        return "\\sqrt 3";
    }
    else if (angle === 90) {
        return "undefined";
    }
    return "undef";

},
convertsTo: ["sec"],
convertTo: function(type, angle) {
    if (type.name === "sec") {

        var tanv = KhanUtil.trigFunc.tan.print(angle);
        var secv = KhanUtil.trigFunc.sec.print(angle);
        var toReturn = [];
        toReturn.push("\\sin^2 x + \\cos^2 x = 1");
        toReturn.push("\\frac{\\sin^2 x}{\\cos^2 x} + \\frac{\\cos^2 x}{\\cos^2 x} = \\frac{1}{\\cos^2 x}");
        toReturn.push("\\tan^2 x + 1 = \\sec^2 x");
        toReturn.push("(" + tanv + ")^2 + 1 = \\sec^2 x");
        toReturn.push("\\sqrt{(" + tanv + ")^2 + 1} = \\sec x");
        toReturn.push(secv + " = \\sec x");
        return toReturn;
    }
}
},
cos: {name: "cos", print: function(angle) {
    return KhanUtil.trigFunc.sin.print(90 - angle);
},
convertsTo: ["sin", "sec"],
convertTo: function(type, angle) {
    var toReturn = [];
    var cosv;
    var sinv;
    var secv;
    if (type.name === "sin") {
        cosv = KhanUtil.trigFunc.cos.print(angle);
        sinv = KhanUtil.trigFunc.sin.print(angle);
        toReturn.push("\\sin^2 x + \\cos^2 x = 1");
        toReturn.push("\\sin^2 x + (" + cosv + ")^2 = 1");
        toReturn.push("(" + cosv + ")^2 = 1 - \\sin^2 x");
        toReturn.push("(" + cosv + ")^2 - 1 = - \\sin^2 x");
        toReturn.push("-(" + cosv + ")^2 + 1 = \\sin^2 x");
        toReturn.push(sinv + " = \\sin x");
        return toReturn;
    }
    else if (type.name === "sec") {
        cosv = KhanUtil.trigFunc.cos.print(angle);
        secv = KhanUtil.trigFunc.sec.print(angle);
        toReturn.push(cosv + " = \\cos x");
        toReturn.push(secv + " = \\frac{1}{\\cos x}");
        toReturn.push(secv + " = \\sec x");
        return toReturn;
    }
}
},
sin: {name: "sin", print: function(angle) {
    if (angle === 0) {
        return 0;
    }
    else if (angle === 30) {
        return "\\frac{1}{2}";
    }
    else if (angle === 45) {
        return "\\frac{\\sqrt 2}{2}";
    }
    else if (angle === 60) {
        return "\\frac{\\sqrt 3}{2}";
    }
    else if (angle === 90) {
        return "1";
    }
    return "undefined";
},
convertsTo: ["cos", "csc"],
convertTo: function(type, angle) {
    if (type.name === "cos") {
        var sinv = KhanUtil.trigFunc.sin.print(angle);
        var cosv = KhanUtil.trigFunc.cos.print(angle);
        var toReturn = [];
        toReturn.push("\\sin^2 x + \\cos^2 x = 1");
        toReturn.push("(" + sinv + ")^2 + \\cos^2 x = 1");
        toReturn.push("(" + sinv + ")^2 = 1- \\cos^2 x ");
        toReturn.push("(" + sinv + ")^2 - 1 = - \\cos^2 x ");
        toReturn.push("-(" + sinv + ")^2 + 1 = \\cos^2 x ");
        toReturn.push(cosv + " =  \\cos x");
        return toReturn;

    }
    else if (type.name === "csc") {
        var sinv = KhanUtil.trigFunc.sin.print(angle);
        var cscv = KhanUtil.trigFunc.csc.print(angle);
        var toReturn = [];
        toReturn.push(sinv + " = \\sin x");
        toReturn.push(cscv + " = \\frac{1}{\\sin x}");
        toReturn.push(cscv + " = \\csc x");
        return toReturn;
    }
}

}
}});

$.extend(KhanUtil, {
    trigTypes: [KhanUtil.trigFunc.sin, KhanUtil.trigFunc.cos, KhanUtil.trigFunc.tan, KhanUtil.trigFunc.csc, KhanUtil.trigFunc.sec],

    findSteps: function(start, end, value) {
        var visited = {};
        var queue = [];
        var next = start;
        while (next.name !== end.name) {
            if (next.convertsTo) {
                $.each(next.convertsTo, function(i, str) {
                    if (! (str in visited)) {
                        var move = KhanUtil.trigFunc[str];
                        move.parent = next;
                        queue.push(move);
                    }
                    visited[str] = true;
                });
            }
            next = queue.shift();
        }
        var prev = next;
        var steps = [];
        while (prev.name !== start.name) {
            steps.unshift(prev.name);
            prev = prev.parent;

        }
        steps.unshift(prev.name);
        var toReturn = [];
        for (var x = 0; x < steps.length - 1; x++) {
            // Vars cannot have circular references, so delete .parent before returning
            var step = KhanUtil.trigFunc[steps[x]].convertTo(KhanUtil.trigFunc[steps[x + 1]], value);
            delete step.parent;

            toReturn.push(step);
        }
        for (x = 0; x < KhanUtil.trigTypes.length - 1; x++) {
            delete KhanUtil.trigTypes[x].parent;
        }
        return toReturn;
    }
});

// I would love to hear a better way of doing this than this mess
$.extend(KhanUtil, {
    trig: {
        // given the simplification of a trig identity and an operation,
        // finds a pair (function, result) such that that simplification
        // operation'd with function equals result, and result is not a 
        // horrible mess of trig functions with sin^4 everywhere and all that
        getOptionsResult: function(firstPart, operation) {
            var options;
            var func;
            if(firstPart === "\\cos^2\\theta") {
                options = ["1", "\\cot^2\\theta", 
                "\\cos^2\\theta \\cdot \\sin^2\\theta"];
            }
            else if(firstPart === "\\sin^2\\theta") {
                options = ["1", "\\tan^2\\theta", 
                "\\cos^2\\theta \\cdot \\sin^2\\theta"];
            }
            else if(firstPart === "\\tan^2\\theta") {
                options = ["1", "\\sin^2\\theta",
                "\\sec^2\\theta"];
            }
            else if(firstPart === "\\sec^2\\theta") {
                options = ["1", "\\tan^2\\theta", "\\csc^2\\theta"];
            }
            else if(firstPart === "\\cot^2\\theta") {
                options = ["1", "\\cos^2\\theta", "\\csc^2\\theta"];
            }
            else if(firstPart === "\\csc^2\\theta") {
                options = ["1", "\\cot^2\\theta", "\\sec^2\\theta"];
            }

            var result = KhanUtil.randFromArray(options);
            if(operation === "*") {
                if(result === "1") {
                    if(firstPart === "\\cos^2\\theta") {
                        func = "\\sec^2\\theta";
                    }
                    else if(firstPart === "\\sin^2\\theta") {
                        func = "\\csc^2\\theta";
                    }
                    else if(firstPart === "\\tan^2\\theta") {
                        func = "\\cot^2\\theta";
                    }
                    else if(firstPart === "\\sec^2\\theta") {
                        func = "\\cos^2\\theta";
                    }
                    else if(firstPart === "\\cot^2\\theta") {
                        func = "\\tan^2\\theta";
                    }
                    else if(firstPart === "\\csc^2\\theta") {
                        func = "\\sin^2\\theta";
                    }
                }
                else if(result === "\\tan^2\\theta") {
                    if(firstPart === "\\sin^2\\theta") {
                        func = "\\sec^2\\theta";
                    }
                    else if(firstPart === "\\sec^2\\theta") {
                        func = "\\sin^2\\theta";
                    }
                }
                else if(result === "\\cot^2\\theta") {
                    if(firstPart === "\\cos^2\\theta") {
                        func = "\\csc^2\\theta";
                    }
                    else if(firstPart === "\\csc^2\\theta") {
                        func = "\\cos^2\\theta";
                    }
                }
                else if(result === "\\cos^2\\theta \\cdot \\sin^2\\theta") {
                    if(firstPart === "\\cos^2\\theta") {
                        func = "\\sin^2\\theta";
                    }
                    else if(firstPart === "\\sin^2\\theta") {
                        func = "\\cos^2\\theta";
                    }
                }
                else if(result === "\\sin^2\\theta") {
                    if(firstPart === "\\tan^2\\theta") {
                        func = "\\cos^2\\theta";
                    }
                }
                else if(result === "\\cos^2\\theta") {
                    if(firstPart === "\\cot^2\\theta") {
                        func = "\\sin^2\\theta";
                    }
                }
                else if(result === "\\sec^2\\theta") {
                    if(firstPart === "\\tan^2\\theta") {
                        func = "\\csc^2\\theta";
                    }
                    else if(firstPart === "\\csc^2\\theta") {
                        func = "\\tan^2\\theta";
                    }
                }
                else if(result === "\\csc^2\\theta") {
                    if(firstPart === "\\sec^2\\theta") {
                        func = "\\cot^2\\theta";
                    }
                    else if(firstPart === "\\cot^2\\theta") {
                        func = "\\sec^2\\theta";
                    }
                }
            }

            else if(operation === "/") {
                if(result === "1") {
                    func = firstPart;
                }
                else if(result === "\\tan^2\\theta") {
                    if(firstPart === "\\sin^2\\theta") {
                        func = "\\cos^2\\theta";
                    }
                    else if(firstPart === "\\sec^2\\theta") {
                        func = "\\csc^2\\theta";
                    }
                }
                else if(result === "\\cot^2\\theta") {
                    if(firstPart === "\\cos^2\\theta") {
                        func = "\\sin^2\\theta";
                    }
                    else if(firstPart === "\\csc^2\\theta") {
                        func = "\\sec^2\\theta";
                    }
                }
                else if (result === "\\cos^2\\theta \\cdot \\sin^2\\theta") {
                    if(firstPart === "\\cos^2\\theta") {
                        func = "\\csc^2\\theta";
                    }
                    else if(firstPart === "\\sin^2\\theta") {
                        func = "\\sec^2\\theta";
                    }
                }
                else if (result === "\\sin^2\\theta") {
                    if(firstPart === "\\tan^2\\theta") {
                        func = "\\sec^2\\theta";
                    }
                }
                else if(result === "\\cos^2\\theta") {
                    if(firstPart === "\\cot^2\\theta") {
                        func = "\\csc^2\\theta";
                    }
                }
                else if (result === "\\sec^2\\theta") {
                    if(firstPart === "\\tan^2\\theta") {
                        func = "\\sin^2\\theta";
                    }
                    else if(firstPart === "\\csc^2\\theta") {
                        func = "\\cot^2\\theta";
                    }
                }
                else if (result === "\\csc^2\\theta") {
                    if(firstPart === "\\sec^2\\theta") {
                        func = "\\tan^2\\theta";
                    }
                    else if(firstPart === "\\cot^2\\theta") {
                        func = "\\cos^2\\theta";
                    }
                }
            }
            return [options, func, result];
        },

        // expresses the given trig^2 function in terms of sin and cosine
        showSimplified: function(func, small) {
            var d = small ? "\\frac" : "\\dfrac";
            switch(func) {
                case "\\sin^2\\theta" :
                    return func;
                case "\\cos^2\\theta" :
                    return func;
                case "\\csc^2\\theta" :
                    return d + "{1}{\\sin^2\\theta}";
                case "\\sec^2\\theta" :
                    return d + "{1}{\\cos^2\\theta}";
                case "\\tan^2\\theta" :
                    return d + "{\\sin^2\\theta}{\\cos^2\\theta}";
                case "\\cot^2\\theta" :
                    return d + "{\\cos^2\\theta}{\\sin^2\\theta}";
            }
        }
    }
});

});

define('utils/derivative-intuition.js',['require','../third_party/jquery.mobile.vmouse.js'],function(require) {

require("../third_party/jquery.mobile.vmouse.js");

$.extend(KhanUtil, {
    FN_COLOR: "#6495ED",
    DDX_COLOR: "#FFA500",
    TANGENT_COLOR: "#AAA",
    TANGENT_LINE_LENGTH: 200,
    TANGENT_GROWTH_FACTOR: 3,
    TANGENT_SHIFT: 5,

    // Wrap graphInit to create a 600x600px graph properly scaled to the given range
    initAutoscaledGraph: function(range, options) {
        var graph = KhanUtil.currentGraph;
        options = $.extend({
            xpixels: 500,
            ypixels: 500,
            xdivisions: 20,
            ydivisions: 20,
            labels: true,
            unityLabels: true,
            range: (typeof range === "undefined" ? [[-10, 10], [-10, 10]] : range)
        }, options);

        options.scale = [options.xpixels / (options.range[0][1] - options.range[0][0]),
                          options.ypixels / (options.range[1][1] - options.range[1][0])];
        options.gridStep = [(options.range[0][1] - options.range[0][0]) / options.xdivisions,
                             (options.range[1][1] - options.range[1][0]) / options.ydivisions];

        // Attach the resulting metrics to the graph for later reference
        graph.xpixels = options.xpixels;
        graph.ypixels = options.ypixels;
        graph.range = options.range;
        graph.scale = options.scale;

        graph.graphInit(options);
    },


    // start the magic
    initDerivativeIntuition: function(fnx, ddx, points) {
        var graph = KhanUtil.currentGraph;

        KhanUtil.fnx = fnx;
        KhanUtil.ddx = ddx;
        KhanUtil.points = points;
        KhanUtil.highlight = false;
        KhanUtil.dragging = false;
        KhanUtil.ddxShown = false;

        // to store the SVG paths
        graph.tangentLines = [];
        graph.tangentPoints = [];
        graph.slopePoints = [];
        graph.mouseTargets = [];

        // graphie puts text spans on top of the SVG, which looks good, but gets
        // in the way of mouse events. So we add another SVG element on top
        // of everything else where we can add invisible shapes with mouse
        // handlers wherever we want. Is there a better way?
        graph.mouselayer = Raphael("ddxplot", graph.xpixels, graph.ypixels);
        $(graph.mouselayer.canvas).css("z-index", 1);
        Khan.scratchpad.disable();

        // plot all the tangent lines first so they're underneath the tangent/slope points
        $(points).each(function(index, xval) {
            KhanUtil.plotTangentLine(index);
        });

        $(points).each(function(index, xval) {
            // blue points
            KhanUtil.plotTangentPoint(index);
            // orange points and mouse magic
            KhanUtil.plotSlopePoint(index);
        });

        // Once the problem loads, call setSlope() for each point to set the
        // slopes to 0. This replicates the action of the user placing each point
        // at zero and applies the same "close enough" test so very small slopes
        // aren't graded wrong even if they look almost right.
        $(Exercises).one("newProblem", function() {
            $(points).each(function(index, xval) {
                KhanUtil.setSlope(index, 0);
            });
        });
    },


    plotTangentLine: function(index) {
        var graph = KhanUtil.currentGraph;
        var xval = KhanUtil.points[index];
        var yval = KhanUtil.fnx(xval);

        // Now the fun bit: To make it clear that the tangent line only
        // touches at a single point, it's shifted a little bit above or
        // below the curve.

        // The shifted pivot point; defaults to unshifted xval/yval in
        // case we're dealing with an inflection point.
        var xshift = xval;
        var yshift = yval;

        // The slope of a line perpendicular to the tangent line. It is
        // along this direction that we shift the tangent line.
        var perpslope = 0;

        // First and second derivative at the point we're dealing with.
        var ddx1 = KhanUtil.ddx(xval);
        var ddx2 = (KhanUtil.ddx(xval - 0.001) - KhanUtil.ddx(xval + 0.001)) / 0.002;

        if (ddx1 !== 0) {
            // We want to shift *visually* perpendicular to the tangent line,
            // so if the graph has different x and y scales, perpslope isn't
            // quite as simple as (-1/slope)
            perpslope = (-1 / (ddx1 * (graph.scale[1] / graph.scale[0]))) / (graph.scale[1] / graph.scale[0]);

            // Second derivative tells us if the curve is concave up or down, thus which way to
            // shift the tangent line to "get away" from the curve. If perpslope is negative,
            // everything is reversed.
            if ((ddx2 > 0 && perpslope > 0) || (ddx2 < 0 && perpslope < 0)) {
                // atan(perpslope) is the direction to shift; cos() of that gives the x component; the rest of the mess normalizes for different x- and y-scales
                xshift = xval + Math.cos(Math.atan(perpslope * (graph.scale[1] / graph.scale[0]))) * KhanUtil.TANGENT_SHIFT / (2 * graph.scale[0]);
                yshift = perpslope * (xshift - xval) + yval;
            } else if ((ddx2 < 0 && perpslope > 0) || (ddx2 > 0 && perpslope < 0)) {
                xshift = xval - Math.cos(Math.atan(perpslope * (graph.scale[1] / graph.scale[0]))) * KhanUtil.TANGENT_SHIFT / (2 * graph.scale[0]);
                yshift = perpslope * (xshift - xval) + yval;
            }
        } else {
            // Slope is 0, so perpslope is undefined. Just shift up or down based on concavity
            if (ddx2 < 0) {
                yshift = yval - (KhanUtil.TANGENT_SHIFT / (2 * graph.scale[1]));
            } else if (ddx2 > 0) {
                yshift = yval + (KhanUtil.TANGENT_SHIFT / (2 * graph.scale[1]));
            }
        }

        // at last the slightly nudged line is ready to draw
        graph.style({
            stroke: KhanUtil.TANGENT_COLOR,
            strokeWidth: 2
        }, function() {
            graph.tangentLines[index] = graph.line(
                    [xshift - KhanUtil.TANGENT_LINE_LENGTH / (2 * graph.scale[0]), yshift],
                    [xshift + KhanUtil.TANGENT_LINE_LENGTH / (2 * graph.scale[0]), yshift]);
        });
    },


    plotTangentPoint: function(index) {
        var graph = KhanUtil.currentGraph;
        var xval = KhanUtil.points[index];

        graph.style({
            fill: KhanUtil.FN_COLOR,
            stroke: KhanUtil.FN_COLOR
        }, function() {
            graph.tangentPoints[index] = graph.ellipse([xval, KhanUtil.fnx(xval)], [4 / graph.scale[0], 4 / graph.scale[1]]);
        });
    },


    plotSlopePoint: function(index) {
        var graph = KhanUtil.currentGraph;
        var xval = KhanUtil.points[index];

        graph.style({
            fill: KhanUtil.DDX_COLOR,
            stroke: KhanUtil.DDX_COLOR
        }, function() {
            graph.slopePoints[index] = graph.ellipse([xval, 0], [4 / graph.scale[0], 4 / graph.scale[1]]);
        });

        // the invisible shape in front of each point that gets mouse events
        graph.mouseTargets[index] = graph.mouselayer.circle(
                (xval - graph.range[0][0]) * graph.scale[0],
                (graph.range[1][1] - 0) * graph.scale[1], 15);
        graph.mouseTargets[index].attr({fill: "#000", "opacity": 0.0});

        $(graph.mouseTargets[index][0]).css("cursor", "move");
        $(graph.mouseTargets[index][0]).bind("vmousedown vmouseover vmouseout", function(event) {
            event.preventDefault();
            var graph = KhanUtil.currentGraph;
            if (event.type === "vmouseover") {
                KhanUtil.highlight = true;
                if (!KhanUtil.dragging) {
                    graph.slopePoints[index].animate({ scale: 2 }, 50);
                    graph.tangentLines[index].animate({ "stroke": KhanUtil.DDX_COLOR }, 100);
                }

            } else if (event.type === "vmouseout") {
                KhanUtil.highlight = false;
                if (!KhanUtil.dragging) {
                    graph.slopePoints[index].animate({ scale: 1 }, 50);
                    graph.tangentLines[index].animate({ "stroke": KhanUtil.TANGENT_COLOR }, 100);
                }

            } else if (event.type === "vmousedown" && (event.which === 1 || event.which === 0)) {
                event.preventDefault();
                graph.tangentLines[index].toFront();
                graph.tangentPoints[index].toFront();
                graph.slopePoints[index].toFront();
                graph.tangentLines[index].animate({ scale: KhanUtil.TANGENT_GROWTH_FACTOR }, 200);
                KhanUtil.dragging = true;

                $(document).bind("vmousemove vmouseup", function(event) {
                    event.preventDefault();

                    // mouseY is in pixels relative to the SVG; coordY is the scaled y-coordinate value
                    var mouseY = event.pageY - $("#ddxplot").offset().top;
                    mouseY = Math.max(10, Math.min(graph.ypixels - 10, mouseY));
                    var coordY = graph.range[1][1] - mouseY / graph.scale[1];

                    if (event.type === "vmousemove") {
                        $($("div#solutionarea :text")[index]).val(KhanUtil.roundTo(2, coordY));
                        $($("div#solutionarea .answer-label")[index]).text(KhanUtil.roundTo(2, coordY));
                        graph.tangentLines[index].rotate(-Math.atan(coordY * (graph.scale[1] / graph.scale[0])) * (180 / Math.PI), true);
                        graph.slopePoints[index].attr("cy", mouseY);
                        graph.mouseTargets[index].attr("cy", mouseY);

                    } else if (event.type === "vmouseup") {
                        $(document).unbind("vmousemove vmouseup");

                        KhanUtil.setSlope(index, coordY);

                        KhanUtil.dragging = false;

                        graph.tangentLines[index].animate({ scale: 1 }, 200);
                        if (!KhanUtil.highlight) {
                            graph.slopePoints[index].animate({ scale: 1 }, 200);
                            graph.tangentLines[index].animate({ "stroke": KhanUtil.TANGENT_COLOR }, 100);
                        }

                        // If all the points are in the right place, reveal the derivative function
                        var answers = $.map($("div#solutionarea .answer-label"), function(x) {
                            return parseFloat($(x).text());
                        });
                        var correct = $.map(KhanUtil.points, function(x) {
                            return KhanUtil.roundTo(2, KhanUtil.ddx(x));
                        });
                        if (answers.join() === correct.join()) {
                            KhanUtil.revealDerivative(400);
                        }
                    }
                });
            }
        });

    },


    // Set the slope for one point. Snap to the right answer if we're close enough.
    setSlope: function(index, coordY) {
        var graph = KhanUtil.currentGraph;
        var answer = KhanUtil.ddx(KhanUtil.points[index]);
        var degreesOff = Math.abs(Math.atan(answer * graph.scale[1] / graph.scale[0]) -
                Math.atan(coordY * graph.scale[1] / graph.scale[0])) * (180 / Math.PI);

        // How far off you're allowed to be
        if (degreesOff < 7) {
            coordY = answer;
        }

        $($("div#solutionarea :text")[index]).val(KhanUtil.roundTo(2, coordY));
        $($("div#solutionarea .answer-label")[index]).text(KhanUtil.roundTo(2, coordY));
        graph.tangentLines[index].rotate(-Math.atan(coordY * (graph.scale[1] / graph.scale[0])) * (180 / Math.PI), true);
        graph.slopePoints[index].attr("cy", (graph.range[1][1] - coordY) * graph.scale[1]);
        graph.mouseTargets[index].attr("cy", (graph.range[1][1] - coordY) * graph.scale[1]);
    },


    // Shows the derivative plot and equation
    // Called when all the points are in the right place or as a hint
    revealDerivative: function(duration) {
        if (!KhanUtil.ddxShown) {
            var graph = KhanUtil.currentGraph;
            var ddxplot;
            duration = duration || 0;
            graph.style({
                stroke: KhanUtil.DDX_COLOR,
                strokeWidth: 1,
                opacity: duration === 0 ? 1 : 0
            }, function() {
                ddxplot = graph.plot(function(x) {
                    return KhanUtil.ddx(x);
                }, KhanUtil.tmpl.getVAR("XRANGE"));
            });

            $("span#ddxspan").show();  // for IE
            $("span#ddxspan").fadeTo(duration, 1);

            ddxplot.animate({ opacity: 1 }, duration);
            KhanUtil.ddxShown = true;
        }
    }

});

});

define('utils/exponents.js',['require','./math.js','./math-format.js'],function(require) {

require("./math.js");
require("./math-format.js");

$.extend(KhanUtil, {

    /* fraction math-format function called with defraction enabled, which is always
     * what is used in the exponent exercises. */

    frac: function(n, d) {
        return KhanUtil.fraction(n, d, true, true, false, false);
    },

    fracSmall: function(n, d) {
        return KhanUtil.fraction(n, d, true, true, true, false);
    },

    fracParens: function(n, d) {
        return KhanUtil.fraction(n, d, true, true, false, true);
    },

    /* Used to show the contracting of something like (-2)^4 into 16, by showing
     * (-2)^4 = (-2)(-2)(-2)(-2) = 4(-2)(-2) = -8(-2) = 16. Returns an array of
     * each of these steps. */
    expandExponent: function(base, exp) {
        var base_str = KhanUtil.negParens(base),
            expansion = "\\cdot" + base_str, steps = [], multiplier;

        steps.unshift(Math.round(Math.pow(base, exp)));

        for (var i = 1; i < exp; i++) {
            multiplier = Math.round(Math.pow(base, exp - i));

            // we wanth the first hint to say (-2)(-2)(-2)(-2), but the next one to
            // say 4(-2)(-2), -8(-2), etc.
            if (i === exp - 1) {
                multiplier = KhanUtil.negParens(multiplier);
            }

            steps.unshift(multiplier + expansion);

            expansion += "\\cdot " + base_str;
        }

        return steps;
    },

    /* expandExponent for rational bases, taking into account negative
     * exponents. Assumes abs(exp)>=1. */
    expandFractionExponent: function(base_n, base_d, exp) {
        if (Math.abs(exp) < 1) {
            return "";
        }

        exp = Math.abs(exp);
        var flip_n = exp > 0 ? base_n : base_d,
            flip_d = exp > 0 ? base_d : base_n,
            parens = function(n, d) {
                return KhanUtil.fraction(n, d, true, true, false, true);
            }, noParens = function(n, d) {
                return KhanUtil.fraction(n, d, true, true, false, false);
            }, base_str = parens(flip_n, flip_d),
            expansion = "\\cdot" + base_str, steps = [], mult_n, mult_d;

        steps.unshift(noParens(
            Math.round(Math.pow(flip_n, exp)),
            Math.round(Math.pow(flip_d, exp))));

        for (var i = 1; i < exp; i++) {
            mult_n = Math.round(Math.pow(flip_n, exp - i));
            mult_d = Math.round(Math.pow(flip_d, exp - i));

            steps.unshift(
                (i === exp - 1 ? parens : noParens)
                    .call(this, mult_n, mult_d) +
                    expansion);

            expansion += "\\cdot " + base_str;
        }

        return steps;
    },

    /* Given a base, returns the highest positive integer it is reasonable to
     * raise that base to. */
    maxReasonableExp: function(n) {
        // The values are shown in comments to show that they're reasonable.
        return {
            0: 1000,
            1: 1000,
            2: 8,    // 2*2*2*2*2*2*2*2 = 256
            3: 5,    // 3*3*3*3*3 = 243
            4: 4,    // 4*4*4*4 = 256
            5: 4,    // 5*5*5*5 = 625
            6: 3,    // 6*6*6 = 216
            7: 3,    // 7*7*7 = 343
            8: 3,    // 8*8*8 = 512
            9: 3,    // 9*9*9 = 729
            10: 10  // 10^10 = 100000000000
        }[Math.abs(n)];
    },

    /* Picks two bases and one root such that both bases can reasonably be taken
     * to that root. The first base is chosen evenly from all the reasonable
     * bases, and then the root is chosen from all the roots which it is
     * reasonable to take that base to, and then the second base is chosen from
     * all other bases which it is reasonable to take that base to. */
    twoBasesOneRoot: function() {
        var bases_by_root = {
            //   1   2   3    4    5   6   7   8   9   10
            2: [1, 4, 9, 16, 25, 36, 49, 64, 81, 100],
            3: [1, 8, 27, 64, 125],
            4: [1, 16, 81, 256]
        };

        // these are all the bases that can be rooted.
        var bases = bases_by_root[2]
            .concat(bases_by_root[3])
            .concat(bases_by_root[4]);

        var roots_by_base = {};
        for (var i = 0; i < bases.length; i++) {
            var base = bases[i];
            for (var j = 2; j <= 4; j++) {
                if (_(bases_by_root[j]).indexOf(base) !== -1) {
                    if (roots_by_base[base] === undefined) {
                        roots_by_base[base] = [j];
                    } else if (_(roots_by_base[base]).indexOf(j) === -1) {
                        roots_by_base[base].push(j);
                    }
                }
            }
        }

        var base_1 = KhanUtil.randFromArray(bases);

        var root;
        while (root === undefined || root === 1) {
            root = KhanUtil.randFromArray(roots_by_base[base_1]);
        }

        var base_2;
        while (base_2 === undefined || base_2 === base_1) {
            base_2 = KhanUtil.randFromArray(bases_by_root[root]);
        }

        return {
            base_1: base_1,
            base_2: base_2,
            root: root
        };
    }
});

});

define('utils/functional.js',['require'],function(require) {

$.extend(KhanUtil, {
    tabulate: function(fn, n) {
        // Return an array, [fn(), fn(), ...] of length n if fn does not take arguments
        // or the array [fn(0), fn(1), ..., fn(n - 1)] if it does
        return $.map(new Array(n), function(val, i) {
            return [fn(i)];
        });
    }
});

});

define('utils/geom.js',['require'],function(require) {

var eps = 1e-9;
var eq = function(x, y) { return Math.abs(x - y) < eps; };
var signum = function(x) { return eq(x, 0) ? 0 : x / Math.abs(x); };

var sub = function(p1, p2) { return {x: p1.x - p2.x, y: p1.y - p2.y}; };
var len = function(p) { return Math.sqrt(p.x * p.x + p.y * p.y); };
var dist = function(p1, p2) { return len(sub(p1, p2)); };
var dot = function(p1, p2) { return p1.x * p2.x + p1.y * p2.y; };
var cross = function(p1, p2) { return p1.x * p2.y - p1.y * p2.x; };
var ccw = function(p1, p2, p3) { return cross(sub(p2, p1), sub(p3, p1)); };

var Geom = {
    convexhull: function(points) {
        var v0;

        _.each(points, function(p) {
            if (v0 == null || p.x < v0.x - eps ||
                    (eq(p.x, v0.x) && p.y < v0.y)) {
                v0 = p;
            }
        });

        points = points.slice(0);
        points.sort(function(a, b) {
            if (a === v0) {
                return -1;
            } else if (b === v0) {
                return 1;
            }

            var c = ccw(v0, a, b);
            if (eq(c, 0)) {
                var d1 = dist(v0, a);
                var d2 = dist(v0, b);

                if (d1 < d2) {
                    return -1;
                } else if (d1 > d2) {
                    return 1;
                } else {
                    return 0;
                }
            } else {
                return -signum(c);
            }
        });

        var ch = [];
        _.each(points, function(p) {
            while (ch.length >= 2 &&
                    ccw(ch[ch.length - 2], ch[ch.length - 1], p) <= eps) {
                ch.pop();
            }
            ch.push(p);
        });

        return ch;
    },

    /**
     * Return a list of angles between 0 and 2 pi, in radians, through
     * which the passed-in set of points have rotational symmetry (about
     * the origin).
     */
    rotationalSymmetries: function(points) {
        var n = points.length,
            v0 = points[0],
            angles = [],
            tau = 2 * Math.PI;

        out: for (var i = 1; i < n; i++) {
            var v1 = points[i];

            var mag = len(v0) * len(v1);
            var cos = dot(v0, v1) / mag;
            var sin = -cross(v0, v1) / mag;

            for (var j = 0; j < n; j++) {
                var p = points[(i + j) % n];
                var rotP = {
                    x: cos * p.x - sin * p.y,
                    y: sin * p.x + cos * p.y
                };

                if (!eq(dist(rotP, points[j]), 0.0)) {
                    // Points don't line up; no good.
                    continue out;
                }
            }

            var angle = (eps + tau + Math.atan2(sin, cos)) % tau - eps;
            if (!eq(angle, 0.0)) {
                angles.push(angle);
            }
        }

        angles = KhanUtil.sortNumbers(angles);
        angles = _.uniq(angles, /* isSorted: */ true, function() {
            return KhanUtil.roundToNearest(eps);
        });

        return angles;
    }
};

KhanUtil.Geom = Geom;

});

define('utils/graphie-3d.js',['require','./graphie.js','./kmatrix.js','./kvector.js'],function(require) {

require("./graphie.js");
var kmatrix = require("./kmatrix.js");
var kvector = require("./kvector.js");

$.extend(KhanUtil, {
    // make a 3d object, which holds the vertices,
    //   faces, and perspective of an object
    make3dObject: function(verts, options) {
        var object = $.extend({
            verts: verts,
            perspective: kmatrix.makeMatrix([
                [1, 0, 0, 0],
                [0, 1, 0, 0],
                [0, 0, 1, 0],
                [0, 0, 0, 1]
            ]),
            scale: 5.0,
            faces: [],
            sketches: [],
            facesTransparent: true,
            faceBorder: false

        }, options);

        var graph = KhanUtil.currentGraph;

        // set the scale
        object.setScale = function(scale) {
            object.scale = scale;
        };

        // set and offset the camera pos
        object.offsetPos = function(offset) {
            this.perspective[0][3] += offset[0];
            this.perspective[1][3] += offset[1];
            this.perspective[2][3] += offset[2];
        };

        object.setPos = function(pos) {
            this.perspective[0][3] = pos[0];
            this.perspective[1][3] = pos[1];
            this.perspective[2][3] = pos[2];
        };

        // perform a rotation of ang around the vector (x, y, z)
        object.rotate = function(x, y, z, ang) {
            var s = Math.sin(ang);
            var c = Math.cos(ang);

            // stolen from the OpenGL glRotate man page
            var rotation = kmatrix.makeMatrix([
                [x*x*(1-c)+c,   x*y*(1-c)-z*s, x*z*(1-c)+y*s, 0],
                [y*x*(1-c)+z*s, y*y*(1-c)+c,   y*z*(1-c)-x*s, 0],
                [x*z*(1-c)-y*s, y*z*(1-c)+x*s, z*z*(1-c)+c,   0],
                [0,             0,             0,             1]
            ]);

            this.perspective = kmatrix.matrixMult(this.perspective, rotation);
        };

        // perform the perspective transformation stored in
        //   object.perspective on a 3d point
        object.doPerspective = function(pt) {
            var newpt = KhanUtil.arrayToColumn(pt);

            newpt[3] = [-1];

            var result = kmatrix.matrixMult(this.perspective, newpt);

            return KhanUtil.columnToArray(result).slice(0, 3);
        };

        // perform the perspective rotation sorted in object.perspective
        //   on a 3d vector (doesn't perform translation)
        object.doRotation = function(pt) {
            var newpt = KhanUtil.arrayToColumn(pt);

            newpt[3] = [0];

            var result = kmatrix.matrixMult(this.perspective, newpt);

            return KhanUtil.columnToArray(result).slice(0, 3);
        };

        // perform the perspective transformation and then project
        //   the 3d point onto a 2d screen
        object.doProjection = function(pt) {
            var p = this.doPerspective(pt);

            var x1 = p[0] * (this.scale / p[2]);
            var y1 = p[1] * (this.scale / p[2]);

            return [x1, y1];
        };

        // add a face to the object, with verts being indices of the
        //   object.verts array
        object.addFace = function(options) {
            var face = $.extend(true, {
                verts: [],
                color: "black",
                lines: [],
                labels: [],
                infront: false
            }, options);

            // compute the normal of a face
            face.normal = function() {
                var a = object.verts[this.verts[0]];
                var b = object.verts[this.verts[1]];
                var c = object.verts[this.verts[2]];

                var ab = [b[0] - a[0], b[1] - a[1], b[2] - a[2]];
                var ac = [c[0] - a[0], c[1] - a[1], c[2] - a[2]];

                var normal = [
                    ab[1] * ac[2] - ab[2] * ac[1],
                    ab[2] * ac[0] - ab[0] * ac[2],
                    ab[0] * ac[1] - ab[1] * ac[0]
                ];

                var length = kvector.length(normal);

                return _.map(normal, function(e) { return e / length; });
            };

            // find the array of the projected points of the face
            face.mappedVerts = function() {
                return _.map(this.verts, function(v) {
                    return object.doProjection(object.verts[v]);
                });
            };

            // find the zdepth of the face. i.e. how close the face is to the
            // camera
            face.zDepth = function() {
                var a = object.verts[this.verts[0]];
                var b = object.verts[this.verts[1]];
                var c = object.verts[this.verts[2]];

                var x = a[0] + b[0] + c[0];
                var y = a[1] + b[1] + c[1];
                var z = a[2] + b[2] + c[2];
                return object.doPerspective([x, y, z])[2];
            };

            // create a path of the face
            face.path = function() {
                return graph.path(
                    face.mappedVerts(),
                    { fill: face.color, stroke: false }
                );
            };

            face.drawBorder = function() {
                return graph.path(
                    face.mappedVerts().concat(true),
                    { fill: null, stroke: "#666", opacity: 1 }
                );
            };

            // draw the face's lines
            face.drawLines = function() {
                var set = graph.raphael.set();

                _.each(this.lines, function(line) {
                    set.push(
                        graph.line(
                            object.doProjection(line[0]),
                            object.doProjection(line[1]),
                            {
                                stroke: "black",
                                strokeDasharray: ". "
                            }
                        )
                    );
                });

                return set;
            };

            // draw the face's labels
            face.drawLabels = function() {
                _.each(this.labels, function(label) {
                    var normal = face.normal();
                    var newpt = [0.2 * normal[0] + label[0][0],
                                 0.2 * normal[1] + label[0][1],
                                 0.2 * normal[2] + label[0][2]];
                    var pt = object.doProjection(newpt);

                    if (label.label == null) {
                        label.label = graph.label(pt, label[1]);
                    } else {
                        label.label.setPosition(pt);
                    }
                });
            };

            // draw all the objects on the face and return the set of them all
            face.draw = function() {
                var set = graph.raphael.set();

                set.push(face.path());
                set.push(face.drawLines());

                face.drawLabels();

                return set;
            };

            // draw the face in the back, which is just the outline
            face.drawBack = function() {
                if (object.facesTransparent) {
                    return graph.path(face.mappedVerts(),
                        { fill: null, stroke: "#666", opacity: 0.1 });
                }
            };

            face.toFront = function() {
                this.infront = true;
            };

            face.toBack = function() {
                this.infront = false;

                _.each(this.labels, function(label) {
                    if (label.label != null) {
                        label.label.remove();
                        label.label = null;
                    }
                });
            };

            this.faces.push(face);

            return this;
        };

        // add a sketch to the object, which is a path that always gets drawn
        object.addSketch = function(options) {
            var sketch = $.extend(true, {
                verts: [],
                color: "black",
                lines: [],
                labels: [],
                opacityValue: 0.1
            }, options);

            // find the array of the projected points of the sketch
            sketch.mappedVerts = function() {
                return _.map(this.verts, function(v) {
                    return object.doProjection(object.verts[v]);
                });
            };

            // create a path of the sketch
            sketch.path = function() {
                return graph.path(
                    sketch.mappedVerts(),
                    { fill: sketch.color, stroke: true }
                );
            };

            // draw the sketch's lines
            sketch.drawLines = function() {
                return graph.path(
                    sketch.mappedVerts(),
                    { fill: null, stroke: "#666", opacity: sketch.opacityValue }
                );
            };

            // draw all the objects on the face and return the set of them all
            sketch.draw = function() {
               return  graph.raphael.set().push(sketch.drawLines());
            };

            this.sketches.push(sketch);
            return this;
        };

        // draw the object, performing backface culling to ensure
        //   faces don't intersect each other
        object.draw = function() {
            var frontFaces = [];
            var backFaces = [];
            var faces = object.faces.slice();

            // Sort the objects faces by their zDepth, so that faces further
            // away are drawn first. This is the "painters" algorithm, which
            // should be fine for our purposes. If we ever end up in a
            // situation where we need to draw configurations with nontrivial
            // cycles, we will really need more powerful 3d capabilities
            // e.g. webGL
            faces.sort(function(a, b) {
                    return a.zDepth() - b.zDepth();
                });

            // figure out which objects should be drawn in front,
            // and which in back
            _.each(faces, function(face) {
                var vert = object.doPerspective(object.verts[face.verts[0]]);
                var normal = face.normal();
                if (kvector.dot(object.doRotation(normal), vert) < 0) {
                    frontFaces.push(face);
                } else {
                    backFaces.push(face);
                }
            });


            // draw each of the faces, and store it in a raphael set
            var image = graph.raphael.set();
            _.each(frontFaces, function(face) {
                face.toFront();
                image.push(face.draw());
                if (object.faceBorder) {
                    image.push(face.drawBorder());
                }
            });
            _.each(backFaces, function(face) {
                face.toBack();
                image.push(face.drawBack());
            });
            _.each(object.sketches, function(sketch) {
                image.push(sketch.draw());
            });

            return image;
        };

        // a list of the current and next frame
        // each time a new one is created, the old one is
        // removed later to avoid fast flickering
        object.images = [graph.raphael.set()];

        // whether or not an image is pending for deletion,
        // in which case we shouldn't draw again
        object.drawPending = false;

        // do the full double-buffered drawing
        object.doDraw = function() {
            // only draw if we don't have a second frame waiting
            if (!this.drawPending) {
                this.drawPending = true;

                // do the drawing, and store the new frame
                this.images.push(this.draw());

                // defer removing the old frame
                _.defer(function() {
                    object.images.shift().remove();
                    object.drawPending = false;
                });
            }
        };

        return object;
    }
});

});

define('utils/graphie-geometry.js',['require','./graphie.js','./kline.js','./kmatrix.js'],function(require) {

require("./graphie.js");
var kline = require("./kline.js");
var kmatrix = require("./kmatrix.js");

// TODO(eater): shove these into KhanUtil or somewhere reasonable

window.rotatePoint = function(p, deg, c) {
    c = c || [0, 0];
    var rad = KhanUtil.toRadians(deg),
        cos = Math.cos(rad),
        sin = Math.sin(rad),
        cx = c[0],
        cy = c[1],
        px = p[0],
        py = p[1],
        x = cx + (px - cx) * cos - (py - cy) * sin,
        y = cy + (px - cx) * sin + (py - cy) * cos;
    return [KhanUtil.roundTo(9, x), KhanUtil.roundTo(9, y)];
};

$.extend(KhanUtil, {
    rightAngleBox: function(path1, path2, style) {
        var graph = KhanUtil.currentGraph;

        var size = 0.5;

        var intersection = findIntersection(path1, path2),
        path = [intersection],
        curr = graph.cartToPolar(intersection)[1],
        offset;

        for (var i = 1; i < 4; i++) {
            offset = graph.polar(size, curr);

            path.push([path[i - 1][0] - offset[0],
                       path[i - 1][1] - offset[1]]);

            curr -= 90;
        }

        path.push(intersection);

        return graph.path(path, style);
    },

    parallel: function(path, num, style) {
        var graph = KhanUtil.currentGraph;

        var point = kline.midpoint(path);

        graph.path([path[0], point], $.extend(style, { arrows: "->" }));
    },

    congruent: function(path, num, style) {
        var graph = KhanUtil.currentGraph;

        var spacing = 5, scale = 5;

        for (var i = 0; i < num; i++) {
            var sPath = _.map(path, graph.scalePoint),
            sPoint = kline.midpoint(sPath),
            angle = Math.atan((sPath[0][1] - sPath[1][1]) / (sPath[0][0] - sPath[1][0])),
            perpangle = angle + Math.PI / 2;

            var sMarkPath = [[sPoint[0] + Math.cos(angle)*spacing*i + Math.cos(perpangle)*scale,
                              sPoint[1] + Math.sin(angle)*spacing*i + Math.sin(perpangle)*scale],
                             [sPoint[0] + Math.cos(angle)*spacing*i - Math.cos(perpangle)*scale,
                              sPoint[1] + Math.sin(angle)*spacing*i - Math.sin(perpangle)*scale]];

            graph.path(_.map(sMarkPath, graph.unscalePoint), style);
        }
    }
});

window.lineLength = function(line) {
    var a = line[0];
    var b = line[1];
    return Math.sqrt((a[0] - b[0]) * (a[0] - b[0]) + (a[1] - b[1]) * (a[1] - b[1]));
};

//Takes an array and an array of positions, all elements whose index is not in the positions array gets replaced by ""
//Very useful for labels, for example, clearArray(["x", "x", "x"], [ANGLE]), where ANGLE is 1, will give you ["", "x", ""], which you can use to label angles in a Triangle such that the second angle is labeled x

window.clearArray = function(arr, i) {
    return $.map(arr, function(el, index) {
        if ($.inArray(index, i) !== -1) {
            return el;
        }
        else {
            return "";
       }
    });
};

//Used together with clearArray, for example mergeArray(clearArray(["x", "x", "x"], [ANGLE]), ["a","b","c"]), where ANGLE is 1, gives labels for a triangle ["a", "x", "c"]
//need to be same length
window.mergeArray = function(ar1, ar2) {
    var i = 0;
    for (i = 0; i < ar1.length; i++) {
        if (ar1[i] === "") {
            ar1[i] = ar2[i];
        }
    }
    return ar1;
};

window.isPointOnLineSegment = function(l, p, precision) {
    precision = precision || 0.1;
    //If line is vertical
    if (Math.abs(l[1][0] - l[0][0]) < precision) {
        return (Math.abs(p[0] - l[0][0]) < precision) && (p[1] <= (Math.max(l[1][1], l[0][1]) + precision)) && (p[1] >= (Math.min(l[1][1], l[0][1]) - precision));
    }
    var m = (l[1][1] - l[0][1]) / (l[1][0] - l[0][0]);
    var k = l[0][1] - m * l[0][0];
    return (Math.abs(m * p[0] + k - p[1]) < precision);
};

//Are two polygons intersecting
window.areIntersecting = function(pol1, pol2) {
    var i, k = 0;
    for (i = 0; i < pol1.length; i++) {
        for (k = 0; k < pol2.length; k++) {
            if (findIntersection(pol1[i], pol2[k])[2]) {
                return true;
            }
        }
    }
    return false;
};


//Returns an intersection of two lines, and whether that point is inside both line segments
window.findIntersection = function(a, b) {
    var tY = [0, a[0][1], a[1][1], b[0][1], b[1][1]];
    var tX = [0, a[0][0], a[1][0], b[0][0], b[1][0]];

    var denominator = (tY[4] - tY[3]) * (tX[2] - tX[1]) - (tX[4] - tX[3]) * (tY[2] - tY[1]);
    var ua = ((tX[4] - tX[3]) * (tY[1] - tY[3]) - (tY[4] - tY[3]) * (tX[1] - tX[3])) / denominator;
    var ub = ((tX[2] - tX[1]) * (tY[1] - tY[3]) - (tY[2] - tY[1]) * (tX[1] - tX[3])) / denominator;
    var isContained = (ua >= -0.01) && (ua <= 1.01) && (ub >= -0.01) && (ub <= 1.01);
    return [tX[1] + ua * (tX[2] - tX[1]), tY[1] + ua * (tY[2] - tY[1]), isContained];
};

window.degToRad = function(deg) {
    return deg * Math.PI / 180;
};

//Returns [ m, k ] of y = mx + k
//Vulnerable to division by 0
window.lineEquation = function(line) {

    var m = (line[1][1] - line[0][1]) / (line[1][0] - line[0][0]);
    var k = line[0][1] - m * line[0][0];

    return [m, k];

};

//Given a line, returns a segment of that line of length amount starting at start
window.lineSegmentFromLine = function(start, line, amount) {

    var eq = lineEquation(line);
    var m = eq[0];
    var angle = Math.atan(m);
    return [start, [start[0] + Math.cos(angle) * amount, start[1] + Math.sin(angle) * amount]];

};

//Gives a line parralel to line going through point
window.parallelLine = function(line, point) {

    var dif = [point[0] - line[0][0], point[1] - line[0][1]];
    return [point, [line[1][0] + dif[0], line[1][1] + dif[1]]];

};

window.movePoint = function(p, a) {

    return [p[0] + a[0], p[1] + a[1]];
};


//Returns a line that bisects an angle defined by line1 and line2
window.bisectAngle = function(line1, line2, scale) {
    var intPoint = findIntersection(line1, line2);
    var l1 = [];
    var l2 = [];

    if ((line1[1][0] - line1[0][0]) >= 0) {
        l1 = lineSegmentFromLine(intPoint, line1, scale);
    }
    else {
        l1 = lineSegmentFromLine(intPoint, line1, -scale);
    }
    if ((line2[1][0] - line2[0][0]) >= 0) {
        l2 = lineSegmentFromLine(intPoint, line2, scale);
    }
    else {
        l2 = lineSegmentFromLine(intPoint, line2, -scale);
    }
    return [intPoint, parallelLine(l1, l2[1])[1]];

};

window.vectorProduct = function(line1, line2) {
    var x1 = line1[1][0] - line1[0][0];
    var x2 = line2[1][0] - line2[0][0];
    var y1 = line1[1][1] - line1[0][1];
    var y2 = line2[1][1] - line2[0][1];
    return x1 * y2 - x2 * y1;
};

//For [a, b] returns [b , a]
window.reverseLine = function(line) {
    return [line[1], line[0]];
};

window.Triangle = function(center, angles, scale, labels, points) {

    var fromPoints = false;
    if (points) {
        fromPoints = true;
    }

    this.labels = labels;
    if (fromPoints) {
        this.points = points;
        this.sides = [[this.points[0], this.points[1]], [this.points[1], this.points[2]] , [this.points[2], this.points[0]]];
        this.sideLengths = $.map(this.sides, lineLength);
        this.angles = anglesFromSides(this.sideLengths);
    }
    else {
        this.angles = angles;
    }

    this.radAngles = $.map(angles, degToRad);
    this.scale = (scale || 3);

    this.cosines = $.map(this.radAngles, Math.cos);
    this.sines = $.map(this.radAngles, Math.sin);


    this.x = center[0];
    this.y = center[1];
    this.rotation = 0;

    //Given the scale(which represensts the area of the triangle) and angles we want to find the side lengths.
    //http://en.wikipedia.org/wiki/Triangle#Using_trigonometry. Using the ASA equation in the link, we find the length of one side.
    var a = Math.sqrt((2 * this.scale * this.sines[1]) / (this.sines[0] * this.sines[2]));
    var b = a * this.sines[2] / this.sines[1];
    if (! fromPoints) {
        this.points = [[this.x, this.y], [b + this.x, this.y], [this.cosines[0] * a + this.x, this.sines[0] * a + this.y]];
    }
    this.sides = [[this.points[0], this.points[1]], [this.points[1], this.points[2]] , [this.points[2], this.points[0]]];

    this.sideLengths = $.map(this.sides, lineLength);

    this.niceSideLengths = $.map(this.sideLengths, function(x) { return parseFloat(x.toFixed(1)); });

    this.set = "";
    this.niceAngles = $.map(this.angles, function(x) { return x + "^{\\circ}"; });
    this.labelObjects = { "sides": [] , "angles" : [], "points" : [], "name" : [] };


    this.angleScale = function(ang) {
        if (ang > 150) {
            return 0.8;
        }
        else if (ang > 140) {
            return 0.7;
        }
        else if (ang > 130) {
            return 0.6;
        }
        else if (ang > 90) {
            return 0.5;
        }
        else if (ang > 40) {
            return 0.6;
        }
        else if (ang > 25) {
            return 0.7;
        }
        return 0.8;
    };

    this.draw = function() {
        this.set = KhanUtil.currentGraph.raphael.set();
        this.set.push(KhanUtil.currentGraph.path(this.points.concat([this.points[0]])));
        return this.set;
    };

    this.color = "black";
    this.createLabel = function(p, v) {
        this.set.push(KhanUtil.currentGraph.label(p, v, "center", { color: this.color }));
    };

    this.boxOut = function(pol, amount) {
        var shouldMove = areIntersecting(pol, this.sides);
        while (areIntersecting(pol, this.sides)) {
            this.translate(amount);
        }
        if (shouldMove) {
            this.translate(amount);
        }
    };

    this.boundingRange = function(margin) {
        margin = margin || 0;
        var X = $.map(this.points, function(p) { return p[0]; });
        var Y = $.map(this.points, function(p) { return p[1]; });
        return [[_.min(X) - margin, _.max(X) + margin],
             [_.min(Y) - margin, _.max(Y) + margin]];
    };

    this.findCenterPoints = function() {
        var Ax = this.points[0][0];
        var Ay = this.points[0][1];
        var Bx = this.points[1][0];
        var By = this.points[1][1];
        var Cx = this.points[2][0];
        var Cy = this.points[2][1];
        var D = 2 * (Ax * (By - Cy) + Bx * (Cy - Ay) + Cx * (Ay - By));
        var a = this.sideLengths[1];
        var b = this.sideLengths[2];
        var c = this.sideLengths[0];
        var P = a + b + c;
        var x1 = (a * Ax + b * Bx + c * Cx) / P;
        var y1 = (a * Ay + b * By + c * Cy) / P;
        var x = ((Ay * Ay + Ax * Ax) * (By - Cy) + (By * By + Bx * Bx) * (Cy - Ay) + (Cy * Cy + Cx * Cx) * (Ay - By)) / D;
        var y = ((Ay * Ay + Ax * Ax) * (Cx - Bx) + (By * By + Bx * Bx) * (Ax - Cx) + (Cy * Cy + Cx * Cx) * (Bx - Ax)) / D;
        this.circumCenter = [x, y];
        this.centroid = [1 / 3 * (Ax + Bx + Cx), 1 / 3 * (Ay + By + Cy)];
        this.inCenter = [x1, y1];
    };

    this.findCenterPoints();

    this.findRadii = function() {
        this.semiperimeter = (this.sideLengths[0] + this.sideLengths[1] + this.sideLengths[2]) / 2;
        this.inradius = this.scale / this.semiperimeter;
        this.circumradius = this.sideLengths[0] * this.sideLengths[1] * this.sideLengths[2] / (4 * this.semiperimeter * this.inradius);
    };

    this.rotationCenter = this.centroid;

    this.rotate = function(amount) {
        amount = amount * Math.PI / 180;
        var tr = this;
        this.points = $.map(this.points, function(el, i) {
                return [tr.rotatePoint(el, amount)];
        });
        this.genSides();
        this.findCenterPoints();
    };

    this.genSides = function() {
        this.sides = [];
        var x = 0;
        for (x = 0; x < this.points.length; x++) {
            this.sides.push([this.points[x], this.points[(x + 1) % this.points.length]]);
        }
    };

    this.translate = function(amount) {
        this.points = $.map(this.points, function(el, i) {
            return [movePoint(el, amount)];
        });
        this.genSides();
        this.findCenterPoints();
    };

    this.rotatePoint = function(pos, theta) {
        theta = theta || this.rotation;
        return [this.rotationCenter[0] + (pos[0] - this.rotationCenter[0]) * Math.cos(theta) + (pos[1] - this.rotationCenter[1]) * Math.sin(theta), this.rotationCenter[1] + (-1) * ((pos[0] - this.rotationCenter[0]) * Math.sin(theta)) + ((pos[1] - this.rotationCenter[1]) * Math.cos(theta))];
    };

    this.drawLabels = function() {
        var i = 0;
        if ("points" in this.labels) {
            //Need to change the position of placement into label objects
            for (i = this.angles.length - 1; i >= 0; i--) {
                this.labelObjects.points.push(this.createLabel(bisectAngle(reverseLine(this.sides[(i + 1) % this.angles.length]), this.sides[i], 0.3)[1], this.labels.points[(i + 1) % this.angles.length]));
            }
        }

        if ("angles" in this.labels) {
            for (i = this.angles.length - 1; i >= 0; i--) {
                this.labelObjects.angles.push(this.createLabel(bisectAngle(this.sides[(i + 1) % this.angles.length], reverseLine(this.sides[i]), this.angleScale(this.angles[(i + 1) % this.angles.length]))[1], this.labels.angles[(i + 1) % this.angles.length]));
            }
        }

        if ("sides" in this.labels) {
            for (i = 0; i < this.sides.length; i++) {
                //http://www.mathworks.com/matlabcentral/newsreader/view_thread/142201
                var midPoint = kline.midpoint(this.sides[i]);
                var t = lineLength([this.sides[i][1], midPoint]);
                var d = 0.5;
                var x3 = midPoint[0] + (this.sides[i][1][1] - midPoint[1]) / t * d;
                var y3 = midPoint[1] - (this.sides[i][1][0] - midPoint[0]) / t * d;
                this.labelObjects.sides.push(this.createLabel([x3, y3], this.labels.sides[i]));
            }
        }

        if ("name" in this.labels) {
            this.labelObjects["name"] = this.createLabel(bisectAngle(reverseLine(this.sides[2]), this.sides[1], 0.3)[1], this.labels.name);
        }


//DEPRECATED
        if ("c" in this.labels) {
            this.createLabel([(this.points[0][0] + this.points[1][0]) / 2, (this.points[0][1] + this.points[1][1]) / 2 - 0.4] , labels.c);
        }
        if ("a" in this.labels) {
            this.createLabel([(this.points[1][0] + this.points[2][0]) / 2 + 0.4, (this.points[1][1] + this.points[2][1]) / 2] , labels.a);
        }
        if ("b" in this.labels) {
            this.createLabel([(this.points[0][0] + this.points[2][0]) / 2 - 0.4, (this.points[0][1] + this.points[2][1]) / 2] , labels.b);
        }


        return this.set;
    };

};
window.Quadrilateral = function(center, angles, sideRatio, labels, size) {

    this.sideRatio = sideRatio;
    this.angles = angles;
    this.radAngles = $.map(angles, degToRad);
    this.scale = 1;
    this.rotation = 0;
    this.x = center[0];
    this.y = center[1];
    this.rotationCenter = [center[0], center[1]];
    this.set = "";
    this.size = size || 10;
    this.cosines = $.map(this.radAngles, Math.cos);
    this.sines = $.map(this.radAngles, Math.sin);
    this.labels = labels || {};
    this.sides = [];

    this.generatePoints = function() {
        var once = false;
        while ((! once) || this.isCrossed() || this.sideTooShort()) {
            var len = Math.sqrt(2 * this.scale * this.scale * this.sideRatio * this.sideRatio - 2 * this.sideRatio * this.scale * this.scale * this.sideRatio * this.cosines[3]);
            once = true;
            var tX = [0, this.scale * this.sideRatio * this.cosines[0] , len * Math.cos((this.angles[0] - (180 - this.angles[3]) / 2) * Math.PI / 180), this.scale, this.scale + Math.cos((180 - this.angles[1]) * Math.PI / 180)];
            var tY = [0, this.scale * this.sideRatio * this.sines[0] , len * Math.sin((this.angles[0] - (180 - this.angles[3]) / 2) * Math.PI / 180), 0, Math.sin((180 - this.angles[1]) * Math.PI / 180)];

            var denominator = (tY[4] - tY[3]) * (tX[2] - tX[1]) - (tX[4] - tX[3]) * (tY[2] - tY[1]);

            var ua = ((tX[4] - tX[3]) * (tY[1] - tY[3]) - (tY[4] - tY[3]) * (tX[1] - tX[3])) / denominator;

            this.points = [[this.x, this.y], [this.x + this.scale * this.sideRatio * this.cosines[0], this.y + this.scale * this.sideRatio * this.sines[0]], [this.x + tX[1] + ua * (tX[2] - tX[1]), this.y + tY[1] + ua * (tY[2] - tY[1])], [this.x + this.scale, this.y]];

            this.sides = [[this.points[0], this.points[3]], [this.points[3], this.points[2]], [this.points[2], this.points[1]], [this.points[1], this.points[0]]];
            this.sideLengths = $.map(this.sides, lineLength);
            this.niceSideLengths = $.map(this.sideLengths, function(x) { return parseFloat(x.toFixed(1)); });

            if (vectorProduct([this.points[0], this.points[1]], [this.points[0], this.points[2]]) > 0) {
                this.sideRatio -= 0.3;
            }

            if (vectorProduct([this.points[0], this.points[3]], [this.points[0], this.points[2]]) < 0) {
                this.sideRatio += 0.3;
            }

            var tooShort = this.sideTooShort();
            if (tooShort) {
                if (tooShort.whichSide % 2 === 0) {
                    this.sideRatio -= 0.05;
                }
                else {
                    this.sideRatio += 0.05;
                }
            }
        }
    };

    this.sideTooShort = function() {
        if (this.sideRatio === 1) {
            return false;
        }
        var shortestSide = _.min(this.sideLengths);
        var allSides = _.reduce(this.sideLengths, function(acc,n) { return acc+n; }, 0);
        return shortestSide/allSides < 0.12 && {whichSide:_.indexOf(this.sideLengths,shortestSide)};
    };

    this.isCrossed = function() {
        return (vectorProduct([this.points[0], this.points[1]], [this.points[0], this.points[2]]) > 0) || (vectorProduct([this.points[0], this.points[3]], [this.points[0], this.points[2]]) < 0);
    };

    this.genSides = function() {
        this.sides = [[this.points[0], this.points[3]], [this.points[3], this.points[2]], [this.points[2], this.points[1]], [this.points[1], this.points[0]]];
    };

    this.generatePoints();

    var area = 0.5 * vectorProduct([this.points[0], this.points[2]], [this.points[3], this.points[1]]);
    this.scale = this.scale * Math.sqrt(this.size / area);
    this.generatePoints();

    area = 0.5 * vectorProduct([this.points[0], this.points[2]], [this.points[3], this.points[1]]);

};


Quadrilateral.prototype = new Triangle([0, 0], [30, 30, 30], 3, "");

//From http://en.wikipedia.org/wiki/Law_of_cosines
window.anglesFromSides = function(sides) {
        var c = sides[0];
        var a = sides[1];
        var b = sides[2];
        var gamma = Math.round(Math.acos((a * a + b * b - c * c) / (2 * a * b)) * 180 / Math.PI);
        var beta = Math.round(Math.acos((a * a + c * c - b * b) / (2 * a * c)) * 180 / Math.PI);
        var alpha = Math.round(Math.acos((b * b + c * c - a * a) / (2 * b * c)) * 180 / Math.PI);
        return [alpha, beta, gamma];
};



window.randomTriangleAngles = {

        triangle: function() {
            var a, b, c;
            a = KhanUtil.randRange(35, 150);
            b = KhanUtil.randRange(35, 180 - a);
            if (a + b > 160) {
                a = Math.max(30, a - 15);
                b = Math.max(30, b - 15);
            }
            c = 180 - a - b;
            return [a, b, c];
        },

        scalene: function() {
            var a, b, c;
            do {
                a = KhanUtil.randRange(25, 150);
                b = KhanUtil.randRange(25, 180 - a);
                if (a + b > 170) {
                    a = Math.max(30, a - 15);
                    b = Math.max(30, b - 15);
                }
                c = 180 - a - b;
            } while (a === b || a === c || b === c);
            return [a, b, c];
        },

        isosceles: function() {
            var a = KhanUtil.randRangeExclude(25, 75, [60]);
            var c = 180 - 2 * a;
            return KhanUtil.shuffle([a, a, c]);
        },
        equilateral: function() {
            return [60, 60, 60];
        }
};


window.randomQuadAngles = {

        square: function() {
            return [90, 90, 90, 90];
        },

        rectangle: function() {
            return [90, 90, 90, 90];
        },

        rhombus: function() {
            var angA, angB;
            do {
                angA = KhanUtil.randRange(30, 150);
                angB = 180 - angA;
            }while (Math.abs(angA - angB) < 5);
            return [angA, angB, angA, angB];
        },

        parallelogram: function() {
            var angA, angB;
            do {
                angA = KhanUtil.randRange(30, 150);
                angB = 180 - angA;
            } while (angA === angB);
            return [angA, angB, angA, angB];
        },

        trapezoid: function() {
            var angA, angB, angC, angD;
            do {
                angA = KhanUtil.randRange(30, 150);
                angB = 180 - angA;
                angC = KhanUtil.randRange(30, 150);
                angD = 180 - angC;
            } while (Math.abs(angA - angC) < 6 || angA + angC === 180);
            return [angA, angC, angD, angB];
        },

        isoscelesTrapezoid: function() {
            var angC, angD;
            do {
                angC = KhanUtil.randRange(30, 150);
                angD = 180 - angC;
            } while (angC === angD);
            return [angC, angC, angD, angD];
        },

        kite: function() {
            var angA, angB, angC;
            do {
                angA = KhanUtil.randRange(90, 140);
                angB = KhanUtil.randRange(30, (360 - (2 * angA)) - 30);
                angC = 360 - angB - 2 * angA;
            } while (angA === angB);
            return [angB, angA, angC, angA];
        }
};


$.extend(KhanUtil, {

    // Creates a representation of a weird blocky shape that you can find
    // the perimeter or area of
    createOddShape: function(options) {
        var shape = $.extend({
            width: 10,
            height: 10,
            squares: [],
            sides: []
        }, options);

        // Start at the top of the shape and pick a random left and right
        // edge for the top row.
        var y = shape.height - 1;
        var left = KhanUtil.randRange(0, shape.width - 1);
        var right = KhanUtil.randRange(left + 1, shape.width);

        // Add the top side
        shape.sides.push({
            start: [left, y],
            end: [right, y],
            length: right - left,
            labelPos: "above"
        });
        // The y-positions where the next vertical line on the left and
        // right sides of the figure starts.
        var leftStart = y;
        var rightStart = y;

        // Add each square in the top row
        _(right - left).times(function(dx) {
            shape.squares.push([left + dx, y]);
        });

        // Iterate through each subsequent row
        while (y > 2) {
            y -= 1;
            // Pick a new left and right edge for each row, with a 70%
            // probability of continuing on the same row as the row above
            var prevLeft = left;
            var prevRight = right;
            left = KhanUtil.randRangeWeighted(0, prevRight - 1, prevLeft, 0.7);
            right = KhanUtil.randRangeWeighted(Math.max(left, prevLeft) + 1,
                shape.width, prevRight, 0.7);

            // Add each square in this row
            _(right - left).times(function(dx) {
                shape.squares.push([left + dx, y]);
            });

            // If the left side isn't the same as the row above,
            // add a new vertical and horizontal side
            if (left !== prevLeft) {
                shape.sides.push({
                    start: [prevLeft, leftStart],
                    end: [prevLeft, y],
                    length: leftStart - y,
                    labelPos: "left"
                });
                shape.sides.push({
                    start: [prevLeft, y],
                    end: [left, y],
                    length: Math.abs(left - prevLeft),
                    labelPos: "center"
                });
                // record where the next vertical side on the left starts
                leftStart = y;
            }

            // If the right side isn't the same as the row above,
            // add a new vertical and horizontal side
            if (right !== prevRight) {
                shape.sides.push({
                    start: [prevRight, rightStart],
                    end: [prevRight, y],
                    length: rightStart - y,
                    labelPos: "right"
                });
                shape.sides.push({
                    start: [prevRight, y],
                    end: [right, y],
                    length: Math.abs(right - prevRight),
                    labelPos: "center"
                });
                // record where the next vertical side on the right starts
                rightStart = y;
            }
        }

        // Add the last left and right vertical sides
        shape.sides.push({
            start: [left, leftStart],
            end: [left, 1],
            length: leftStart - 1,
            labelPos: "left"
        });
        shape.sides.push({
            start: [right, rightStart],
            end: [right, 1],
            length: rightStart - 1,
            labelPos: "right"
        });

        // Add the bottom side
        shape.sides.push({
            start: [left, 1],
            end: [right, 1],
            length: right - left,
            labelPos: "below"
        });

        shape.perimeter = _.reduce(shape.sides, function(perimeter, side) {
                return perimeter + side.length;
            }, 0);

        shape.area = shape.squares.length;

        shape.numSides = shape.sides.length;

        shape.labelSquares = function() {
            _.each(shape.squares, function(square, n) {
                KhanUtil.currentGraph.label([square[0] + 0.5, square[1] - 0.5],
                    n + 1, "center", false);
            });
        };

        shape.labelSides = function() {
            _.each(shape.sides, function(side) {
                KhanUtil.currentGraph.label([(side.start[0] + side.end[0]) / 2,
                    (side.start[1] + side.end[1]) / 2], side.length,
                    side.labelPos);
            });
        };

        return shape;
    }
});


// The following triangley code creates hopefully more legible triangles
// TODO(eater): Collapse this stuff into the existing triangle code above
//              without breaking a bunch of stuff (and refactor things so
//              Quadrilateral no longer inherits from Triangle)
//
//            angles[0]
//               /\
//              /  \
//    sides[1] /    \ sides[2]
//            /      \
//           /________\
// angles[2]  sides[0]  angles[1]
//

// The following solves the triangle by filling in any side and angle measures
// that were not included.
//
// The sides and angles included must unambiguously specify one triangle. duh.
// If not, behavior is undefined.
//
KhanUtil.solveTriangle = function(triangle) {
    var sides = triangle.sides;
    var angles = triangle.angles;
    var numSides = _.reduce(sides, function(n, side) {
        return n + (typeof side === "number" ? 1 : 0);
    }, 0);
    var numAngles = _.reduce(angles, function(n, angle) {
        return n + (typeof angle === "number" ? 1 : 0);
    }, 0);

    // If we have 2 sides, we must have the angle opposite the unknown side.
    // (SAS is the only valid postulate in this case)
    // We can use the law of cosines to find the third side
    if (numSides === 2) {
        var missingSide = sides.indexOf(null);
        var side1 = sides[(missingSide + 1) % 3];
        var side2 = sides[(missingSide + 2) % 3];
        sides[missingSide] = Math.sqrt(side1 * side1 + side2 * side2 - 2 *
            side1 * side2 * Math.cos(angles[missingSide] * Math.PI / 180));
        numSides = 3;
    }

    // If we have all three sides, we can use the law of cosines to find all
    // the angles
    if (numSides === 3) {
        // Use law of cosines to find all the angles
        angles = _.map(angles, function(angle, n) {
            var oppSide = sides[n];
            var adjSide1 = sides[(n + 1) % 3];
            var adjSide2 = sides[(n + 2) % 3];
            return Math.acos((adjSide1 * adjSide1 + adjSide2 * adjSide2 -
                oppSide * oppSide) / (2 * adjSide1 * adjSide2));
        });
        angles = _.map(angles, KhanUtil.toDegrees);
    }

    // If we have 2 angles, we can easily fill in the third angle
    if (numAngles === 2) {
        var missingAngle = angles.indexOf(null);
        angles[missingAngle] = 180 - angles[(missingAngle + 1) % 3] -
            angles[(missingAngle + 2) % 3];
        numAngles = 3;
    }

    // 3 angles and 1 side is enough to figure out the rest of the sides using
    // the law of sines
    if (numAngles === 3 && numSides >= 1) {
        var knownSide = sides.indexOf(sides[0] || sides[1] || sides[2]);
        sides[(knownSide + 1) % 3] = (sides[knownSide] *
            Math.sin(angles[(knownSide + 1) % 3] * Math.PI / 180)) /
            Math.sin(angles[knownSide] * Math.PI / 180);
        sides[(knownSide + 2) % 3] = (sides[knownSide] *
            Math.sin(angles[(knownSide + 2) % 3] * Math.PI / 180)) /
            Math.sin(angles[knownSide] * Math.PI / 180);
    }

    triangle.sides = sides;
    triangle.angles = angles;

    triangle.isRight = function() {
        return (this.angles[0] === 90 || this.angles[1] === 90 ||
            this.angles[2] === 90);
    };

    triangle.isScalene = function() {
        return (this.angles[0] !== this.angles[1] &&
            this.angles[1] !== this.angles[2] &&
            this.angles[0] !== this.angles[2]);
    };

    triangle.isNotDegenerate = function() {
        return (this.sides[1] + this.sides[2] > this.sides[0] &&
            this.sides[0] + this.sides[2] > this.sides[1] &&
            this.sides[0] + this.sides[1] > this.sides[2]);
    };

    return triangle;
};


KhanUtil.Graphie.prototype.addTriangle = function(triangle) {
    var graphie = this;
    triangle = $.extend({
        sides: [],
        angles: [],
        points: [],
        sideLabels: [],
        angleLabels: [],
        vertexLabels: [],
        labels: [],
        rot: 0,
        xPos: 0,
        yPos: 0,
        width: 10,
        height: 10,
        color: KhanUtil.BLUE
    }, triangle);

    var rotatePoint = function(point, angle) {
        var matrix = kmatrix.makeMatrix([
            [Math.cos(angle), -Math.sin(angle), 0],
            [Math.sin(angle), Math.cos(angle), 0],
            [0, 0, 1]
        ]);
        var vector = kmatrix.makeMatrix([[point[0]], [point[1]], [1]]);
        var prod = kmatrix.matrixMult(matrix, vector);
        return [prod[0][0], prod[1][0]];
    };

    var findCenterPoints = function(triangle, points) {
        var Ax = points[0][0];
        var Ay = points[0][1];
        var Bx = points[1][0];
        var By = points[1][1];
        var Cx = points[2][0];
        var Cy = points[2][1];
        var D = 2 * (Ax * (By - Cy) + Bx * (Cy - Ay) + Cx * (Ay - By));
        var a = triangle.sides[0];
        var b = triangle.sides[1];
        var c = triangle.sides[2];
        var P = a + b + c;
        var x1 = (a * Ax + b * Bx + c * Cx) / P;
        var y1 = (a * Ay + b * By + c * Cy) / P;
        var x = ((Ay * Ay + Ax * Ax) * (By - Cy) + (By * By + Bx * Bx) *
            (Cy - Ay) + (Cy * Cy + Cx * Cx) * (Ay - By)) / D;
        var y = ((Ay * Ay + Ax * Ax) * (Cx - Bx) + (By * By + Bx * Bx) *
            (Ax - Cx) + (Cy * Cy + Cx * Cx) * (Bx - Ax)) / D;
        return {
            circumCenter: [x, y],
            centroid: [1 / 3 * (Ax + Bx + Cx), 1 / 3 * (Ay + By + Cy)],
            inCenter: [x1, y1]
        };
    };

    triangle.draw = function() {
        if (triangle.set != null) {
            triangle.set.remove();
        }
        _.each(triangle.labels, function(lbl) {
            lbl.remove();
        });
        triangle.set = graphie.raphael.set();
        triangle.set.push(graphie.path(triangle.points.concat([true]),{
            stroke: triangle.color
        }));

        var centerPoints = findCenterPoints(triangle, triangle.points);
        _(3).times(function(i) {
            if (triangle.angleLabels[i] != null) {
                var ang = Math.atan2(centerPoints.inCenter[1] -
                    triangle.points[i][1], centerPoints.inCenter[0] -
                    triangle.points[i][0]);

                // The angle measure label needs to be further from the vertex
                // for small angles and closer for large angles. This is an
                // empirically determined formula for figuring out how far.
                var labelDist = (3.51470560176242 - 0.5687298702748785) *
                    Math.exp(-0.037587715462826674 * triangle.angles[i]) +
                    0.5687298702748785;

                triangle.labels.push(graphie.label([
                    triangle.points[i][0] + Math.cos(ang) * labelDist,
                    triangle.points[i][1] + Math.sin(ang) * labelDist],
                    triangle.angleLabels[i], "center"));
            }
        });

        _(3).times(function(i) {
            if (triangle.sideLabels[i] != null) {
                var x = (triangle.points[(i + 1) % 3][0] +
                    triangle.points[(i + 2) % 3][0]) / 2;
                var y = (triangle.points[(i + 1) % 3][1] +
                    triangle.points[(i + 2) % 3][1]) / 2;
                var ang;
                if (triangle.angles[i] < 90) {
                    ang = Math.atan2(y - centerPoints.circumCenter[1],
                        x - centerPoints.circumCenter[0]);
                } else if (triangle.angles[i] > 90) {
                    ang = Math.atan2(centerPoints.circumCenter[1] - y,
                        centerPoints.circumCenter[0] - x);
                } else {
                    ang = Math.atan2(y - centerPoints.centroid[1],
                        x - centerPoints.centroid[0]);
                }

                triangle.labels.push(graphie.label([x, y],
                    triangle.sideLabels[i], ang));
            }
        });

        _(3).times(function(i) {
            if (triangle.vertexLabels[i] != null) {
                var ang = Math.atan2(triangle.points[i][1] -
                    centerPoints.inCenter[1], triangle.points[i][0] -
                    centerPoints.inCenter[0]);
                var labelDist = 0.4;

                var lbl = graphie.label([
                    triangle.points[i][0] + Math.cos(ang) * labelDist,
                    triangle.points[i][1] + Math.sin(ang) * labelDist],
                    triangle.vertexLabels[i], "center");
                lbl.css("color", triangle.color);
                triangle.labels.push(lbl);
            }
        });
    };

    // Return the points coorresponding to an alitude to angle[n]
    triangle.findAltitude = function(n) {
        var p1 = triangle.points[n];
        var p2 = triangle.points[(n + 1) % 3];
        var p3 = triangle.points[(n + 2) % 3];

        // Project p1 onto line between p2 and p3
        // Could use kvector's projection method
        var v1 = [p1[0] - p2[0], p1[1] - p2[1]];
        var v2 = [p3[0] - p2[0], p3[1] - p2[1]];
        var dot1 = v1[0] * v2[0] + v1[1] * v2[1];
        var dot2 = v2[0] * v2[0] + v2[1] * v2[1];
        var s = dot1 / dot2;
        return [p1, [p2[0] + v2[0] * s, p2[1] + v2[1] * s]];
    };

    triangle.points[2] = [0, 0];
    triangle.points[1] = [triangle.sides[0], 0];
    triangle.points[0] = [Math.cos(triangle.angles[2] * Math.PI / 180) *
        triangle.sides[1], Math.sin(triangle.angles[2] * Math.PI / 180) *
        triangle.sides[1]];

    // Rotate the triangle
    triangle.points[0] = rotatePoint(triangle.points[0], triangle.rot *
        Math.PI / 180);
    triangle.points[1] = rotatePoint(triangle.points[1], triangle.rot *
        Math.PI / 180);
    triangle.points[2] = rotatePoint(triangle.points[2], triangle.rot *
        Math.PI / 180);

    // Scale and translate the triangle such that it fits within the
    // specified width/height constraint and is positioned at xPos, yPos
    var minX = _.min(_.map(triangle.points, function(p) { return p[0]; }));
    var maxX = _.max(_.map(triangle.points, function(p) { return p[0]; }));
    var minY = _.min(_.map(triangle.points, function(p) { return p[1]; }));
    var maxY = _.max(_.map(triangle.points, function(p) { return p[1]; }));
    var xScale = triangle.width / (maxX - minX);
    var yScale = triangle.height / (maxY - minY);
    var scale = _.min([xScale, yScale]);
    triangle.width = (maxX - minX) * scale;
    triangle.height = (maxY - minY) * scale;

    triangle.points = _.map(triangle.points, function(p) {
        return [(p[0] - minX) * scale + triangle.xPos,
            (p[1] - minY) * scale + triangle.yPos];
    });

    return triangle;
};

});

define('utils/graphie-helpers-arithmetic.js',['require'],function(require) {

var decimalPointSymbol = icu.getDecimalFormatSymbols().decimal_separator;

function Adder(a, b, digitsA, digitsB) {
    var graph = KhanUtil.currentGraph;
    digitsA = digitsA || KhanUtil.digits(a);
    digitsB = digitsB || KhanUtil.digits(b);
    var highlights = [];
    var carry = 0;
    var pos = { max: Math.max(digitsA.length, digitsB.length, KhanUtil.digits(a + b).length),
        carry: 3,
        first: 2,
        second: 1,
        sum: 0,
        sideX: Math.max(digitsA.length, digitsB.length) + 2,
        sideY: 1.5 };

    var index = 0;
    var numHints = Adder.numHintsFor(a, b);

    this.show = function() {
        graph.init({
            range: [[-1, 11], [pos.sum - 0.5, pos.carry + 0.5]],
            scale: [20, 40]
        });

        drawDigits(digitsA.slice(0).reverse(), pos.max - digitsA.length + 1, pos.first);
        drawDigits(digitsB.slice(0).reverse(), pos.max - digitsB.length + 1, pos.second);

        graph.path([[-0.5, pos.second - 0.5], [pos.max + 0.5, pos.second - 0.5]]);
        graph.label([0, 1] , "\\LARGE{+\\vphantom{0}}");
    };

    this.showHint = function() {
        this.removeHighlights();
        if ((index === numHints - 2) && (numHints - 1 > digitsA.length)) {
            this.showFinalCarry();
            index++;
            return;
        } else if (index === numHints - 1) {
            return;
        }
        var prevCarry = carry;
        var prevCarryStr = "";
        var carryStr = "";
        var addendStr = "";
        var sum;

        var x = pos.max - index;
        var power = Math.pow(10, index);
        var zeros = new Array(index + 1).join("0");

        if (prevCarry !== 0) {
            highlights.push(graph.label([x, pos.carry], "\\blue{" + prevCarry + "}", "below"));
            prevCarryStr = "\\blue{" + (prevCarry * power) + "} + ";
        }

        sum = digitsA[index] + carry;
        highlights = highlights.concat(drawDigits([digitsA[index]], x, pos.first, KhanUtil.BLUE));

        if (index < digitsB.length) {
            highlights = highlights.concat(drawDigits([digitsB[index]], x, pos.second, KhanUtil.BLUE));
            addendStr = " + \\blue{" + (digitsB[index] * power) + "}";
            sum += digitsB[index];
        }

        drawDigits([sum % 10], x, pos.sum);
        highlights = highlights.concat(drawDigits([sum % 10], x, pos.sum, KhanUtil.GREEN));

        carry = Math.floor(sum / 10);
        if (carry !== 0) {
            highlights.push(graph.label([x - 1, pos.carry], "\\orange{" + carry + "}", "below"));
            carryStr = "\\orange{" + carry + "}";
        }

        this.showSideLabel("\\Large{" +
            prevCarryStr +
            "\\blue{" + (digitsA[index] * power) + "}" +
            addendStr +
            " = " +
            carryStr +
            "\\green{" + sum % 10 + "}" +
            zeros +
            "}");

        index++;
    };

    this.showFinalCarry = function() {
        highlights.push(graph.label([pos.max - index, pos.carry],
            "\\blue{" + carry + "}", "below"));
        graph.label([pos.max - index, pos.sum], "\\LARGE{" + carry + "}");
        highlights.push(graph.label([pos.max - index, pos.sum],
            "\\LARGE{\\color{#28AE7B}{" + carry + "}}"));

        this.showSideLabel("\\Large{" +
            "\\blue{" + carry + "}" +
            " = " +
            "\\color{#28AE7B}{" + carry + "}" +
            "}");
    };

    this.getNumHints = function() {
        return numHints;
    };

    this.removeHighlights = function() {
        while (highlights.length) {
            highlights.pop().remove();
        }
    };

    this.showSideLabel = function(str) {
        highlights.push(graph.label([pos.sideX, pos.sideY], str, "right"));
    };

    this.showDecimals = function(deciA, deciB) {
        for (var i = 0; i < 3; i++) {
            graph.style({ fill: "#000" }, function() {
                graph.label([pos.max - Math.max(deciA, deciB) + 0.5, i - 0.1],
                    "\\LARGE{" + decimalPointSymbol + "}", "center", true);
            });
        }
        this.showSideLabel("\\text{Make sure the decimals are lined up.}");
    };
}

Adder.numHintsFor = function(a, b) {
    return KhanUtil.digits(a + b).length + 1;
};

function Subtractor(a, b, digitsA, digitsB, decimalPlaces) {
    var graph = KhanUtil.currentGraph;
    digitsA = digitsA || KhanUtil.digits(a);
    digitsB = digitsB || KhanUtil.digits(b);
    var workingDigitsA = digitsA.slice(0);
    var workingDigitsB = digitsB.slice(0);
    var highlights = [];
    var pos = { max: digitsA.length,
        carry: 3,
        first: 2,
        second: 1,
        diff: 0,
        sideX: Math.max(digitsA.length, digitsB.length) + 2,
        sideY: 1.5 };

    var index = 0;
    var numHints = Subtractor.numHintsFor(a, b);
    decimalPlaces = decimalPlaces || 0;

    this.show = function() {
        graph.init({
            range: [[-1, 11], [pos.diff - 0.5, pos.carry + 0.5]],
            scale: [20, 40]
        });
        drawDigits(digitsA.slice(0).reverse(), pos.max - digitsA.length + 1, pos.first);
        drawDigits(digitsB.slice(0).reverse(), pos.max - digitsB.length + 1, pos.second);

        graph.path([[-0.5, pos.second - 0.5], [pos.max + 0.5, pos.second - 0.5]]);
        graph.label([0, 1] , "\\LARGE{-\\vphantom{0}}");

        for (var i = 0; i < digitsA.length; i++) {
            highlights.unshift([]);
        }
    };

    this.borrow = function(idx) {
        var borrowedIdx = idx + 1;
        if (workingDigitsA[idx + 1] < 1) {
            borrowedIdx = this.borrow(idx + 1);
        }
        workingDigitsA[idx + 1] -= 1;
        workingDigitsA[idx] += 10;

        var depth = borrowedIdx - idx - 1;

        highlights[idx].push(graph.label([pos.max - idx, pos.carry + (0.5 * depth)],
                                             "\\blue{" + workingDigitsA[idx] + "}", "below"));
        highlights[idx].push(graph.path([[pos.max - 0.3 - idx, pos.first - 0.4], [pos.max + 0.3 - idx, pos.first + 0.4]]));

        highlights[idx + 1].push(graph.label([pos.max - 1 - idx, pos.carry + (0.5 * depth)],
                                                 "\\orange{" + workingDigitsA[idx + 1] + "}", "below"));
        highlights[idx + 1].push(graph.path([[pos.max - 1.3 - idx, pos.first - 0.4], [pos.max - 0.7 - idx, pos.first + 0.4]]));
        if (depth !== 0) {
            highlights[idx + 1].push(graph.path([[pos.max - 1.3 - idx, pos.carry - 1 + (0.5 * depth)], [pos.max - 0.7 - idx, pos.carry - 0.7 + (0.5 * depth)]]));
        }
        return borrowedIdx;
    };

    this.showHint = function() {
        this.removeHighlights(index);

        if (index !== 0) {
            this.removeHighlights(index - 1);
        }
        if (index === numHints - 1) {
            return;
        }

        var value = workingDigitsA[index];
        var withinB = index < workingDigitsB.length;
        var subtrahend = withinB ? workingDigitsB[index] : 0;
        var subStr = "";
        var power = Math.pow(10, index);

        if (value < subtrahend) {
            this.borrow(index);
        } else if (workingDigitsA[index] === digitsA[index]) {
            highlights[index].push(graph.label([pos.max - index, pos.first],
                "\\LARGE{\\blue{" + workingDigitsA[index] + "}}"));
        } else {
            highlights[index].push(graph.label([pos.max - index, pos.carry],
                "\\blue{" + workingDigitsA[index] + "}", "below"));
        }

        if (withinB) {
            highlights[index].push(graph.label([pos.max - index, pos.second],
                "\\LARGE{\\blue{" + workingDigitsB[index] + "}}"));
            subStr = " - \\blue{" + (subtrahend * power) + "}";
        }

        var diff = workingDigitsA[index] - subtrahend;
        if (((a - b) / Math.pow(10, index)) > 1 || index < decimalPlaces) {
            graph.label([pos.max - index, pos.diff], "\\LARGE{" + diff + "}");
        }
        var zeros = diff ? new Array(index + 1).join("0") :  "";

        highlights[index].push(graph.label([pos.max - index, pos.diff], "\\LARGE{\\green{" + diff + "}}"));
        if (subStr === "") {
            subStr = "- \\blue{ 0 }";
        }

        this.showSideLabel("\\Large{" +
            "\\blue{" + (workingDigitsA[index] * power) + "}" +
            subStr +
            " = " +
            "\\green{" + diff + "}" + 
            zeros +
            "}");

        index++;
    };

    this.getNumHints = function() {
        return numHints;
    };

    this.removeHighlights = function(i) {
        if (i >= highlights.length) {
            return;
        }

        var col = highlights[i];
        while (col.length) {
            col.pop().remove();
        }
    };

    this.showSideLabel = function(str) {
        highlights[index].push(graph.label([pos.sideX, pos.sideY], str, "right"));
    };

    this.showDecimals = function(deciA, deciB) {
        for (var i = 0; i < 3; i++) {
            graph.style({ fill: "#000" }, function() {
                graph.label([pos.max - Math.max(deciA, deciB) + 0.5, i - 0.1],
                    "\\LARGE{" + decimalPointSymbol + "}", "center", true);
            });
        }
        this.showSideLabel("\\text{Make sure the decimals are lined up.}");
    };
}

Subtractor.numHintsFor = function(a, b) {
    return KhanUtil.digits(a).length + 1;
};

// convert Adder -> DecimalAdder and Subtractor -> DecimalSubtractor
(function() {
    var decimate = function(drawer) {
        var news = function(a, aDecimal, b, bDecimal) {
            var newA = a * (bDecimal > aDecimal ? Math.pow(10, bDecimal - aDecimal) : 1);
            var newB = b * (aDecimal > bDecimal ? Math.pow(10, aDecimal - bDecimal) : 1);
            return [newA, newB];
        };

        var decimated = function(a, aDecimal, b, bDecimal) {
            var newAB = news(a, aDecimal, b, bDecimal);
            var newA = newAB[0], newB = newAB[1];

            var aDigits = KhanUtil.digits(newA);
            for (var i = 0; i < (aDecimal - bDecimal) || aDigits.length < aDecimal + 1; i++) {
                aDigits.push(0);
            }

            var bDigits = KhanUtil.digits(newB);
            for (var i = 0; i < (bDecimal - aDecimal) || bDigits.length < bDecimal + 1; i++) {
                bDigits.push(0);
            }
            var drawn = new drawer(newA, newB, aDigits, bDigits, Math.max(aDecimal, bDecimal));

            drawn.showDecimals = (function(old) {
                return function() {
                    old.call(drawn, aDecimal, bDecimal);
                };
            })(drawn.showDecimals);

            return drawn;
        };

        decimated.numHintsFor = function(a, aDecimal, b, bDecimal) {
            var newAB = news(a, aDecimal, b, bDecimal);
            var newA = newAB[0], newB = newAB[1];

            return drawer.numHintsFor(newA, newB);
        };

        return decimated;
    };

    // I hate global variables
    KhanUtil.DecimalAdder = decimate(Adder);
    KhanUtil.DecimalSubtractor = decimate(Subtractor);
})();

function drawCircles(num, color) {
    var graph = KhanUtil.currentGraph;
    var numCols = Math.floor(Math.sqrt(num));
    var numRows = Math.floor(num / numCols);
    var extra = num % numRows;

    graph.init({
        range: [[0, numCols + 1], [-1, numRows + 2]],
        scale: [30, 30]
    });

    graph.style({
        stroke: color,
        fill: color
    });

    for (var i = numRows; i > 0; i--) {
        for (var j = numCols; j > 0; j--) {
            graph.circle([j, i], 0.25);
        }
    }

    for (var j = extra; j > 0; j--) {
        graph.circle([j, 0], 0.25);
    }
}

function crossOutCircles(numCircles, numCrossed, color) {
    var graph = KhanUtil.currentGraph;
    var numCols = Math.floor(Math.sqrt(numCircles));
    var numRows = Math.floor(numCircles / numCols);
    var extra = numCircles % numRows;
    var count = 0;

    graph.style({
        stroke: color,
        fill: color
    });

    for (var i = numRows; i > 0; i--) {
        for (var j = numCols; j > 0; j--) {
            graph.path([[j - 0.3, i - 0.3], [j + 0.3, i + 0.3]]);
            graph.path([[j - 0.3, i + 0.3], [j + 0.3, i - 0.3]]);
            count += 1;
            if (count === numCrossed) {
                return;
            }
        }
    }

    for (var j = extra; j > 0; j--) {
        graph.path([[j - 0.3, i - 0.3], [j + 0.3, i + 0.3]]);
        graph.path([[j - 0.3, i + 0.3], [j + 0.3, i - 0.3]]);
        count += 1;
        if (count === numCrossed) {
            return;
        }
    }
}

function drawDigits(digits, startX, startY, color) {
    var graph = KhanUtil.currentGraph;
    var set = [];
    $.each(digits, function(index, digit) {
        var str = "\\LARGE{" + digit + "}";
        set.push(graph.label([startX + index, startY], str, { color: color }));
    });
    return set;
}

// for multiplication 0.5, 1
function drawRow(num, y, color, startCount) {
    var graph = KhanUtil.currentGraph;

    graph.style({
        stroke: color
    });

    var set = graph.raphael.set();
    for (var x = 0; x < num; x++) {
        set.push(graph.label([x, y], "\\small{\\color{" + color + "}{" + (startCount + x) + "}}"));
        set.push(graph.circle([x, y], 0.25));
    }

    return set;
}

function Multiplier(a, b, digitsA, digitsB, deciA, deciB) {
    var graph = KhanUtil.currentGraph;
    deciA = deciA || 0;
    deciB = deciB || 0;
    digitsA = digitsA || KhanUtil.digits(a);
    digitsB = digitsB || KhanUtil.digits(b);
    var digitsProduct = KhanUtil.integerToDigits(a * b);
    var highlights = [];
    var carry = 0;
    var indexA = 0;
    var indexB = 0;
    var maxNumDigits = Math.max(deciA + deciB, digitsProduct.length);

    var leadingZero = 0;
    for (var i=digitsB.length-1; i>0; i--) {
        if (digitsB[i] === 0) {
            leadingZero++;
        } else {
            break;
        }
    }

    var numHints = digitsA.length * (digitsB.length - leadingZero) + 1;

    this.show = function() {
        graph.init({
            range: [[-2 - maxNumDigits, 12], [-Math.max(numHints, 6), 3]],
            scale: [20, 40]
        });

        drawDigits(digitsA.slice(0).reverse(), 1 - digitsA.length, 2);
        drawDigits(digitsB.slice(0).reverse(), 1 - digitsB.length, 1);

        graph.path([[-1 - digitsProduct.length, 0.5], [1, 0.5]]);
        graph.label([- (Math.max(digitsA.length, digitsB.length)), 1] , "\\LARGE{\\times\\vphantom{0}}");
    };

    this.removeHighlights = function() {
        while (highlights.length) {
            highlights.pop().remove();
        }
    };

    this.showHint = function() {
        this.removeHighlights();

        if (indexB === digitsB.length - leadingZero) {
            this.showFinalAddition();
            return;
        }

        var bigDigit = digitsA[indexA];
        var smallDigit = digitsB[indexB];

        var product = smallDigit * bigDigit + carry;
        var ones = product % 10;
        var currCarry = Math.floor(product / 10);

        highlights = highlights.concat(drawDigits([bigDigit], -indexA, 2, KhanUtil.BLUE));
        highlights = highlights.concat(drawDigits([smallDigit], -indexB, 1, KhanUtil.PINK));
        if (carry) {
            highlights = highlights.concat(graph.label([-indexA, 3], "\\orange{" + carry + "}", "below"));
        }
        graph.label([2, -indexB * digitsA.length - indexA + 2],
            "\\blue{" + bigDigit + "}" +
            "\\times" +
            "\\color{#FF00AF}{" + smallDigit + "}" +
            (carry ? "+\\orange{" + carry + "}" : "") +
            "=" +
            "\\color{#28AE7B}{" + product + "}", "right");

        drawDigits([ones], -indexB - indexA, -indexB);
        highlights = highlights.concat(drawDigits([ones], -indexB - indexA, -indexB, KhanUtil.GREEN));

        if (currCarry) {
            highlights = highlights.concat(graph.label([-1 - indexA, 3], "\\color{#28AE7B}{" + currCarry + "}", "below"));
            if (indexA === digitsA.length - 1) {
                drawDigits([currCarry], -indexB - indexA - 1, -indexB);
                highlights = highlights.concat(drawDigits([currCarry], -indexB - indexA - 1, -indexB, KhanUtil.GREEN));
            }
        }
        carry = currCarry;

        if (indexA === digitsA.length - 1) {
            indexB++;
            indexA = 0;
            carry = 0;
        } else {
            indexA++;
        }
    };

    this.showFinalAddition = function() {
        if (digitsB.length - leadingZero > 1) {
            while (digitsProduct.length < deciA + deciB + 1) {
                digitsProduct.unshift(0);
            }
            var y = leadingZero - digitsB.length;

            graph.path([[-1 - digitsProduct.length, y + 0.5], [1, y + 0.5]]);
            graph.label([-1 - digitsProduct.length, y + 1] , "\\LARGE{+\\vphantom{0}}");
            drawDigits(digitsProduct, 1 - digitsProduct.length, y);
        }
    };

    this.getNumHints = function() {
        return numHints;
    };

    this.showDecimals = function() {
        graph.style({
            fill: "#000"
        }, function() {
            if (deciA > 0) {
                graph.label([-deciA + 0.5, 1.9],
                    "\\LARGE{" + decimalPointSymbol + "}", "center", true);
            }
            if (deciB > 0) {
                graph.label([-deciB + 0.5, 0.9],
                    "\\LARGE{" + decimalPointSymbol + "}", "center", true);
            }
        });
    };

    this.showDecimalsInProduct = function() {
        var x = -maxNumDigits;
        var y = -Math.max((digitsB.length - leadingZero) * digitsA.length, 3 + digitsB.length - leadingZero);

        graph.label([x, y + 2],
            $.ngettext("\\text{The top number has 1 digit to the right of the decimal.}", "\\text{The top number has %(num)s digits to the right of the decimal.}", deciA), "right");
        graph.label([x, y + 1],
            $.ngettext("\\text{The bottom number has 1 digit to the right of the decimal.}", "\\text{The bottom number has %(num)s digits to the right of the decimal.}", deciB), "right");
        // TODO(jeresig): i18n: Should this be pluralized?
        graph.label([x, y],
                    $._("\\text{The product has %(numA)s + %(numB)s = %(numSum)s digits to the right of the decimal.}",
                        {numA: deciA, numB: deciB, numSum: deciA + deciB}),
                    "right");
        graph.style({
            fill: "#000"
        }, function() {
            var y = -digitsB.length + leadingZero;
            if (y === -1) {
                // y gets mistakenly calculated -1 only in the case where there's
                // no addition step. In that case, the decimal really goes at y = 0
                y = 0;
            }
            graph.label([-deciB - deciA + 0.5, y - 0.1],
                "\\LARGE{" + decimalPointSymbol + "}", "center", true);
        });
    };
}

function Divider(divisor, dividend, deciDivisor, deciDividend, decimalRemainder) {
    var graph = KhanUtil.currentGraph;
    var digitsDivisor = KhanUtil.integerToDigits(divisor);
    var digitsDividend = KhanUtil.integerToDigits(dividend);
    deciDivisor = deciDivisor || 0;
    deciDividend = deciDividend || 0;

    deciDividend = Divider.processDividend(digitsDividend, deciDividend);
    var deciDiff = deciDivisor - deciDividend;
    var hints = Divider.getHints(divisor, digitsDividend, deciDivisor, deciDividend, decimalRemainder);
    var numHints = hints.length;

    var highlights = [];
    var leadingZeros = [];
    var decimals = [];
    var temporaryLabel = false;
    var index = 0;
    var dx = 0;
    var dy = 0;
    var currentValue = 0;
    var fOnlyZeros = true;

    this.show = function() {
        // Count number of subdivisions shown and find how many decimals have been added
        var steps = 0;
        var decimalsAdded = 0;
        for (var i = 0; i < hints.length; i++) {
            if (hints[i][0] === 'result' && hints[i][1] !== 0) {
                steps++;
            } else if (hints[i][0] === 'decimal-remainder') {
                decimalsAdded = hints[i][1];
            }
        }

        // Calculate the x-coordinate for the hints
        dx = digitsDividend.length + decimalsAdded + Math.max(0, deciDiff) + 0.5;

        var paddedDivisor = digitsDivisor;
        if (deciDivisor !== 0) {
            paddedDivisor = (KhanUtil.padDigitsToNum(digitsDivisor.reverse(), deciDivisor + 1)).reverse();
        }

        graph.init({
            range: [[-1 - paddedDivisor.length, 17], [-2 * steps - 1, 2]],
            scale: [20, 40]
        });

        graph.style({
            fill: "#000"
        }, function() {
            if (deciDivisor !== 0) {
                decimals = decimals.concat(
                    graph.label([-1 - deciDivisor, -0.1],
                        "\\LARGE{" + decimalPointSymbol + "}", "center", true));
            }
            if (deciDividend !== 0) {
                decimals = decimals.concat(
                    graph.label(
                        [digitsDividend.length - deciDividend - 0.5, -0.1],
                        "\\LARGE{" + decimalPointSymbol + "}", "center", true));
            }
        });

        drawDigits(paddedDivisor, -0.5 - paddedDivisor.length, 0);
        drawDigits(digitsDividend, 0, 0);
        graph.path([[-0.75, -0.5], [-0.75, 0.5], [dx - 0.8, 0.5]]);
    };

    this.showHint = function() {
        this.clearArray(highlights);
        var hint = hints.shift();

        // For the last hint, remove leading zero in the answer
        if (hints.length === 0) {
            this.clearArray(leadingZeros);
        }

        switch (hint[0]) {
            case 'shift':
                this.shiftDecimals();
                break;
            case 'bring-up-decimal':
                this.bringUpDecimal();
                break;
            case 'division':
                currentValue = hint[1];
                this.showDivisionStep();
                break;
            case 'result':
                this.showDivisionStepResult(hint[1], hint[2], hint[3]);
                break;
            case 'decimal-remainder':
                this.addDecimalRemainder();
                break;
            case 'remainder':
                this.showRemainder(hint[1]);
                break;
        }
    };

    this.shiftDecimals = function() {
        this.clearArray(decimals);

        temporaryLabel = graph.label([dx, 1],
            $.ngettext("\\text{Shift the decimal 1 to the right.}",
                       "\\text{Shift the decimal %(num)s to the right.}",
                       deciDivisor),
            "right");

        this.addDecimals([[-1, -0.1], [digitsDividend.length + deciDiff - 0.5, -0.1]]);

        // Draw extra zeros in the dividend
        if (deciDiff > 0) {
            var orig = digitsDividend;
            digitsDividend = KhanUtil.padDigitsToNum(digitsDividend, digitsDividend.length + deciDiff);
            var x = digitsDividend.length - deciDiff;
            var zeros = digitsDividend.slice(x);
            drawDigits(zeros, x, 0);
            highlights = highlights.concat(drawDigits(zeros, x, 0, KhanUtil.PINK));
        }
    };

    this.bringUpDecimal = function() {
        if (temporaryLabel) {
            temporaryLabel.remove();
            temporaryLabel = false;
        }

        // TODO(jeresig): i18n: This probably won't work in multiple langs
        graph.label([dx, 1.2], $._("\\text{Bring the decimal up into the}"), "right");
        graph.label([dx, 0.8], $._("\\text{answer (the quotient).}"), "right");
        this.addDecimals([[digitsDividend.length + deciDiff - 0.5, 0.9]]);
    };

    this.showDivisionStep = function(division) {
        // Write question
        var question = $._("\\text{How many times does }%(divisor)s" +
                           "\\text{ go into }\\color{#6495ED}{%(value)s}\\text{?}",
                            {divisor: divisor, value: currentValue});

        if (currentValue >= divisor) {
            graph.label([dx, dy], question, "right");
        } else {
            highlights = highlights.concat(graph.label([dx, dy], question, "right"));
        }

        // Bring down another number
        if (!fOnlyZeros) {
            graph.style({
                arrows: "->"
            }, function() {
                highlights.push(graph.path([[index, -0.5], [index, dy + 0.5]]));
            });

            if (digitsDividend[index]) {
                drawDigits([digitsDividend[index]], index, dy);
            } else {
                // Add a zero in the dividend and bring that down
                drawDigits([0], index, 0);
                drawDigits([0], index, dy);
            }
        }

        // Highlight current dividend
        var digits = KhanUtil.integerToDigits(currentValue);
        highlights = highlights.concat(drawDigits(digits, index - digits.length + 1, dy, KhanUtil.BLUE));
    };

    this.showDivisionStepResult = function(result, remainder) {
        if (result !== 0) {
            fOnlyZeros = false;
        }

        // Leading zeros except one before a decimal point and those after
        // are stored separately so they can be removed later.
        if (fOnlyZeros && index < digitsDividend.length + deciDiff - 1) {
            leadingZeros = leadingZeros.concat(drawDigits([0], index, 1));
        } else { 
            drawDigits([result], index, 1);
        }

        // Highlight result
        highlights = highlights.concat(drawDigits([result], index, 1, KhanUtil.GREEN));

        if (result !== 0) {
            dy -= 2;
            var productDigits = KhanUtil.integerToDigits(result * divisor);
            var productLength = productDigits.length;
            drawDigits(productDigits, index - productLength + 1, dy + 1);

            graph.path([[index - productLength - 0.25, dy + 0.5], [index + 0.5, dy + 0.5]]);
            graph.label([index - productLength, dy + 1] , "-");

            var remainderDigits = KhanUtil.integerToDigits(remainder);
            var remainderX = index - remainderDigits.length + 1;
            drawDigits(remainderDigits, remainderX, dy);
            highlights = highlights.concat(drawDigits(remainderDigits, remainderX, dy, KhanUtil.PINK));

            graph.label([dx, dy + 1],
                "\\blue{" + currentValue + "}" +
                "\\div" + divisor + "=" +
                "\\green{" + result + "}" +
                "\\text{" + $._(" with a remainder of ") + " }" +
                "\\pink{" + remainder + "}",
                "right");
        }

        index++;
    };

    this.addDecimalRemainder = function() {
        digitsDividend = KhanUtil.integerToDigits(dividend * 10);
        deciDividend = 1;
        deciDiff = deciDivisor - deciDividend;

        drawDigits([0], index, 0);
        this.addDecimals([[index - 0.5, 0.9], [index - 0.5, -0.1]]);

        graph.label([dx, 1], $._("\\text{Write in a decimal and a zero.}"), "right");
    };

    this.showRemainder = function(remainder) {
        var txt;
        if (remainder === 0) {
            txt = "\\text{" + $._("The remainder is 0 so we have our answer.") + "}";
        } else {
            txt = $._("\\text{Since } %(remainder)s \\text{ is less than } %(divisor)s \\text{, it is left as our remainder.}",
                    { remainder: remainder, divisor: divisor });

            drawDigits(["\\text{R}"].concat(KhanUtil.integerToDigits(remainder)), digitsDividend.length, 1);
        }

        graph.label([dx, dy], txt, "right");
    };

    this.getNumHints = function() {
        return numHints;
    };

    this.clearArray = function(arr) {
        while (arr.length) {
            arr.pop().remove();
        }
    };

    this.addDecimals = function(coords) {
        graph.style({
                fill: "#000"
            }, function() {
                for (var i = 0; i < coords.length; i++) {
                    graph.label(coords[i], "\\LARGE{" + decimalPointSymbol + "}", "center", true);
                }
            });
    };

}

// Go through the division step-by-step
// Return steps as an array of arrays,
// where the first item is the type of hint and following items are parameters.
// The hint types are:
// ['shift']                        The divisor is a decimal, so shift the decimal to make it an integer.
// ['bring-up-decimal']             The dividend is a decimal, so bring up decimal point into the quotient.
// ['decimal-remainder', param1]    decimalRemainder is true and we need to add decimals to the dividend to continue.
//                                  Param1 is the number of zeros added (to a maximum of 4).
//                                  e.g. for 1 / 8, we add a decimal and 3 zeros so 1 becomes 1.000.
// ['division', param1]             Show a sub-division step, dividing param1 by the divisor.
//                                  e.g. For 58 / 2, the first step is to divide 5 (param1) by 2.
// ['result', param1, param2]       Show the result of a sub-division step. The result is param1 remainder param2.
//                                  e.g. For 5 / 2, param1 is 2 and param2 is 1.
// ['remainder', param1]            Show the remainder of param1 (Usually 0 showing we have finished).
// Appended to the end of the hints is the number of decimals added as part of the decimal-remainder step

Divider.getHints = function(divisor, digitsDividend, deciDivisor, deciDividend, decimalRemainder) {
    var hints = [];
    //var digitsDividend = KhanUtil.integerToDigits(dividend);
    var dividend = 0;

    if (deciDivisor > 0) {
        hints.push(['shift']);
        if (deciDivisor > deciDividend) {
            digitsDividend = KhanUtil.padDigitsToNum(digitsDividend, digitsDividend.length + deciDivisor - deciDividend);
        }
    }

    if (deciDividend > deciDivisor) {
        hints.push(['bring-up-decimal']);
    }

    // If we want a decimal remainder, add up to 4 extra places
    var numPlaces = digitsDividend.length + (decimalRemainder ? 4 : 0);
    var digits = KhanUtil.padDigitsToNum(digitsDividend, numPlaces);
    var decimalsAdded = 0;
    var decimalsRemainder = ['decimal-remainder', 0];

    for (var i = 0; i < digits.length; i++) {
        if (i >= digitsDividend.length) {
            if (dividend === 0) {
                // No need to add more decimals
                break;
            } else {
                decimalsAdded++;
            }

            if (i === digitsDividend.length) {
                hints.push(decimalsRemainder);
            }
        }

        if (decimalsAdded > 0) {
            decimalsRemainder[1] = decimalsAdded;
        }

        dividend = dividend * 10 + digits[i];
        hints.push(['division', dividend]);

        var quotient = Math.floor(dividend / divisor);
        var product = divisor * quotient;
        dividend -= product;
        hints.push(['result', quotient, dividend]);
    }

    if (dividend === 0 || decimalsAdded !== 4) {
        hints.push(['remainder', dividend]);
    }

    return hints;
};

Divider.getNumberOfHints = function(divisor, dividend, deciDivisor, deciDividend, decimalRemainder) {
    var digitsDividend = KhanUtil.integerToDigits(dividend);
    deciDividend = Divider.processDividend(digitsDividend, deciDividend);
    var hints = Divider.getHints(divisor, digitsDividend, deciDivisor, deciDividend, decimalRemainder);
    return hints.length;
};

Divider.processDividend = function(dividendDigits, deciDividend) {
    // Trim unnecessary zeros after the decimal point
    var end = dividendDigits.length - 1;
    for (var i = 0; i < deciDividend; i++) {
        if (dividendDigits[end - i] === 0) {
            dividendDigits.splice(end - i);
            deciDividend--;
        } else {
            break;
        }
    }

    // Add zeros before the decimal point
    var extraZeros = deciDividend - dividendDigits.length + 1;
    for (var i = 0; i < extraZeros; i++) {
        dividendDigits.splice(0, 0, 0);
    }

    return deciDividend;
};

KhanUtil.Adder = Adder;
KhanUtil.Subtractor = Subtractor;
KhanUtil.Multiplier = Multiplier;
KhanUtil.Divider = Divider;
KhanUtil.drawCircles = drawCircles;
KhanUtil.drawDigits = drawDigits;
KhanUtil.drawRow = drawRow;
KhanUtil.crossOutCircles = crossOutCircles;

});

define('utils/graphie-polygon.js',['require'],function(require) {

$.extend(KhanUtil, {
    Polygon: function(numSides) {
        // This should be renamed...
        // these are the angles between diagonals
        // to construct the polygon.
        var angles = [],
            points = [],
            gExteriorAngles = [];

        function getMaxDiagonalLength(p1, p2, p3) {
            var intersection = findIntersection([p1, p2], [[0, 0], p3]),
                x = intersection[0],
                y = intersection[1];
            return Math.sqrt(x * x + y * y);
        }

        function getDistance(p1, p2) {
            var dx = p2[0] - p1[0],
                dy = p2[1] - p1[1];
            return Math.sqrt(dx * dx + dy * dy);
        }

        // Creates a convex n-gon by choosing n-2 angles,
        // where each of the n vertices will fall somewhere
        // on these diagonals, or rays from the origin.
        // ( see http://gyazo.com/625bd5662ac07707c86fd83d9d8531a1 )
        // Choose the first two diagonal-lengths willy-nilly,
        // but each subsequent vertex must be closer to the origin
        // than the intersection of the corresponding diagonal
        // and the line created by the previous two vertices.
        // Hippopotamus.
        (function() {
            var graph = KhanUtil.currentGraph,
                curr,
                length,
                min = 1,
                max = 5,
                incr = 1;

            for (var i = 0; i < numSides - 2; i++) {
                var evenlyDivided = 180 / numSides,
                    jitter = KhanUtil.randRange(-10, 10) / 40;
                angles.push(evenlyDivided * (1 + jitter));
            }

            while (points.length !== angles.length + 2) {
                curr = 0;
                points = [[0, 0], graph.polar(KhanUtil.randRange(min, max), curr)];
                $.each(angles, function(index, angle) {
                    curr += angle;
                    if (index === 0) {
                        length = KhanUtil.randRange(min, max);
                    } else {
                        var maxLength = getMaxDiagonalLength(points[points.length - 2], points[points.length - 1], graph.polar(min, curr));
                        if (Math.floor(maxLength) <= min + incr) {
                            return;
                        }
                        maxLength = Math.min(Math.floor(maxLength) - incr, max);
                        length = KhanUtil.randRange(min, maxLength);
                    }
                    points.push(graph.polar(length, curr));
                });
            }
        })();

        this.draw = function() {
            var graph = KhanUtil.currentGraph;
            graph.style({stroke: KhanUtil.BLUE });
            points.push([0, 0]);
            graph.path(points);
            points.pop();
        };

        function drawDiagonalTriangle(start) {
            var graph = KhanUtil.currentGraph,
                length = points.length;
            graph.style({stroke: KhanUtil.ORANGE, "stroke-width": 3});
            graph.line(points[start % length], points[(start + 1) % length]);
            graph.line(points[(start + 1) % length], points[(start + 2) % length]);
            graph.line(points[(start + 2) % length], points[start % length]);
        }

        function drawEndTriangles(start) {
            drawDiagonalTriangle(start);
            drawDiagonalTriangle(start + points.length - 2);
        }

        this.drawDiagonals = function(start) {
            var graph = KhanUtil.currentGraph,
                p1 = points[start % points.length];
            $.each(points, function(i, p2) {
                if (start !== i) {
                    graph.line(p1, p2);
                }
            });
            drawEndTriangles(start);
        };

        this.drawRadialDiagonals = function() {
            var graph = KhanUtil.currentGraph,
                cx = 0,
                cy = 0;

            $.each(points, function(index, point) {
                cx += point[0];
                cy += point[1];
            });
            cx /= points.length;
            cy /= points.length;
            graph.style({stroke: KhanUtil.ORANGE}, function() {
                $.each(points, function(index, point) {
                    graph.line([cx, cy], point);
                });
            });
            graph.circle([cx, cy], 0.3);
        };

        this.drawExteriorAngles = function() {
            var graph = KhanUtil.currentGraph,
                prevTheta = 0,
                prevPoint;
            graph.style({ "stroke-dasharray": "-"});
            points.push([0, 0]);
            $.each(points, function(index, point) {
                if (index !== 0) {
                    var distance = getDistance(prevPoint, point),
                        dx = point[0] - prevPoint[0],
                        dy = point[1] - prevPoint[1],
                        theta = Math.acos(dx / distance) * 180 / Math.PI,
                        coord;
                    if (dy < 0) {
                        theta = 360 - theta;
                    }
                    coord = graph.polar(distance + 2, theta);
                    coord[0] += prevPoint[0];
                    coord[1] += prevPoint[1];
                    graph.line(prevPoint, coord);
                    if (index !== 1) {
                        graph.style({"stroke-dasharray": ""}, function() {
                            gExteriorAngles.push(graph.arc(prevPoint, 0.5, prevTheta, theta));
                        });
                    }
                    prevTheta = theta;
                }
                prevPoint = point;
            });
            graph.style({"stroke-dasharray": ""}, function() {
                gExteriorAngles.push(graph.arc(prevPoint, 0.5, prevTheta, 360));
            });
            points.pop();
        };

        function getColor(i) {
            switch (i % 4) {
                case 0: return KhanUtil.BLUE;
                case 1: return KhanUtil.ORANGE;
                case 2: return KhanUtil.GREEN;
                case 3: return KhanUtil.PINK;
            }
        }

        this.animateExteriorAngles = function(start) {
            var graph = KhanUtil.currentGraph,
                origin = graph.scalePoint(points[start]);
            points.push([0, 0]);
            gExteriorAngles.unshift("dummy");
            for (var i = 1; i < gExteriorAngles.length; i++) {
                var gAngle = gExteriorAngles[i],
                    point = points[i],
                    coord = graph.scalePoint(point),
                    clone = gAngle.attr("stroke", getColor(i)).clone();
                clone.animate({ translation: [origin[0] - coord[0], origin[1] - coord[1]] }, 1000);
            }
            points.pop();
            gExteriorAngles.shift();
        };

        this.clone = function() {
            return $.extend(true, {}, this);
        };

        this.ex = function() {
            return gExteriorAngles;
        };
    },

    Circle: function(radius, center) {
        center = center || [0, 0];
        var pointRadius = 0.1;

        (function() {
            var graph = KhanUtil.currentGraph;
            graph.style({stroke: KhanUtil.BLUE});
            graph.circle(center, radius);
        })();

        this.drawPoint = function(theta) {
            var graph = KhanUtil.currentGraph,
                point = graph.polar(radius, theta);
            return graph.circle(point, pointRadius);
        };

        this.drawCenter = function() {
            var graph = KhanUtil.currentGraph;
            graph.style({ fill: KhanUtil.BLUE }, function() {
                graph.circle(center, pointRadius);
            });
        };

        this.drawRadius = function(theta) {
            var graph = KhanUtil.currentGraph,
                point = graph.polar(radius, theta);
            return graph.line(center, point);
        };

        this.drawChord = function(theta1, theta2) {
            var graph = KhanUtil.currentGraph,
                point1 = graph.polar(radius, theta1),
                point2 = graph.polar(radius, theta2);
            return graph.line(point1, point2);
        };

        function isThetaWithin(theta, min, max) {
            min = min % 360;
            max = max % 360;
            if (min > max) {
                return theta < max || theta > min;
            } else {
                return theta > min && theta < max;
            }
        }

        function getThetaFromXY(x, y) {
            var angle = Math.atan2(y, x);
            if (angle < 0) {
                angle += 2 * Math.PI;
            }
            angle = angle * 180 / Math.PI;
            return angle;
        }

        this.drawMovablePoint = function(theta, min, max) {
            var graph = KhanUtil.currentGraph,
                point = graph.polar(radius, theta);
            min = min || 0;
            max = max || 360;
            graph.graph.movable = { vertex: KhanUtil.bogusShape, arc: KhanUtil.bogusShape, chords: [KhanUtil.bogusShape, KhanUtil.bogusShape] };

            graph.graph.inscribedPoint = graph.addMovablePoint({coordX: point[0], coordY: point[1] });

            graph.graph.inscribedPoint.onMove = function(x, y) {
                var theta = getThetaFromXY(x, y);
                if (!isThetaWithin(theta, min, max)) {
                    return false;
                }
                graph.style({stroke: KhanUtil.ORANGE});
                graph.graph.movable.arc.remove();
                graph.graph.movable.chords[0].remove();
                graph.graph.movable.chords[1].remove();
                graph.graph.movable.vertex.remove();
                graph.graph.movable = graph.graph.circle.drawInscribedAngle(theta, max, min);
                return graph.polar(radius, theta);
            };
        };

        this.drawCentralArc = function(start, end, arcRadius) {
            var graph = KhanUtil.currentGraph,
                arc;
            arcRadius = arcRadius || 0.5;
            graph.style({fill: ""}, function() {
                arc = graph.arc(center, arcRadius, start, end);
            });
            return arc;
        };

        this.drawCentralAngle = function(start, end, arcRadius) {
            var result = { radii: [] };
            result.radii.push(this.drawRadius(start));
            result.radii.push(this.drawRadius(end));
            result.arc = this.drawCentralArc(start, end, arcRadius);
            return result;
        };

        this.drawInscribedArc = function(inscribed, start, end, arcRadius) {
            var graph = KhanUtil.currentGraph,
                vertex = graph.polar(radius, inscribed),
                point1 = graph.polar(radius, start),
                point2 = graph.polar(radius, end),
                theta1 = getThetaFromXY(point1[0] - vertex[0], point1[1] - vertex[1]),
                theta2 = getThetaFromXY(point2[0] - vertex[0], point2[1] - vertex[1]),
                arc;
            arcRadius = arcRadius || 0.5;
            graph.style({ fill: "" }, function() {
                arc = graph.arc(vertex, arcRadius, theta1, theta2);
            });
            return arc;
        };

        this.drawInscribedAngle = function(inscribed, start, end, arcRadius) {
            var chords = [this.drawChord(inscribed, start), this.drawChord(inscribed, end)],
                vertex = this.drawPoint(inscribed),
                arc = this.drawInscribedArc(inscribed, start, end, arcRadius);
            return { chords: chords, vertex: vertex, arc: arc };
        };
    }
});

});

define('utils/khanscript.js',['require'],function(require) {

$.fn.khanscript = function(problem) {
    return this.find("script[type='text/khanscript']").each(function() {
        var code = $(this).text();
        code = "(function() {" + code + "})()";
        $.tmpl.getVAR(code);
    }).end();
};

});

(function(root) {
define("third_party/jquery.cursor-position.js", [], function() {
  return (function() {
(function ($) {
    // from http://stackoverflow.com/questions/1891444/how-can-i-get-cursor-position-in-a-textarea?rq=1
    $.fn.getCursorPosition = function() {
        var el = $(this).get(0);
        var pos = 0;
        if ("selectionStart" in el) {
            pos = el.selectionStart;
        } else if ("selection" in document) {
            el.focus();
            var sel = document.selection.createRange();
            var selLength = document.selection.createRange().text.length;
            sel.moveStart("character", -el.value.length);
            pos = sel.text.length - selLength;
        }
        return pos;
    };

    $.fn.isCursorFirst = function() {
        var pos = $(this).getCursorPosition();
        return pos === 0;
    };

    $.fn.isCursorLast = function() {
        var pos = $(this).getCursorPosition();
        var last = $(this).val().length;
        return pos === last;
    };
})(jQuery);


  }).apply(root, arguments);
});
}(this));

/**
 * Allows for intuitive matrix input for matrix exercises.
 *
 * See `matrix_transpose.html` for an example.
 *
 * To use in an exercise:
 *
 * 1. Add "matrix matrix-input" to data-require.
 *
 * 2. Use `matrixPad()` to pad the solution matrix with empty string values
 *     and assign to a `var` named `PADDED_SOLN_MAT`:
 *
 * Ex: <var id="PADDED_SOLN_MAT">matrixPad(SOLN_MAT, 3, 3)</var>
 *
 * 3. Use the following HTML for the
 *     solution markup:
 *
 * <div class="solution" data-type="multiple">
 *     <div data-each="PADDED_SOLN_MAT as row" class="row">
 *         <div data-each="row as elem">
 *             <div data-if="elem !== ''" class="sol">
 *                 <var>elem</var>
 *             </div>
 *             <div data-else data-type="text" class="sol">
 *                 <var>elem</var>
 *             </div>
 *         </div>
 *     </div>
 * </div>
 *
 */
define('utils/matrix-input.js',['require','../third_party/jquery.cursor-position.js'],function(require) {

require("../third_party/jquery.cursor-position.js");

$.extend(KhanUtil, {

    matrixInput: {

        eventsAttached: false,

        containerEl: null,
        bracketEls: null,
        cells: null,

        LEFT_ARROW: 37,
        UP_ARROW: 38,
        RIGHT_ARROW: 39,
        DOWN_ARROW: 40,
        ENTER_KEY: 13,

        ROWS: 3,
        COLS: 3,

        maxRow: 0,
        maxCol: 0,

        contentMaxRow: 0,
        contentMaxCol: 0,

        init: function() {
            var self = this;

            this.initContainer();

            var inputs = $(".matrix-input .sol input[type='text']");
            this.cells = _.map(inputs, function(input, i) {
                return {
                    el: input,
                    index: i,
                    row: self.indexToRow(i),
                    col: self.indexToCol(i),
                    val: function() {
                        return $.trim($(this.el).val());
                    },
                    clearVal: function() {
                        $(this.el).val("");
                    }
                };
            });

            this.addBrackets();

            this.bindInputEvents();
            this.resetAllMaxVals();
            this.render();
        },

        initContainer: function() {
            this.containerEl = $("#solutionarea").addClass("matrix-input");
        },

        addBrackets: function(i) {
            var left = $("<div>").addClass("matrix-bracket bracket-left");
            var right = $("<div>").addClass("matrix-bracket bracket-right");
            this.containerEl.prepend(left, right);
            this.bracketEls = [left, right];
        },

        removeBrackets: function() {
            _.each(this.bracketEls, function(bracketEl) {
                $(bracketEl).remove();
            });
        },

        indexToRow: function(i) {
            return Math.floor(i / this.COLS);
        },

        indexToCol: function(i) {
            return i % this.COLS;
        },

        coordToIndex: function(row, col) {
            return this.COLS * row + col;
        },

        bindInputEvents: function() {
            // We reevaluate the highlighted area after:
            // 1) clicking on some element besides the cells, or
            // 2) tabbing to a new cell in the solution area
            // This is sufficient since these are the only ways
            // the user will get to change the value.
            var self = this;

            // case #1
            $("body").click(function() {
                self.resetMaxToContentMax();
                self.render();
            });

            _.each(this.cells, function(cell) {

                $(cell.el).on({
                    // case #2
                    focus: function(e) {
                        self.setMaxVals(cell);
                        self.render();
                    },

                    blur: function(e) {
                        self.setMaxVals(cell);
                    },

                    // case #1 (prevent from performing a redundant
                    // reevaluation when clicking on a cell, since focus event
                    // is triggered on both tabs and clicks)
                    click: function(e) {
                        e.stopPropagation();
                    },

                    keydown: function(e) {
                        var LAST_ROW = self.ROWS - 1;
                        var LAST_INDEX = self.cells.length - 1;

                        var nextIndex = null;
                        var nextRow;

                        // cursor position only does something when you
                        // are at the start of the input, moving left, or
                        // at the end of the input, moving right

                        if (e.which === self.LEFT_ARROW) {
                            // don't do anything if at the first cell
                            // or if the cursor is not at the start
                            if (cell.index === 0 || !$(this).isCursorFirst()) {
                                 return;
                            }
                            nextIndex = cell.index - 1;

                        } else if (e.which === self.RIGHT_ARROW) {
                            // don't do anything if at the last cell
                            // or if the cursor is not at the end of the input
                            // text
                            if (cell.index === LAST_INDEX ||
                                !$(this).isCursorLast()) {
                                return;
                            }
                            nextIndex = cell.index + 1;

                        } else if (e.which === self.UP_ARROW) {
                            // if already on first row, don't do anything
                            if (cell.row === 0) {
                                return;
                            }
                            nextRow = cell.row - 1;
                            nextIndex = self.coordToIndex(nextRow, cell.col);

                        } else if (e.which === self.DOWN_ARROW) {
                            // if on last row, don't do anything
                            if (cell.row === LAST_ROW) {
                                return;
                            }
                            nextRow = cell.row + 1;
                            nextIndex = self.coordToIndex(nextRow, cell.col);

                        // when submitting via enter key, make sure max vals
                        // are set properly
                        } else if (e.which === self.ENTER_KEY) {
                            self.setMaxVals(cell);
                        }

                        // let default behavior take place if we don't do
                        // anything
                        if (nextIndex === null) {
                            return;
                        }

                        // change focus to next input
                        $(self.cells[nextIndex].el).focus();

                        // don't let event bubble
                        e.preventDefault();
                    }
                });
            });
        },

        setContentMaxRow: function(val) {
            this.contentMaxRow = Math.max(val, this.contentMaxRow);
        },

        setContentMaxCol: function(val) {
            this.contentMaxCol = Math.max(val, this.contentMaxCol);
        },

        // maxRow/maxCol is the max of the currently selected element and the
        // content max element
        setMaxRow: function(val) {
            this.maxRow = Math.max(val, this.contentMaxRow);
        },

        setMaxCol: function(val) {
            this.maxCol = Math.max(val, this.contentMaxCol);
        },

        resetMaxToContentMax: function() {
            this.maxRow = this.contentMaxRow;
            this.maxCol = this.contentMaxCol;
        },

        resetAllMaxVals: function() {
            this.maxRow = 0;
            this.maxCol = 0;
            this.contentMaxRow = 0;
            this.contentMaxCol = 0;
        },

        setMaxValsFromScratch: function() {
            // initialize to 0, since we want to start from scratch
            this.resetAllMaxVals();

            var self = this;
            _.each(this.cells, function(cell) {
                if (cell.val()) {
                    self.setContentMaxRow(cell.row);
                    self.setContentMaxCol(cell.col);
                }
            });

            this.resetMaxToContentMax();
        },

        setMaxVals: function(cell) {
            var val = cell.val();

            // cell is nonempty
            if (val) {
                // only nonempty cell can be used to set content max values
                // unless (see case below)
                this.setContentMaxRow(cell.row);
                this.setContentMaxCol(cell.col);

            // cell is empty
            } else {
                // reset the contents of the cell when it's just spaces
                cell.clearVal();

                // if it was the cell responsible for a content max val(s),
                // we need to find the new content max val(s)...
                if (this.contentMaxRow === cell.row ||
                    this.contentMaxCol === cell.col) {

                    this.setMaxValsFromScratch();
                }
            }

            // both nonempty and empty cells can set absolute max values
            this.setMaxRow(cell.row);
            this.setMaxCol(cell.col);
        },

        // position matrix brackets based on bounds
        positionBrackets: function() {

            var cell = $(this.cells[0].el);
            var bracketWidth = this.bracketEls[0].width();

            var rows = this.maxRow + 1;
            var cols = this.maxCol + 1;

            var height = cell.outerHeight(true) * rows;
            var marginLeft = cell.outerWidth(true) * cols - bracketWidth;

            _.each(this.bracketEls, function($el) {
                $el.css({
                    "height": height
                });
            });

            // right bracket
            this.bracketEls[1].css({
                "margin-left": marginLeft
            });
        },

        render: function() {
            this.positionBrackets();
        },

        cleanup: function() {
            this.removeBrackets();
        }
    }
});

$.fn["matrix-inputLoad"] = function() {
    if (KhanUtil.matrixInput.eventsAttached) {
        return;
    }

    $(Exercises).on("newProblem.matrix-input", function() {
        KhanUtil.matrixInput.init();
    });

    $(Khan).on("showGuess.matrix-input", function() {
        KhanUtil.matrixInput.setMaxValsFromScratch();
        KhanUtil.matrixInput.render();
    });

    KhanUtil.matrixInput.eventsAttached = true;
};

$.fn["matrix-inputCleanup"] = function() {
    if (!KhanUtil.matrixInput.eventsAttached) {
        return;
    }

    KhanUtil.matrixInput.cleanup();
    $(Exercises).off("newProblem.matrix-input");
    $(Khan).off("showGuess.matrix-input");

    KhanUtil.matrixInput.eventsAttached = false;
};

});

define('utils/stat.js',['require','./math.js'],function(require) {

require("./math.js");

$.extend(KhanUtil, {
    sum: function(values) {
        var sum = 0;

        $.each(values, function(index, value) {
            sum += value;
        });
        return sum;
    },

    mean: function(values) {
        return KhanUtil.sum(values) / values.length;
    },

    median: function(values) {
        var sortedInts, median;
        sortedInts = KhanUtil.sortNumbers(values);

        if (values.length % 2 === 0) {
            median = KhanUtil.roundTo(1,
                (sortedInts[(values.length / 2) - 1] + sortedInts[values.length / 2]) / 2);
        } else {
            median = sortedInts[Math.floor(values.length / 2)];
        }
        return median;
    },

    mode: function(values) {
        var numInstances = [];
        var modeInstances = -1;

        var mode;
        for (var i = 0; i < values.length; i++) {
            if (!numInstances[values[i]]) {
                numInstances[values[i]] = 1;
            } else {
                numInstances[values[i]] += 1;
                if (numInstances[values[i]] > modeInstances) {
                    modeInstances = numInstances[values[i]];
                    mode = values[i];
                }
            }
        }

        // iterate again to check for 'no mode'
        for (var i = 0; i < numInstances.length; i++) {
            if (numInstances[i]) {
                if (i !== mode && numInstances[i] >= modeInstances) {
                    return false;
                }
            }
        }

        return mode;
    },

    variance: function(values) {
        var xbar = KhanUtil.mean(values);
        var n = values.length;

        var sum = 0;
        $.each(values, function(i, x_i) {
            sum += (x_i - xbar) * (x_i - xbar);
        });
        return sum / (n - 1);
    },

    variancePop: function(values) {
        var xbar = KhanUtil.mean(values);
        var N = values.length;

        var sum = 0;
        $.each(values, function(i, x_i) {
            sum += (x_i - xbar) * (x_i - xbar);
        });
        return sum / N;
    },

    stdDev: function(values) {
        return Math.sqrt(KhanUtil.variance(values));
    },

    stdDevPop: function(values) {
        return Math.sqrt(KhanUtil.variancePop(values));
    },

    // Gaussian distribution using Box-Muller transform
    // defaults to standard normal unless target mean and stddev are passed
    // Pass "count" to get an array of data
    randGaussian: function(tgtMean, tgtStdDev, count) {
        if (count == null) {
            var x1, x2, rad;

            do {
                x1 = 2 * KhanUtil.random() - 1;
                x2 = 2 * KhanUtil.random() - 1;
                rad = x1 * x1 + x2 * x2;
            } while (rad >= 1 || rad === 0);

            var c = Math.sqrt(-2 * Math.log(rad) / rad);

            return x1 * c * (tgtStdDev || 1) + (tgtMean || 0);
        } else {
            return $.map(new Array(count), function() {
                return KhanUtil.randGaussian(tgtMean, tgtStdDev);
            });
        }
    },

    gaussianPDF: function(mean, stddev, x) {
        return (1 / Math.sqrt(2 * Math.PI * stddev * stddev)) * Math.exp(-((x - mean) * (x - mean)) / (2 * stddev * stddev));
    },

    zScores: function(z) {
        return ({
            "0": 0.5, "1": 0.504, "2": 0.508, "3": 0.512, "4": 0.516,
            "5": 0.5199, "6": 0.5239, "7": 0.5279, "8": 0.5319, "9": 0.5359,
            "10": 0.5398, "11": 0.5438, "12": 0.5478, "13": 0.5517, "14": 0.5557,
            "15": 0.5596, "16": 0.5636, "17": 0.5675, "18": 0.5714, "19": 0.5753,
            "20": 0.5793, "21": 0.5832, "22": 0.5871, "23": 0.591, "24": 0.5948,
            "25": 0.5987, "26": 0.6026, "27": 0.6064, "28": 0.6103, "29": 0.6141,
            "30": 0.6179, "31": 0.6217, "32": 0.6255, "33": 0.6293, "34": 0.6331,
            "35": 0.6368, "36": 0.6406, "37": 0.6443, "38": 0.648, "39": 0.6517,
            "40": 0.6554, "41": 0.6591, "42": 0.6628, "43": 0.6664, "44": 0.67,
            "45": 0.6736, "46": 0.6772, "47": 0.6808, "48": 0.6844, "49": 0.6879,
            "50": 0.6915, "51": 0.695, "52": 0.6985, "53": 0.7019, "54": 0.7054,
            "55": 0.7088, "56": 0.7123, "57": 0.7157, "58": 0.719, "59": 0.7224,
            "60": 0.7257, "61": 0.7291, "62": 0.7324, "63": 0.7357, "64": 0.7389,
            "65": 0.7422, "66": 0.7454, "67": 0.7486, "68": 0.7517, "69": 0.7549,
            "70": 0.758, "71": 0.7611, "72": 0.7642, "73": 0.7673, "74": 0.7704,
            "75": 0.7734, "76": 0.7764, "77": 0.7794, "78": 0.7823, "79": 0.7852,
            "80": 0.7881, "81": 0.791, "82": 0.7939, "83": 0.7967, "84": 0.7995,
            "85": 0.8023, "86": 0.8051, "87": 0.8078, "88": 0.8106, "89": 0.8133,
            "90": 0.8159, "91": 0.8186, "92": 0.8212, "93": 0.8238, "94": 0.8264,
            "95": 0.8289, "96": 0.8315, "97": 0.834, "98": 0.8365, "99": 0.8389,
            "100": 0.8413, "101": 0.8438, "102": 0.8461, "103": 0.8485, "104": 0.8508,
            "105": 0.8531, "106": 0.8554, "107": 0.8577, "108": 0.8599, "109": 0.8621,
            "110": 0.8643, "111": 0.8665, "112": 0.8686, "113": 0.8708, "114": 0.8729,
            "115": 0.8749, "116": 0.877, "117": 0.879, "118": 0.881, "119": 0.883,
            "120": 0.8849, "121": 0.8869, "122": 0.8888, "123": 0.8907, "124": 0.8925,
            "125": 0.8944, "126": 0.8962, "127": 0.898, "128": 0.8997, "129": 0.9015,
            "130": 0.9032, "131": 0.9049, "132": 0.9066, "133": 0.9082, "134": 0.9099,
            "135": 0.9115, "136": 0.9131, "137": 0.9147, "138": 0.9162, "139": 0.9177,
            "140": 0.9192, "141": 0.9207, "142": 0.9222, "143": 0.9236, "144": 0.9251,
            "145": 0.9265, "146": 0.9279, "147": 0.9292, "148": 0.9306, "149": 0.9319,
            "150": 0.9332, "151": 0.9345, "152": 0.9357, "153": 0.937, "154": 0.9382,
            "155": 0.9394, "156": 0.9406, "157": 0.9418, "158": 0.9429, "159": 0.9441,
            "160": 0.9452, "161": 0.9463, "162": 0.9474, "163": 0.9484, "164": 0.9495,
            "165": 0.9505, "166": 0.9515, "167": 0.9525, "168": 0.9535, "169": 0.9545,
            "170": 0.9554, "171": 0.9564, "172": 0.9573, "173": 0.9582, "174": 0.9591,
            "175": 0.9599, "176": 0.9608, "177": 0.9616, "178": 0.9625, "179": 0.9633,
            "180": 0.9641, "181": 0.9649, "182": 0.9656, "183": 0.9664, "184": 0.9671,
            "185": 0.9678, "186": 0.9686, "187": 0.9693, "188": 0.9699, "189": 0.9706,
            "190": 0.9713, "191": 0.9719, "192": 0.9726, "193": 0.9732, "194": 0.9738,
            "195": 0.9744, "196": 0.975, "197": 0.9756, "198": 0.9761, "199": 0.9767,
            "200": 0.9772, "201": 0.9778, "202": 0.9783, "203": 0.9788, "204": 0.9793,
            "205": 0.9798, "206": 0.9803, "207": 0.9808, "208": 0.9812, "209": 0.9817,
            "210": 0.9821, "211": 0.9826, "212": 0.983, "213": 0.9834, "214": 0.9838,
            "215": 0.9842, "216": 0.9846, "217": 0.985, "218": 0.9854, "219": 0.9857,
            "220": 0.9861, "221": 0.9864, "222": 0.9868, "223": 0.9871, "224": 0.9875,
            "225": 0.9878, "226": 0.9881, "227": 0.9884, "228": 0.9887, "229": 0.989,
            "230": 0.9893, "231": 0.9896, "232": 0.9898, "233": 0.9901, "234": 0.9904,
            "235": 0.9906, "236": 0.9909, "237": 0.9911, "238": 0.9913, "239": 0.9916,
            "240": 0.9918, "241": 0.992, "242": 0.9922, "243": 0.9925, "244": 0.9927,
            "245": 0.9929, "246": 0.9931, "247": 0.9932, "248": 0.9934, "249": 0.9936,
            "250": 0.9938, "251": 0.994, "252": 0.9941, "253": 0.9943, "254": 0.9945,
            "255": 0.9946, "256": 0.9948, "257": 0.9949, "258": 0.9951, "259": 0.9952,
            "260": 0.9953, "261": 0.9955, "262": 0.9956, "263": 0.9957, "264": 0.9959,
            "265": 0.996, "266": 0.9961, "267": 0.9962, "268": 0.9963, "269": 0.9964,
            "270": 0.9965, "271": 0.9966, "272": 0.9967, "273": 0.9968, "274": 0.9969,
            "275": 0.997, "276": 0.9971, "277": 0.9972, "278": 0.9973, "279": 0.9974,
            "280": 0.9974, "281": 0.9975, "282": 0.9976, "283": 0.9977, "284": 0.9977,
            "285": 0.9978, "286": 0.9979, "287": 0.9979, "288": 0.998, "289": 0.9981,
            "290": 0.9981, "291": 0.9982, "292": 0.9982, "293": 0.9983, "294": 0.9984,
            "295": 0.9984, "296": 0.9985, "297": 0.9985, "298": 0.9986, "299": 0.9986,
            "300": 0.9987, "301": 0.9987, "302": 0.9987, "303": 0.9988, "304": 0.9988,
            "305": 0.9989, "306": 0.9989, "307": 0.9989, "308": 0.999, "309": 0.999
        }[z]);
    }

});

});

define('utils/mean-and-median.js',['require','./stat.js'],function(require) {

require("./stat.js");

$.extend(KhanUtil, {

    updateMean: function(mean) {
        var graph = KhanUtil.currentGraph;

        graph.graph.meanArrow.translate((mean * graph.scale[0]) - graph.graph.meanArrow.attr("translation").x, 0);
        graph.graph.meanValueLabel.remove();
        graph.graph.meanValueLabel = graph.label([mean, 0.8],
            (mean + "").replace(/-(\d)/g, "\\llap{-}$1"),
            "above",
            { color: KhanUtil.BLUE }
        );

        graph.graph.meanLabel.remove();
        graph.graph.meanLabel = graph.label([mean, 1.3], $._("\\text{mean}"),
            "above", { color: KhanUtil.BLUE });

        graph.graph.mean = mean;
    },


    updateMedian: function(median) {
        var graph = KhanUtil.currentGraph;

        graph.graph.medianArrow.translate((median * graph.scale[0]) - graph.graph.medianArrow.attr("translation").x, 0);
        graph.graph.medianValueLabel.remove();
        graph.graph.medianValueLabel = graph.label([median, -1.2],
            (median + "").replace(/-(\d)/g, "\\llap{-}$1"),
            "below",
            { color: KhanUtil.GREEN }
        );

        graph.graph.medianLabel.remove();
        graph.graph.medianLabel = graph.label([median, -1.7],
            $._("\\text{median}"), "below", { color: KhanUtil.GREEN });

        graph.graph.median = median;
    },

    updateMeanAndMedian: function() {
        var points = KhanUtil.currentGraph.graph.points;
        var mean = KhanUtil.mean($.map(points, function(el) { return el.coord[0]; }));
        var median = KhanUtil.median($.map(points, function(el) { return el.coord[0]; }));

        KhanUtil.updateMean(KhanUtil.roundTo(2, mean));
        KhanUtil.updateMedian(KhanUtil.roundTo(2, median));
    },

    updateMeanAndStddev: function() {
        var graph = KhanUtil.currentGraph;
        var points = KhanUtil.currentGraph.graph.points;
        var mean = KhanUtil.mean($.map(points, function(el) { return el.coord[0]; }));
        var stddev = KhanUtil.stdDev($.map(points, function(el) { return el.coord[0]; }));

        mean = KhanUtil.roundTo(1, mean);
        stddev = KhanUtil.roundTo(1, stddev);

        graph.graph.stddevLeft.translate(((mean) * graph.scale[0]) - graph.graph.stddevLeft.attr("translation").x, 0);
        graph.graph.stddevRight.translate(((mean + stddev) * graph.scale[0]) - graph.graph.stddevRight.attr("translation").x, 0);
        graph.graph.stddevLine.translate(((mean) * graph.scale[0]) - graph.graph.stddevLine.attr("translation").x, 0);
        graph.graph.stddevLine.scale(stddev, 1, graph.graph.stddevLine.attr("path")[0][1], graph.graph.stddevLine.attr("path")[0][2]);

        graph.graph.stddevValueLabel.remove();
        graph.graph.stddevValueLabel = graph.label([stddev / 2 + mean, -1.3], "s \\approx " + stddev, "below", { color: KhanUtil.GREEN });

        if (stddev > 0) {

            graph.style({ strokeWidth: 2, stroke: "#bbb", fill: null, "plot-points": 100 }, function() {
                graph.graph.pdf.remove();
                graph.graph.pdf = graph.plot(function(x) {
                    return KhanUtil.gaussianPDF(mean, stddev, x) * 5 - 0.2;
                }, [-7, 7]).toBack();
            });

            graph.style({ strokeWidth: 2, stroke: KhanUtil.BLUE, fill: null }, function() {
                graph.graph.meanLine.remove();
                graph.graph.meanLine = graph.line([mean, -0.2], [mean, KhanUtil.gaussianPDF(mean, stddev, mean) * 5 - 0.2]).toBack();
            });

            graph.graph.meanValueLabel.remove();
            graph.graph.meanValueLabel = graph.label(
                [mean, KhanUtil.gaussianPDF(mean, stddev, mean) * 5 - 0.2],
                "\\bar{x} \\approx " + mean, "above", { color: KhanUtil.BLUE }
            );

            var points = [];

            points.push([mean - stddev, -0.2]);
            points.push([mean - stddev, KhanUtil.gaussianPDF(mean, stddev, mean - stddev) * 5 - 0.2]);
            var step = stddev / 50;
            for (var x = mean - stddev; x <= mean + stddev; x += step) {
                points.push([x, KhanUtil.gaussianPDF(mean, stddev, x) * 5 - 0.2]);
            }
            points.push([mean + stddev, KhanUtil.gaussianPDF(mean, stddev, mean + stddev) * 5 - 0.2]);
            points.push([mean + stddev, -0.2]);

            graph.style({ strokeWidth: 0, stroke: null, fill: KhanUtil.GREEN, opacity: 0.3 }, function() {
                graph.graph.stddevArea.remove();
                graph.graph.stddevArea = graph.path(points).toBack();
            });

        } else {
            graph.graph.pdf.remove();
            graph.graph.pdf = KhanUtil.bogusShape;
        }


        graph.graph.mean = mean;
        graph.graph.stddev = stddev;
    },


    onMovePoint: function(point, x, y, updateFunction) {
        var points = KhanUtil.currentGraph.graph.points;

        // don't allow the point to move past the bounds
        x = Math.min(Math.max(-7, x), 7);

        // Don't do anything unless the point actually moved
        if (point.coord[0] !== x) {

            point.coord = [x, 0];

            // Figure out which points are at the same position
            var positions = {};
            // The point being dragged is always at the bottom of the pile
            positions[Math.round(x * 2) / 2] = [point];

            $.each(points, function() {
                if (this !== point) {
                    var pos = Math.round(this.coord[0] * 2) / 2;
                    if (!_.isArray(positions[pos])) {
                        positions[pos] = [];
                    }
                    positions[pos].push(this);
                }
            });

            if (_.isFunction(updateFunction)) {
                updateFunction();
            }

            // Adjust the y-value of each point in case points are stacked
            $.each(positions, function(value, points) {
                points = points.sort(function(a, b) { return a.coord[1] - b.coord[1]; });
                $.each(points, function(i, point) {
                    if (updateFunction !== undefined) {
                        point.moveTo(point.coord[0], 0.3 * i);
                    } else {
                        point.setCoord([point.coord[0], 0.3 * i]);
                    }
                });
            });

            return [x, 0];
        }
    },


    arrangePointsAroundMedian: function() {
        var graph = KhanUtil.currentGraph;
        var points = graph.graph.points;
        var targetMedian = graph.graph.targetMedian;
        var numPoints = graph.graph.numPoints;
        var maxWidth = Math.min(Math.abs(-7 - targetMedian), Math.abs(7 - targetMedian));

        var distance = 0.5;
        var newValues = [];
        if (numPoints % 2 === 0) {
            newValues.push(targetMedian + distance);
            newValues.push(targetMedian - distance);
            distance += 0.5;
        } else {
            newValues.push(targetMedian);
        }

        while (newValues.length < points.length) {
            newValues.push(targetMedian + distance);
            newValues.push(targetMedian - distance);
            if (distance >= maxWidth) {
                distance = 0.5;
            } else {
                distance += 0.5;
            }
        }
        return KhanUtil.sortNumbers(newValues);
    },


    animatePoints: function(oldValues, newValues, newMedian, newMean) {
        var graph = KhanUtil.currentGraph;
        var points = graph.graph.points;
        var sortedPoints = points.sort(function(a, b) { return a.coord[0] - b.coord[0]; });

        $.each(oldValues, function(i, oldValue) {
            $({ 0: oldValue }).animate({ 0: newValues[i] }, {
                duration: 500,
                step: function(now, fx) {
                    KhanUtil.onMovePoint(sortedPoints[i], now, 0);
                }
            });
        });

        $({ median: graph.graph.median, mean: graph.graph.mean }).animate({
            median: newMedian, mean: newMean
        }, {
            duration: 500,
            step: function(now, fx) {
                if (fx.prop === "median") {
                    KhanUtil.updateMedian(KhanUtil.roundTo(2, now));
                } else if (fx.prop === "mean") {
                    KhanUtil.updateMean(KhanUtil.roundTo(2, now));
                }
            }
        });
    },


    showMedianExample: function(onComplete) {
        var points = KhanUtil.currentGraph.graph.points;
        var targetMedian = KhanUtil.currentGraph.graph.targetMedian;
        var sortedPoints = points.sort(function(a, b) { return a.coord[0] - b.coord[0]; });
        var oldValues = [];
        $.each(sortedPoints, function(i, point) {
            oldValues.push(point.coord[0]);
        });
        var newValues = KhanUtil.arrangePointsAroundMedian();

        KhanUtil.animatePoints(oldValues, newValues, targetMedian, targetMedian);
        KhanUtil.currentGraph.graph.moved = true;
    },


    showMeanExample: function() {
        var graph = KhanUtil.currentGraph;
        var points = graph.graph.points;

        var calculateMean = function(values) {
            var mean = 0;
            $.each(values, function() {
                mean += this;
            });
            mean /= values.length;
            return mean;
        };

        var sortedPoints = points.sort(function(a, b) { return a.coord[0] - b.coord[0]; });
        var oldValues = [];
        $.each(sortedPoints, function(i, point) {
            oldValues.push(point.coord[0]);
        });

        var newValues = KhanUtil.arrangePointsAroundMedian();

        // Keep moving outlier points further away from the median until
        // we get to the right mean
        var mean = calculateMean(newValues);
        while (mean !== graph.graph.targetMean) {
            if (mean < graph.graph.targetMean) {
                // Start by moving the right-most point further to the right, then the next, etc.
                var pointToMove = newValues.length - 1;
                while (newValues[pointToMove] === 7 && pointToMove > (points.length / 2)) {
                    --pointToMove;
                }
                // If we move all the points on the right of the median all the way to the right
                // and we still don't have the right mean, start moving points on the left
                // closer to the median
                if (pointToMove <= (points.length / 2)) {
                    pointToMove = 0;
                }
                newValues[pointToMove] += 0.5;
            } else {
                // Start by moving the left-most point further to the left, then the next, etc.
                var pointToMove = 0;
                while (newValues[pointToMove] === -7 && pointToMove < (points.length / 2 - 1)) {
                    ++pointToMove;
                }
                // If we move all the points on the left of the median all the way to the left
                // and we still don't have the right mean, start moving points on the right
                // closer to the median
                if (pointToMove >= (points.length / 2 - 1)) {
                    pointToMove = newValues.length - 1;
                }
                newValues[pointToMove] -= 0.5;
            }
            mean = calculateMean(newValues);
            newValues = KhanUtil.sortNumbers(newValues);
        }

        KhanUtil.animatePoints(oldValues, newValues, graph.graph.targetMedian, graph.graph.targetMean);
        KhanUtil.currentGraph.graph.moved = true;
    },

    showStddevExample: function() {
        var points = KhanUtil.currentGraph.graph.points;
        var targetStddev = KhanUtil.currentGraph.graph.targetStddev;
        var sortedPoints = points.sort(function(a, b) { return a.coord[0] - b.coord[0]; });
        var oldValues = [];
        $.each(sortedPoints, function(i, point) {
            oldValues.push(point.coord[0]);
        });
        var newValues = new Array(points.length);

        // brute force answer finder :(
        var loopCount = 0;
        do {
            newValues = $.map(newValues, function() {
                return KhanUtil.roundToNearest(0.5, KhanUtil.randGaussian() * targetStddev);
            });
            newValues = KhanUtil.sortNumbers(newValues);
            ++loopCount;
        } while (loopCount < 1000 && (
            KhanUtil.roundTo(1, KhanUtil.mean(newValues) !== 0) ||
            KhanUtil.roundTo(1, KhanUtil.stdDev(newValues)) !== targetStddev ||
            _.isEqual(oldValues, newValues)
        ));
        if (loopCount === 1000) {
            // better this than an infinte loop
            newValues = oldValues.slice();
        }


        $.each(oldValues, function(i, oldValue) {
            $({ 0: oldValue }).animate({ 0: newValues[i] }, {
                duration: 500,
                step: function(now, fx) {
                    KhanUtil.onMovePoint(sortedPoints[i], now, 0);
                }
            });
        });
        $({ 0: 0 }).animate({ 0: 1 }, {
            duration: 600,
            step: function(now, fx) {
                KhanUtil.updateMeanAndStddev();
            }
        });
        KhanUtil.currentGraph.graph.moved = true;
    }

});

});

define('utils/parabola-intuition.js',['require'],function(require) {

$.extend(KhanUtil, {
    doParabolaInteraction: function(func, vertex, directrix) {
        var graph = KhanUtil.currentGraph;

        var vertexLine = KhanUtil.bogusShape;
        var directrixLine = KhanUtil.bogusShape;
        var lineEndcap = KhanUtil.bogusShape;
        var highlighted = false;

        // Attach an onMove handler that gets called whenever the mouse hovers over
        // the parabola
        func.onMove = function(coordX, coordY) {
            vertexLine.remove();
            directrixLine.remove();
            lineEndcap.remove();
            graph.style({ strokeWidth: 1.5, stroke: KhanUtil.GREEN, opacity: 0.0 });
            var vertexDistance = KhanUtil.getDistance([coordX, coordY], vertex.coord);

            // Draw a line from the vertex to the highlighted point on the parabola
            vertexLine = graph.line([coordX, coordY], vertex.coord);
            // Draw the horizontal line from the highlighted point on the parabola towards the directrix
            if (directrix.coordA[1] < coordY) {
                directrixLine = graph.line([coordX, coordY], [coordX, coordY - vertexDistance]);
                lineEndcap = graph.line([coordX - 0.05, coordY - vertexDistance], [coordX + 0.05, coordY - vertexDistance]);
            } else {
                directrixLine = graph.line([coordX, coordY], [coordX, coordY + vertexDistance]);
                lineEndcap = graph.line([coordX - 0.05, coordY + vertexDistance], [coordX + 0.05, coordY + vertexDistance]);
            }
            vertexLine.toBack();
            directrixLine.toBack();
            if (!highlighted) {
                vertexLine.animate({opacity: 1.0}, 100);
                directrixLine.animate({opacity: 1.0}, 100);
                lineEndcap.animate({opacity: 1.0}, 100);
            } else {
                vertexLine.attr({ opacity: 1.0 });
                directrixLine.attr({ opacity: 1.0 });
                lineEndcap.attr({ opacity: 1.0 });
            }
            highlighted = true;
        };

        // Attach an onLeave handler that gets called whenever the mouse moves away from the parabola
        func.onLeave = function(coordX, coordY) {
            vertexLine.animate({opacity: 0.0}, 100);
            directrixLine.animate({opacity: 0.0}, 100);
            lineEndcap.animate({ opacity: 0.0 }, 100);
            highlighted = false;
        };

    },

    doHyperbolaInteraction: function(func, focus1, focus2) {
        var graph = KhanUtil.currentGraph;
        var focusLine1 = KhanUtil.bogusShape;
        var focusLine2 = KhanUtil.bogusShape;
        var highlighted = false;

        func.onMove = function(coordX, coordY) {
            focusLine1.remove();
            focusLine2.remove();

            // Draw a line from each focus to the highlighted point on the hyperbola
            graph.style({ strokeWidth: 1.5, stroke: KhanUtil.GREEN, opacity: 0.0 });
            focusLine1 = graph.line([coordX, coordY], focus1.coord);
            graph.style({ stroke: KhanUtil.RED });
            focusLine2 = graph.line([coordX, coordY], focus2.coord);

            focusLine1.toBack();
            focusLine2.toBack();

            if (!highlighted) {
                focusLine1.animate({opacity: 1.0}, 100);
                focusLine2.animate({opacity: 1.0}, 100);
                $('#problemarea div.focus-instructions').hide();
                $('#problemarea div.focus-distances').show();
            } else {
                focusLine1.attr({ opacity: 1.0 });
                focusLine2.attr({ opacity: 1.0 });
            }

            highlighted = true;
            this.writeDistances(coordX, coordY);
        };

        func.onLeave = function(coordX, coordY) {
            focusLine1.animate({opacity: 0.0}, 100);
            focusLine2.animate({opacity: 0.0}, 100);
            $('#problemarea div.focus-instructions').show();
            $('#problemarea div.focus-distances').hide();
            highlighted = false;
        };
    },

    doEllipseInteraction: function(ellipse, focus1, focus2) {
        var graph = KhanUtil.currentGraph;
        var focusLine1 = KhanUtil.bogusShape;
        var focusLine2 = KhanUtil.bogusShape;
        var highlighted = false;

        ellipse.onMove = function(coordX, coordY) {
            focusLine1.remove();
            focusLine2.remove();

            // Draw a line from each focus to the highlighted point on the ellipse
            graph.style({ strokeWidth: 1.5, stroke: KhanUtil.GREEN, opacity: 0.0 });
            focusLine1 = graph.line([coordX, coordY], focus1.coord);
            graph.style({ stroke: KhanUtil.RED });
            focusLine2 = graph.line([coordX, coordY], focus2.coord);

            focusLine1.toBack();
            focusLine2.toBack();

            if (!highlighted) {
                focusLine1.animate({opacity: 1.0}, 100);
                focusLine2.animate({opacity: 1.0}, 100);
                $('#problemarea div.focus-instructions').hide();
                $('#problemarea div.focus-distances').show();
            } else {
                focusLine1.attr({ opacity: 1.0 });
                focusLine2.attr({ opacity: 1.0 });
            }

            highlighted = true;
            this.writeDistances(coordX, coordY);
        };

        ellipse.onLeave = function(coordX, coordY) {
            focusLine1.animate({opacity: 0.0}, 100);
            focusLine2.animate({opacity: 0.0}, 100);
            $('#problemarea div.focus-instructions').show();
            $('#problemarea div.focus-distances').hide();
            highlighted = false;
        };
    }

});

});

define('utils/polynomials.js',['require','./math.js','./expressions.js'],function(require) {

require("./math.js");
require("./expressions.js");

$.extend(KhanUtil, {
    Polynomial: function(minDegree, maxDegree, coefs, variable, name) {
        var term = function(coef, vari, degree) {

            // sort of a weird error behavior
            if (typeof coef === "undefined" || coef === 0) {
                return null;
            }

            if (degree === 0) {
                return coef;
            } else if (degree === 1) {
                return ["*", coef, vari];
            } else {
                return ["*", coef, ["^", vari, degree]];
            }

        };

        // inverse of term.    Given an expression it returns the coef and degree.
        // calculus needs this for hints
        var extractFromExpr = function(expr) {
            var coef, degree;
            if (typeof expr === "number") {
                coef = expr;
                degree = 0;
            } else if (_.isArray(expr) && !_.isArray(expr[2])) {
                coef = expr[1];
                degree = 1;
            } else if (_.isArray(expr) && _.isArray(expr[2])) {
                coef = expr[1];
                degree = expr[2][2];
            }
            return {
                coef: coef,
                degree: degree
            };
        };

        // These seem royally useless to me
        if (maxDegree >= minDegree) {
            this.minDegree = minDegree;
            this.maxDegree = maxDegree;
        } else {
            this.minDegree = maxDegree;
            this.maxDegree = minDegree;
        }

        this.coefs = coefs || KhanUtil.randCoefs(this.minDegree, this.maxDegree);

        this.variable = (typeof variable !== "undefined") ? variable : "x";

        this.name = name || "f";

        this.findMaxDegree = function(coefs) {
            if (!coefs) {
                for (var i = this.maxDegree; i >= this.minDegree; i--) {
                    if (this.coefs[i] !== 0) {
                        return i;
                    }
                }
            } else {
                for (var i = coefs.length - 1; i >= 0; i--) {
                    if (coefs[i] !== 0) {
                        return i;
                    }
                }
                return -1;
            }
        };

        this.findMinDegree = function(coefs) {
            if (!coefs) {
                for (var i = this.minDegree; i <= this.maxDegree; i++) {
                    if (this.coefs[i] !== 0) {
                        return i;
                    }
                }
            } else {
                for (var i = 0; i < coefs.length; i++) {
                    if (coefs[i] !== 0) {
                        return i;
                    }
                }
                return -1;
            }
        };

        this.expr = function(vari) {
            if (typeof vari === "undefined") {
                vari = this.variable;
            }

            var expr = ["+"];

            for (var i = this.maxDegree; i >= this.minDegree; i--) {
                var theTerm = term(this.coefs[i], vari, i);

                if (theTerm != null) {
                    expr.push(theTerm);
                }
            }

            return expr;
        };

        this.getNumberOfTerms = function() {

            // -1 as the first term in the expression for a polynomial is always a "+"
            return this.expr().length - 1;

        };

        this.getCoefAndDegreeForTerm = function(termIndex) {

            //returns the coef and degree for a particular term
            var numberOfTerms = this.getNumberOfTerms();

            //mod twice to always get positive
            termIndex = ((termIndex % numberOfTerms) + numberOfTerms) % numberOfTerms;

            //upshift by one due to "+" sign at the front of the expression
            return extractFromExpr(this.expr()[termIndex + 1]);

        };

        this.text = function() {
            return KhanUtil.expr(this.expr(this.variable));
        };


        // Return a string that the expression editor can understand
        // Probably a better way to do this than string replacements
        this.parsableText = function() {
            var s = this.text();
            s = s.replace(/{/g, "(").replace(/}/g, ")");
            return s;
        };

        this.toString = this.text;

        this.hintEvalOf = function(val) {
            return KhanUtil.expr(this.expr(val));
        };

        this.evalOf = function(val) {
            return KhanUtil.expr(this.expr(val), true);
        };

        this.hint = function(val) {
            var hints = [];
            hints.push("<p><code>" + this.name + "(" + val + ") = " +
                this.hintEvalOf(val) + "</code></p>");
            hints.push("<p><code>" + this.name + "(" + val + ") = " +
                this.evalOf(val) + "</code></p>");

            return hints;
        };

        this.derivative = function() {
            var ddxCoefs = [];

            for (var i = this.maxDegree; i >= this.minDegree; i--) {
                ddxCoefs[i - 1] = i * this.coefs[i];
            }

            // if the term's degree is zero, the derivative degree is not
            // decremented
            var ddxMinDegree = this.minDegree ? this.minDegree - 1 : 0;
            var ddxMaxDegree = this.maxDegree ? this.maxDegree - 1 : 0;

            return new KhanUtil.Polynomial(ddxMinDegree, ddxMaxDegree, ddxCoefs, this.variable);
        };

        /**
         * Add this polynomial to a number or other polynomial.
         *
         * Assumes the second polynomial's variable is the same as the first
         * polynomial's.
         *
         * Does not change the polynomials, returns the result.
         */
        this.add = function(addend) {
            var coefs = [];

            if (typeof addend === "number") {
                addend = new KhanUtil.Polynomial(0, 0, [addend], this.variable);
            }

            // Assume if it's not a number it's a polynomial
            var minDegree = Math.min(this.minDegree, addend.minDegree);
            var maxDegree = Math.max(this.maxDegree, addend.maxDegree);
            for (var i = minDegree; i <= maxDegree; i++) {
                var value = 0;

                value += i <= this.maxDegree ? this.coefs[i] : 0;
                value += i <= addend.maxDegree ? addend.coefs[i] : 0;

                coefs[i] = value;
            }

            return new KhanUtil.Polynomial(minDegree, maxDegree, coefs, this.variable);
        };

        /**
         * Subtracts a number or other polynomial from this polynomial.
         *
         * Assumes the second polynomial's variable is the same as the first
         * polynomial's.
         *
         * Does not change the polynomials, returns the result.
         */
        this.subtract = function(addend) {
            if (typeof addend === "number") {
                return this.add(-addend);
            } else {
                return this.add(addend.multiply(-1));
            }
        };

        /**
         * Multiplies this polynomial by a number or other polynomial.
         *
         * Assumes the second polynomial's variable is the same as the first
         * polynomial's.
         *
         * Does not change the polynomials, returns the result.
         */
        this.multiply = function(value) {
            var coefs = [];
            if (typeof value === "number") {

                for (var i = 0; i < this.coefs.length; i++) {
                    coefs[i] = this.coefs[i] * value;
                }

                return new KhanUtil.Polynomial(this.minDegree, this.maxDegree, coefs, this.variable);

            // Assume if it's not a number it's a polynomial
            } else {
                for (var i = this.minDegree; i <= this.maxDegree; i++) {
                    if (this.coefs[i] === 0) {
                        continue;
                    }
                    for (var j = value.minDegree; j <= value.maxDegree; j++) {
                        if (value.coefs[j] === 0) {
                            continue;
                        }

                        var coef = this.coefs[i] * value.coefs[j];

                        if (coefs[i + j] === undefined) {
                            coefs[i + j] = coef;
                        } else {
                            coefs[i + j] += coef;
                        }
                    }
                }

                // Fill in any missing values of coefs with 0s
                for (var i = 0; i < coefs.length; i++) {
                    if (coefs[i] === undefined) {
                        coefs[i] = 0;
                    }
                }

                return new KhanUtil.Polynomial(Math.min(this.minDegree, value.minDegree), coefs.length - 1, coefs, this.variable);
            }
        };

        // Scale or shift a polynomial
        // Example: f(x) = Ax^2 + Bx + C ==>
        //          f(mx + b) = A(mx + b)^2 + B(mx + b) + C
        this.scale = function(m, b) {

            // v = mx + b
            var v = new KhanUtil.Polynomial(0, 1, [b, m]);

            var n = this.getNumberOfTerms();

            // nothing to scale of the polynomial is y = 0
            if (n === 0) {
                return this;
            }

            // expand each substituted term of the polynomial
            var self = this;
            var termPolys = _.map(_.range(0, n), function(i) {
                var term = self.getCoefAndDegreeForTerm(i);

                // start with the coefficient in front of the term
                var termPoly = new KhanUtil.Polynomial(0, 0, [term.coef]);

                // expand the substituted term
                // ex: A(mx + b)^3 = A(mx + b)(mx + b)(mx + b)
                _.times(term.degree, function(j) {
                    termPoly = termPoly.multiply(v);
                });
                return termPoly;
            });

            // add all of the substituted terms
            var scaledPoly = _.reduce(termPolys, function(memo, curr) {
                return memo.add(curr);
            });

            return scaledPoly;
        };

        return this;
    },

    CompositePolynomial: function(minDegree, maxDegree, coefs, variable, name,
            composed, composedCoef) {
        var base = new KhanUtil.Polynomial(
            minDegree, maxDegree, coefs, variable, name);

        $.extend(this, base);

        if (!composedCoef) {
            composedCoef = KhanUtil.randRangeNonZero(-5, 5);
        }
        var composedFunc = composed.name + "(" + this.variable + ")";

        var tackOn = function(expr, tack) {
            expr = $.merge([], expr);

            if (expr[0] === "+") {
                expr.push(tack);
            } else {
                expr = ["+", expr, tack];
            }

            return expr;
        };

        this.expr = function(vari) {
            return tackOn(base.expr(vari), ["*", composedCoef, composedFunc]);
        };

        this.text = function() {
            return KhanUtil.expr(this.expr(this.variable));
        };

        this.toString = this.text;

        this.hintEvalOf = function(val, evalInner) {
            if (evalInner) {

                return KhanUtil.expr(tackOn(base.expr(val),
                    ["*", composedCoef, composed.evalOf(val)]));

            } else {

                return KhanUtil.expr(tackOn(base.expr(val),
                    ["*", composedCoef, composed.name + "(" + val + ")"]));

            }
        };

        this.evalOf = function(val) {
            return base.evalOf(val) + composedCoef * composed.evalOf(val);
        };

        this.hint = function(val) {
            var hints = [];
            hints.push("<p><code>" + this.name + "(" + val + ") = " +
                this.hintEvalOf(val) + "</code></p>");

            var composedFuncWithVal = composed.name + "(" + val + ")";

            hints.push(
                $._("<p>To solve for the value of <code>%(name)s</code>, we " +
                "need to solve for the value of " +
                "<code>%(composedFuncWithVal)s</code>.</p>",
                {name: this.name, composedFuncWithVal: composedFuncWithVal}));

            hints = hints.concat(composed.hint(val));

            hints.push($._("<p>That means <code>%(name)s(%(val)s) = " +
                "%(hintEvalOf)s</code></p>",
                {name: this.name, val: val,
                    hintEvalOf: this.hintEvalOf(val, true)}));

            hints.push("<p><code>" + this.name + "(" + val + ") = " +
                this.evalOf(val) + "</code></p>");

            return hints;

        };

        return this;

    },

    randCoefs: function randCoefs(minDegree, maxDegree) {
        var coefs = [];
        var allZero = true;

        for (var i = maxDegree; i >= minDegree; i--) {
            coefs[i] = KhanUtil.randRange(-7, 7);
            allZero = allZero && coefs[i] === 0;
        }

        return allZero ? randCoefs(minDegree, maxDegree) : coefs;
    },

    findRootsNumerically: function(fn, range, step) {
        step = step || 0.05;
        var x = range[0];
        var positive = fn(x) > 0;
        var roots = [];
        while (x < range[1]) {
            x += step;
            if ((fn(x) > 0) !== positive) {
                roots.push(KhanUtil.roundToNearest(step, x - step));
                positive = !positive;
            }
        }
        return roots;
    }
});

});

define('utils/probability.js',['require'],function(require) {

$.extend(KhanUtil, {
    /* coinFlips(2) returns
     * [["HH", 2], ["HT", 1], ["TH", 1], ["TT", 0]] */
    coinFlips: function(n) {
        if (n === 0) {
            return [["", 0]];
        } else {
            var preceding = KhanUtil.coinFlips(n - 1);

            var andAHead = $.map(preceding, function(_arg, i) {
                var seq = _arg[0];
                var h = _arg[1];
                // I18N: Represents "heads" on a coin
                return [[$._("H") + seq, h + 1]];
            });

            var andATail = $.map(preceding, function(_arg, i) {
                var seq = _arg[0];
                var h = _arg[1];
                // I18N: Represents "tails" on a coin
                return [[$._("T") + seq, h]];
            });

            return andAHead.concat(andATail);
        }
    },

    /* returns binomial coefficient (n choose k) or
     * sum of choose(n, i) for i in k:
     * choose(4, [0, 1, 2]) = 1 + 4 + 6 = 11 */
    choose: function(n, k) {
        if (typeof k === "number") {
            if (k * 2 > n) {
                return KhanUtil.choose(n, n - k);
            } else if (k > 0.5) {
                return KhanUtil.choose(n, k - 1) * (n - k + 1) / (k);
            } else if (Math.abs(k) <= 0.5) {
                return 1;
            } else {
                return 0;
            }
        } else {
            var sum = 0;
            $.each(k, function(ind, elem) {
                sum += KhanUtil.choose(n, elem);
            });
            return sum;
        }
    }
});

});

define('utils/qhints.js',['require'],function(require) {

$.fn["qhintsLoad"] = function() {

    var checkAnswer = function(parent, source) {
        var feedback = parent.find(".qhint-feedback");

        // if answer already revealed in the feedback, don't do anything
        if (feedback.length) {
            return;
        }

        // make a new feedback element
        feedback = $("<p>", { "class": "qhint-feedback" });
        var answer = $(parent.find(".qhint-answer")).text();
        var input = parent.find(".qhint-input");
        var userInput = "";

        if (source) {
            var type = source.attr("type");
            if (type === "text" || type === "submit") {
                userInput = $(parent.find("input:text")).val();
            } else if (type === "button") {
                userInput = source.val();
            } else if (source.is("a")) {
                userInput = source.text();
            }
        }

        // hide input element and instead show the feedback element
        input.hide();

        if (!source) {
            feedback.text(answer);
        } else if (userInput === answer) {
            feedback.text($._("Correct! The answer is %(answer)s.",
                {answer: answer})).addClass("correct");
        } else {
            feedback.text($._("Incorrect. The answer is %(answer)s.",
                {answer: answer})).addClass("incorrect");
        }

        parent.append(feedback);
    };

    var handleCheck = function(e) {
        var parent = $(e.currentTarget).parents(".qhint");
        checkAnswer(parent, $(e.currentTarget));
    };

    var selectors =
        ".qhint input:submit, .qhint input:button, .qhint a.qhint-button";
    $("body").on("click", selectors, handleCheck);

    // check hint when user presses enter
    $("body").on("keydown", ".qhint input:text", function(e) {
        // enter is pressed
        if (e.keyCode === 13) {
            handleCheck(e);
        }
    });

    $(Khan).on("hintUsed", function() {
        var lastQhElem = $(".qhint").last();
        if (lastQhElem.length) {
            checkAnswer(lastQhElem, null);
        }
    });
};

});

define('utils/rational-expressions.js',['require'],function(require) {

$.extend(KhanUtil, {

    getPermutations: function(arr) {
        var permArr = [];
        var usedChars = [];

        function permute(input) {
            for (var i = 0; i < input.length; i++) {
                var term = input.splice(i, 1)[0];
                usedChars.push(term);
                if (input.length === 0) {
                    permArr.push(usedChars.slice());
                }
                permute(input);
                input.splice(i, 0, term);
                usedChars.pop();
            }
            return permArr;
        }

        return permute(arr);
    },

    writeExpressionFraction: function(numerator, denominator) {
        if (denominator.toString() === '1') {
            return numerator.toString();
        }
        if (denominator.toString() === '-1') {
            return numerator.multiply(-1).toString();
        }
        if (numerator.isNegative()) {
            return "-\\dfrac{" + numerator.multiply(-1).toString() + "}{" + denominator.toString() + "}";
        }
        if (denominator.isNegative()) {
            return "-\\dfrac{" + numerator.toString() + "}{" + denominator.multiply(-1).toString() + "}";
        }
        return "\\dfrac{" + numerator.toString() + "}{" + denominator.toString() + "}";
    },

    /*
    Term in an expression
    Takes an array. The first value is the coefficient
    and subsequent values are variables and their degree
    e.g. Term(5) = 5
         Term(5, 'x') = 5x
         Term(5, 'xy') = 5xy
         Term(5, {'x': 1}) = 5x
         Term(5, {'x': 2}) = 5x^2
         Term(5, {'x': 1, 'y': 2}) = 5xy^2
    */
    Term: function(coefficient, variables, degree) {
        this.coefficient = coefficient;
        this.variables = {};

        if (degree === undefined) {
            degree = 1;
        }

        if (typeof variables === 'string') {
            for (var i = 0; i < variables.length; i++) {
                this.variables[variables.charAt(i)] = degree;
            }
        } else if (variables !== undefined){
            this.variables = variables;
        }

        // Create a string representing the term
        // e.g. 5yx^2 = 5y1x2
        // Used for hashing
        this.variableString = '';
        for (var vari in this.variables) {
            if (this.variables[vari] !== 0) {
                this.variableString += vari + this.variables[vari];
            } else {
                delete this.variables[vari];
            }
        }

        this.isNegative = function() {
            return this.coefficient < 0;
        };

        // Return a RationalExpression object representing the sum of this term with the passed object
        this.add = function(expression) {
            // Copy self so don't mutate original term
            var copy = [this.coefficient, this.variables];

            if (expression instanceof KhanUtil.RationalExpression) {
                return expression.add(this);
            } else if (expression instanceof KhanUtil.Term) {
                return new KhanUtil.RationalExpression([copy, [expression.coefficient, expression.variables]]);
            } else {
                return new KhanUtil.RationalExpression([copy, expression]);
            }
        };


        this.isOne = function() {
            return this.toString() === '1';
        };

        // Given a mapping of variable to value, {'x' : 2}, evaulate the term
        // Or give a number and all variables will be given that value
        // TODO: Make this work for multi-variable terms
        // when only the value of one variable is given
        this.evaluate = function(values) {
            var value = this.coefficient;

            if (typeof values === 'number') {
                _.each(this.variables, function(v) {
                    value *= Math.pow(values, v);
                });
            } else {
                _.each(this.variables, function(v, i) {
                    value *= Math.pow(values[i], v);
                });
            }
            return value;
        };

        // Return a new term representing this term multiplied by another term or a number
        this.multiply = function(term) {
            if (term instanceof KhanUtil.RationalExpression) {
                return term.multiply(this);
            }

            var coefficient = this.coefficient;
            var variables = _.clone(this.variables);

            if (typeof term === 'number') {
                coefficient *= term;
            } else {
                coefficient *= term.coefficient;
                for (var i in term.variables) {
                    if (variables[i] != null) {
                        variables[i] += term.variables[i];
                    } else {
                        variables[i] = term.variables[i];
                    }
                }
            }

            return new KhanUtil.Term(coefficient, variables);
        };

        // Return a new term representing this term divided by another term or a number
        this.divide = function(term) {
            var coefficient = this.coefficient;
            var variables = _.clone(this.variables);

            if (typeof term === 'number') {
                coefficient /= term;
            } else {
                coefficient /= term.coefficient;
                for (var i in term.variables) {
                    if (variables[i]) {
                        variables[i] -= term.variables[i];
                    } else {
                        variables[i] = -term.variables[i];
                    }
                }
            }

            return new KhanUtil.Term(coefficient, variables);
        };

        // Return a Term object representing the greatest common factor between this term and another
        this.getGCD = function(expression) {
            if (expression instanceof KhanUtil.RationalExpression) {
                return expression.getGCD(this);
            }

            if (typeof expression === 'number') {
                return KhanUtil.getGCD(this.coefficient, expression);
            }

            var coefficient = KhanUtil.getGCD(this.coefficient, expression.coefficient);
            var variables = {};

            for (var i in this.variables) {
                if (expression.variables[i]) {
                    variables[i] = Math.min(this.variables[i], expression.variables[i]);
                }
            }

            return new KhanUtil.Term(coefficient, variables);
        };

        // includeSign if term is not the first in an expression
        this.toString = function(includeSign) {
            if (this.coefficient === 0) {
                return '';
            }

            var s = '';

            if (includeSign) {
                s += this.coefficient >= 0 ? ' + ' : ' - ';
            } else if (this.coefficient < 0) {
                s += '-';
            }

            var coefficient = Math.abs(this.coefficient);
            if (!(coefficient === 1 && this.variableString !== "")) {
                s += coefficient;
            }

            _.each(this.variables, function(degree, i) {
                if (degree === 0) {
                    return; // continue
                }
                s += i;
                if (degree !== 1) {
                    s += '^' + degree;
                }
            });
            return s;
        };

        // Just so Terms can be treated like RationalExpressions
        this.toStringFactored = function() {
            return this.toString();
        };

        // Return a string showing how the term should be evaluated with a given value
        // e.g. 5x^2 evalated with 3 returns 5(3)^2
        // If color is defined, the value representing the variable is colored
        this.getEvaluateString = function(values, includeSign, color) {
            var s = '';

            if (includeSign) {
                s += this.coefficient >= 0 ? ' + ' : ' - ';
            } else if (this.coefficient < 0) {
                s += '-';
            }

            var coefficient = Math.abs(this.coefficient);
            if (!(coefficient === 1 && this.variableString !== '')) {
                s += coefficient;
                if (this.variableString !== '') {
                    s += '\\cdot';
                }
            }

            _.each(this.variables, function(degree, i) {
                var value = (typeof values === 'number') ? values : values[i];
                if (color !== undefined) {
                    value = '\\' + color + '{' + value + '}';
                }

                s += (value < 0 || degree === 1) ? value : '(' + value + ')^' + degree;
            });

            return s;
        };

        // Return a regex that will capture this term
        // If includeSign is true, then 4x is captured by +4x
        this.regex = function() {
            return '^' + this.regexForExpression() + '$';
        };

        // Return a regex that will capture this term
        // If includeSign is true, then 4x is captured by +4x
        this.regexForExpression = function(includeSign) {
            if (this.coefficient === 0) {
                return '';
            }

            var regex;

            // Include leading space if there are earlier terms
            if (this.coefficient < 0){
                regex = includeSign ? '[-\\u2212]\\s*' : '\\s*[-\\u2212]\\s*';
            } else {
                regex = includeSign ? '\\+\\s*' : '\\s*';
            }

            if (!(Math.abs(this.coefficient) === 1 && this.variableString !== '')) {
                regex += Math.abs(this.coefficient);
            }

            // Add all permutations of variables
            var variable_array = [];
            for (var vari in this.variables) {
                if (degree !== 0) {
                    variable_array.push([vari, this.variables[vari]]);
                }
            }

            if (variable_array.length > 1) {
                var permutations = KhanUtil.getPermutations(variable_array);

                regex += "(?:";
                for (var p=0; p<permutations.length; p++) {
                    var variables = permutations[p];

                    regex += "(?:";
                    for (var i=0; i<variables.length; i++) {
                        var vari = variables[i][0];
                        var degree = variables[i][1];
                        regex += degree > 1 ? vari + "\\s*\\^\\s*" + degree : vari;
                    }
                    regex += p < permutations.length - 1 ? ")|" : ")";
                }
                regex += ")";

            } else if (variable_array.length === 1) {
                var vari = variable_array[0][0];
                var degree = variable_array[0][1];
                regex += degree > 1 ? vari + "\\s*\\^\\s*" + degree : vari;
            }

            return regex + '\\s*';
        };

    },

    /*
        A flat (i.e. no parentheses), multi-variable polynomial expression
        Represented as an array of terms that are added together
        Terms can be numbers or an array representing [coefficient, variable]
        e.g. [5, [1, 'x']] = 5 + x
        e.g. [5, [2, {'x': 2}] = 5 + 2x^2
        e.g. [5, [2, {'x': 2, 'y': 1}]] = 5 + 2x^2y
    */
    RationalExpression: function(terms) {
        this.terms = [];

        for (var i = 0; i < terms.length; i++) {
            var term = terms[i];
            var newTerm;
            if (typeof term === 'number') {
                newTerm = new KhanUtil.Term(term);
            } else if (term instanceof KhanUtil.Term) {
                newTerm = new KhanUtil.Term(term.coefficient, term.variables);
            } else {
                newTerm = new KhanUtil.Term(term[0], term[1]);
            }
            if (newTerm.coefficient !== 0) {
                this.terms.push(newTerm);
            }
        }

        // Given a term, e.g. x1, return the coefficient of that term
        this.getCoefficient = function(variable) {
            var coefficient = 0;
            for (var i = 0; i < this.terms.length; i++) {
                if (this.terms[i].variableString === variable) {
                    coefficient += this.terms[i].coefficient;
                }
            }
            return coefficient;
        };

        // Combine any terms that have the same variable and remove any with a coefficient of 0
        this.combineLikeTerms = function() {
            var variables = {};

            for (var i = 0; i < this.terms.length; i++) {
                var term = this.terms[i];
                var s = term.variableString;

                if (variables[s]) {
                    variables[s].coefficient += term.coefficient;
                } else {
                    variables[s] = term;
                }
            }

            this.terms = [];
            for (var v in variables) {
                if (variables[v].coefficient !== 0) {
                    this.terms.push(variables[v]);
                }
            }
        };
        this.combineLikeTerms();

        // Test whether this expressions is equal to the one passed in
        // Assumes the like terms in both expressions have been combined
        this.isEqualTo = function(that) {
            var n1 = this.terms.length;
            var n2 = that.terms.length;

            if (n1 !== n2) {
                return false;
            }

            for (var i=0; i<n1; i++) {
                var t1 = this.terms[i];
                var found = false;

                for (var j=0; j<n2; j++) {
                    var t2 = that.terms[j];
                    if (t1.coefficient === t2.coefficient && t1.variableString === t2.variableString) {
                        found = true;
                        break;
                    }
                }
                if (!found) {
                    return false;
                }
            }

            return true;
        };

        this.isNegative = function() {
            return this.terms[0].coefficient < 0;
        };

        // Return the coefficient of term contain variable to the degree power
        // e.g. for 5x^2 + x + 2, getCoefficentOfTerm('x', 2) will return 5
        // getCoefficentOfTerm('x',) will return 1
        // getCoefficentOfTerm() will return 2
        this.getCoefficentOfTerm = function(variable, degree) {
            var variableString = "";

            if (variable === '') {
                variableString = '';
            } else if (variable !== undefined && degree !== 0) {
                degree = degree || 1;
                variableString = variable + degree;
            }

            for (var i = 0; i < this.terms.length; i++) {
                if (this.terms[i].variableString === variableString) {
                    return this.terms[i].coefficient;
                }
            }

            return 0;
        };

        this.evaluate = function(values) {
            var value = 0;
            for (var i = 0; i < this.terms.length; i++) {
                value += this.terms[i].evaluate(values);
            }
            return value;
        };

        // Return a new expression which is the sum of this one and the one passed in
        this.add = function(expression) {
            var terms = [];

            // Copy own terms
            for (var i = 0; i < this.terms.length; i++) {
                var term = this.terms[i];
                terms.push([term.coefficient, term.variables]);
            }

            if (expression instanceof KhanUtil.Term) {
                // Add single term
                terms.push(new KhanUtil.Term(expression.coefficient, expression.variables));
            } else if (typeof expression === 'number') {
                // Add single digit
                terms.push(new KhanUtil.Term(expression));
            } else {
                // Add all terms from another expression
                for (var i = 0; i < expression.terms.length; i++) {
                    var term = expression.terms[i];
                    terms.push([term.coefficient, term.variables]);
                }
            }

            var result = new KhanUtil.RationalExpression(terms);
            result.combineLikeTerms();

            return result;
        };

        // Return a new expression representing the product of this one and the one passed in
        this.multiply = function(expression) {
            var multiplyTerms;
            if (expression instanceof KhanUtil.RationalExpression) {
                multiplyTerms = expression.terms;
            } else if (typeof expression === 'number' || expression instanceof KhanUtil.Term) {
                multiplyTerms = [expression];
            } else {
                // Assume it's a variable name
                multiplyTerms = [new KhanUtil.Term(1, expression)];
            }

            var terms = [];

            for (var i = 0; i < multiplyTerms.length; i++) {
                var value = multiplyTerms[i];

                for (var j = 0; j < this.terms.length; j++) {
                    terms.push(this.terms[j].multiply(value));
                }
            }

            return new KhanUtil.RationalExpression(terms);
        };

        // Return a new expression representing this one divided by another expression
        // Assumes this expression can be factored to remove the one passed in
        this.divide = function(expression) {
            if (expression instanceof KhanUtil.RationalExpression) {
                if (expression.terms.length === 1) {
                    return this.divide(expression.terms[0]);
                }

                var factors1 = this.factor();
                var factors2 = expression.factor();

                if (factors1[1].isEqualTo(factors2[1])) {
                    var value = factors1[0].divide(factors2[0]);
                    return new KhanUtil.RationalExpression([value]);
                } else if (factors1[1].isEqualTo(factors2[1].multiply(-1))) {
                    var value = factors1[0].divide(factors2[0]).multiply(-1);
                    return new KhanUtil.RationalExpression([value]);
                } else {
                    // Cannot divide by this expression
                    // Can be used to check whether expression have a common factor
                    return false;
                }

            } else {
                var terms = [];

                for (var i = 0; i < this.terms.length; i++) {
                    terms.push(this.terms[i].divide(expression));
                }

                return new KhanUtil.RationalExpression(terms);
            }
        };

        // Return a Term object representing the greatest common factor between this expression and another
        this.getGCD = function(that) {
            var t1 = this.getTermsGCD();
            var GCD;

            if (that instanceof KhanUtil.Term) {
                GCD = t1.getGCD(that);
            } else if (that instanceof KhanUtil.RationalExpression) {
                GCD = t1.getGCD(that.getTermsGCD());
            } else {
                return KhanUtil.getGCD(that, t1.coefficient);
            }

            if (GCD.coefficient < 0) {
                GCD.coefficient *= -1;
            }
            return GCD;
        };

        // Return a Term object representing the greatest common divisor of all the terms in this expression
        this.getTermsGCD = function() {
            var GCD = this.terms[0];

            for (var i=0; i<this.terms.length; i++) {
                GCD = GCD.getGCD(this.terms[i]);
            }

            if (this.isNegative()) {
                GCD = GCD.multiply(-1);
            }

            return GCD;
        };

        // Factor out the GCD of all terms and return [GCD, remaining expression]
        // e.g. 6x + 4x^2 => [2x, 3 + 2x]
        this.factor = function() {
            var gcd = this.getTermsGCD();
            var factor = this.divide(gcd);
            return [gcd, factor];
        };

        this.toString = function() {
            if (this.terms.length === 0) {
                return '0';
            }

            var s = this.terms[0].toString();
            for (var i = 1; i < this.terms.length; i++) {
                s += this.terms[i].toString(s !== '');
            }

            return s !== '' ? s : '0';
        };

        // Return a string of the factored expression
        this.toStringFactored = function(parenthesise) {
            var factors = this.factor();

            if (this.terms.length === 1 || factors[0].isOne()) {
                if (parenthesise) {
                   return "(" + this.toString() + ")";
                } else {
                    return this.toString();
                }
            }

            var s = (factors[0].toString() === '-1') ? '-' : factors[0].toString();
            s += "(" + factors[1].toString() + ")";

            return s;
        };

        // Returns a string showing the expression with variable substituted.
        this.getEvaluateString = function(values, color) {
            var s = this.terms[0].getEvaluateString(values, false, color);

            for (var i = 1; i < this.terms.length; i++) {
                s += this.terms[i].getEvaluateString(values, true, color);
            }

            return s !== "" ? s : '0';
        };

        // Returns a regex that captures all permutation passed in
        this.getTermsRegex = function(permutations, start, stop) {
            var regex = "";

            start = start ?  "|(?:^" + start : "|(?:^";
            stop = stop ?  stop + "$)" : "$)";

            for (var p = 0; p < permutations.length; p++) {
                regex += start;

                var terms = permutations[p];
                for (var i = 0; i < terms.length; i++) {
                    regex += terms[i].regexForExpression(i);
                }

                regex += stop;
            }
            return regex;
        };

        // Returns a single regex to capture this expression.
        // It will capture every permutations of terms so is
        // not recommended for expressions with more than 3 terms
        // If allowFactors is true, 3(x + 4) will match 3x + 12
        this.regex = function(allowFactors) {
            var permutations = KhanUtil.getPermutations(this.terms);
            var regex = this.getTermsRegex(permutations).slice(1);

            if (!allowFactors || this.terms.length === 1) {
                return regex;
            }

            // Generate regex factored expression
            // If GCD is 1, will accept parenthesised expression
            // e.g. p - 5 will accept (p - 5)
            var factors = this.factor();
            permutations = KhanUtil.getPermutations(factors[1].terms);

            if (factors[0].isOne()) {
                regex += this.getTermsRegex(permutations, "\\s*\\(", "\\)\\s*");
            } else if (factors[0].toString() === '-1') {
                regex += this.getTermsRegex(permutations, "\\s*[-\\u2212]\\s*\\(", "\\)\\s*");
            } else {
                regex += this.getTermsRegex(permutations, factors[0].regexForExpression() + "\\*?\\s*\\(", "\\)\\s*");
            }

            // Factor out a negative
            factors[0] = factors[0].multiply(-1);
            factors[1] = factors[1].multiply(-1);
            permutations = KhanUtil.getPermutations(factors[1].terms);

            if (factors[0].isOne()) {
                regex += this.getTermsRegex(permutations, "\\s*\\(", "\\)\\s*");
            } else if (factors[0].toString === '-1') {
                regex += this.getTermsRegex(permutations, "\\s*[-\\u2212]\\s*\\(", "\\)\\s*");
            } else {
                regex += this.getTermsRegex(permutations, factors[0].regexForExpression() + "\\*?\\s*\\(", "\\)\\s*");
            }

            return regex;
        };
    }

});

});

define('utils/slice-clone.js',['require'],function(require) {

// Helper for fractions_cut_and_copy_1 and fractions_cut_and_copy_2
$.extend(KhanUtil, {
    initSliceClone: function(goalBlocks) {
        KhanUtil.pieces = 1;
        KhanUtil.times = {};
        for (var i = 0; i < goalBlocks.length; i++) {
            KhanUtil.times[goalBlocks[i]] = 1;
        }
    },

    // Change the number of pieces the starting block
    // is sliced into.
    changePieces: function(increase) {
        if (KhanUtil.pieces === 1 && !increase) {
            return;
        }

        KhanUtil.pieces += (increase) ? 1 : -1;

        $("#pieces").text(KhanUtil.plural(KhanUtil.pieces, "piece"));

        KhanUtil.currentGraph = $("#problemarea").find("#parent_block").data("graphie");
        rectchart([1, KhanUtil.pieces - 1], ["#e00", "#999"]);

        KhanUtil.updateGraphAndAnswer();
    },

    // Change the number of times the slice is copied.
    changeTimes: function(increase, id) {
        if (KhanUtil.times[id] === 1 && !increase) {
            return;
        }

        KhanUtil.times[id] += (increase) ? 1 : -1;

        $("#" + id + "_times").text(KhanUtil.plural(KhanUtil.times[id], "time"));

        KhanUtil.updateGraphAndAnswer();
    },

    updateGraphAndAnswer: function() {
        var pieces = KhanUtil.pieces;
        _.each(KhanUtil.times, function(times, id) {
            KhanUtil.currentGraph = $("#problemarea").find("#" + id).data("graphie");
            KhanUtil.currentGraph.raphael.clear();
            KhanUtil.currentGraph.init({ range: [[0, 1], [0, 1]], scale: [500 / pieces * times, 25] });
            rectchart([times, 0], ["#e00", "#999"]);
            $("#" + id + "_answer input").val(KhanUtil.roundTo(3, times / pieces));
        });
    }
});

});

define('utils/spin.js',['require'],function(require) {

$.extend(KhanUtil, {
    spin: function(content) {
        // First find all top-level blocks and spin them
        var startingBracePos = -1;
        var nestingLevel = 0;

        for (var i = 0; i < content.length; i++) {
            if (content.charAt(i) === "{") {

                // We encounter our first "{"
                if (startingBracePos === -1) {
                    startingBracePos = i;

                // We are already inside a top-level block, this starts a nested block
                } else {
                    nestingLevel++;
                }

            // We encounter a "}" and have seen a "{" before
            } else if (content.charAt(i) === "}" && startingBracePos !== -1) {

                // This is the closing brace for a top-level block
                if (nestingLevel === 0) {
                    // Spin the top-level block
                    var spun = KhanUtil.spin(content.substring(startingBracePos + 1, i));
                    content = content.substring(0, startingBracePos) + spun + content.substring(i + 1);
                    i -= (i - startingBracePos) - spun.length + 1;
                    startingBracePos = -1;

                // This brace closes a nested block
                } else {
                    nestingLevel--;
                }
            }
        }

        return KhanUtil.randFromArray(content.split("|"));
    }
});


$.fn.spin = function() {
    this.find(".spin").each(function() {
        var spun = KhanUtil.spin($(this).html());
        $(this).html(spun);
    });
};

});

define('utils/subhints.js',['require'],function(require) {

var getSubHints = function(id, title, subHints) {
    var str = "[<a href='#' class='show-subhint' data-subhint='" + id + "'>" + title + "</a>]</p>";
    str += "<div class='subhint' id='" + id + "'>";
    for (var iHint = 0; iHint < subHints.length; iHint++) {
        str += "<p>" + subHints[iHint] + "</p>";
    }
    str += "</div>";
    return str;
};

$(document).on("click", "a.show-subhint", function(event) {
    var subhint = $("#" + $(this).data("subhint"));
    var visibleText = $(this).data("visible-text") || $(this).text();
    var hiddenText = $(this).data("hidden-text") || "Hide explanation";
    $(this).data({ "visible-text": visibleText, "hidden-text": hiddenText });

    if (subhint.is(":visible")) {
        $(this).text(visibleText);
    } else {
        // write to KALOG capturing the subhint-expand
        // click
        $(Exercises).trigger("subhintExpand", [$(this).data("subhint")]);
        $(this).text(hiddenText);
    }

    var $el = $("#" + $(this).data("subhint"));
    $el.toggle(200, function() {
        // TODO(alpert): This flashes when the subhint is revealed.
        // Flashing is better than the alternative, though:
        // https://uploads.hipchat.com/6574/33523/6qxvb1j5sh88vjv/upload.png
        $el.find("code").each(function(i, code) {
            KhanUtil.processMath(code, null, true);
        });
    });

    return false;
});

$(document).on("mouseenter mouseleave", "a.show-definition", function(event) {
    $("#" + $(this).data("definition")).toggle(200);
    return false;
});

$.extend(KhanUtil, {
    getSubHints: getSubHints
});

});

define('utils/time.js',['require'],function(require) {

$.extend(KhanUtil, {
    addAnalogClock: function(options) {
        var analogClock = $.extend(true, {
            graph: KhanUtil.currentGraph,
            set: KhanUtil.currentGraph.raphael.set(),
            hands: KhanUtil.currentGraph.raphael.set(),
            center: [0, 0],
            radius: 3.5,
            showLabels: true,
            hour: null,
            minute: null
        }, options);

        analogClock.drawLabels = function() {
            var self = this;
            _(12).times(function(n) {
                n += 1;
                var coord = self.graph.scalePoint([
                        self.center[0] + 0.78 * self.radius * Math.sin(2 * Math.PI * n / 12),
                        self.center[1] + 0.78 * self.radius * Math.cos(2 * Math.PI * n / 12)]);
                // Use raphael text rather than mathjax labels so the hands can
                // be drawn on top. Also, the sans-serif font better fits the
                // stylish look of this sleek, modern clock.
                var lbl = self.graph.raphael.text(coord[0], coord[1], n);
                lbl.attr({
                    color: KhanUtil.GRAY,
                    fill: KhanUtil.GRAY,
                    "font-size": 14
                });
                self.set.push(lbl);
            });
            self.hands.toFront();
        };

        analogClock.drawHands = function() {
            var self = this;
            self.graph.style({
                fill: "#333",
                stroke: "none"
            }, function() {
                var hourHand = self.graph.path([
                        [self.center[0] - 0.15 * self.radius, self.center[1] + 0.035 * self.radius],
                        [self.center[0] + 0.45 * self.radius, self.center[1] + 0.020 * self.radius],
                        [self.center[0] + 0.45 * self.radius, self.center[1] - 0.020 * self.radius],
                        [self.center[0] - 0.15 * self.radius, self.center[1] - 0.035 * self.radius],
                        true]);
                hourHand.rotate(-KhanUtil.timeToDegrees((self.hour + self.minute/60) * 5),
                        self.graph.scalePoint(self.center)[0], self.graph.scalePoint(self.center)[1]);
                self.hands.push(hourHand);

                var minuteHand = self.graph.path([
                        [self.center[0] - 0.15 * self.radius, self.center[0] + 0.035 * self.radius],
                        [self.center[0] + 0.85 * self.radius, self.center[0] + 0.017 * self.radius],
                        [self.center[0] + 0.85 * self.radius, self.center[0] - 0.017 * self.radius],
                        [self.center[0] - 0.15 * self.radius, self.center[0] - 0.035 * self.radius],
                        true]);
                minuteHand.rotate(-KhanUtil.timeToDegrees(self.minute),
                        self.graph.scalePoint(self.center)[0], self.graph.scalePoint(self.center)[1]);
                self.hands.push(minuteHand);
            });
            self.set.push(self.hands);
        };

        analogClock.draw = function() {
            var self = this;
            self.graph.style({
                stroke: KhanUtil.GRAY,
                fill: "#fff",
                strokeWidth: 5
            }, function() {
                self.set.push(self.graph.circle(self.center, self.radius));
            });
            self.graph.style({
                stroke: KhanUtil.GRAY,
                strokeWidth: 4
            }, function() {
                _(12).times(function(n) {
                    var tick = self.graph.line(
                            [self.center[0] + self.radius - 4 / self.graph.scale[0], self.center[1]],
                            [self.center[0] + self.radius - 8 / self.graph.scale[0], self.center[1]]);
                    tick.rotate(n * 30, self.graph.scalePoint(self.center)[0], self.graph.scalePoint(self.center)[1]);
                    self.set.push(tick);
                });
            });
            self.graph.style({
                stroke: KhanUtil.GRAY,
                strokeWidth: 1
            }, function() {
                _(60).times(function(n) {
                    var tick = self.graph.line(
                            [self.center[0] + self.radius - 4 / self.graph.scale[0], self.center[1]],
                            [self.center[0] + self.radius - 8 / self.graph.scale[0], self.center[1]]);
                    tick.rotate(n * 6, self.graph.scalePoint(self.center)[0], self.graph.scalePoint(self.center)[1]);
                    self.set.push(tick);
                });
            });
            if (self.showLabels) {
                self.drawLabels();
            }
            if (self.hour != null && self.minute != null) {
                self.drawHands();
            }
            return self.set;
        };

        return analogClock;
    },

    addInteractiveAnalogClock: function(options) {
        options = $.extend(true, {
            minuteSnapPoints: 12,
            minuteIncrement: 5,
            minuteStartAngle: 90,
            hourStartAngle: 60
        }, options);

        var interactiveAnalogClock = KhanUtil.addAnalogClock(options);
        var graph = interactiveAnalogClock.graph;

        var hourSnapPoints = 12 * 60 / interactiveAnalogClock.minuteIncrement;
        var outerPointRadius = interactiveAnalogClock.radius * 1.10;
        interactiveAnalogClock.minuteRadius = interactiveAnalogClock.radius * 0.65;
        interactiveAnalogClock.hourRadius = interactiveAnalogClock.radius * 0.45;

        var minuteSnapDegrees = 360 / interactiveAnalogClock.minuteSnapPoints;
        var hourSnapDegrees = 360 / hourSnapPoints;

        interactiveAnalogClock.draw();
        graph.addMouseLayer();

        var redStyle = { fill: KhanUtil.RED, stroke: KhanUtil.RED };
        var blueStyle = { fill: KhanUtil.BLUE, stroke: KhanUtil.BLUE };

        var movePartnerPoint = function (options) {
            var x = options.x;
            var y = options.y;
            var point = options.point;
            var outerPoint = options.outerPoint;
            var isOuterPoint = options.isOuterPoint;

            var ratio = outerPoint.constraints.fixedDistance.dist / point.constraints.fixedDistance.dist;

            if (isOuterPoint) {
                ratio = 1 / ratio;
                point.setCoord([x * ratio , y * ratio]);
                outerPoint.setCoord([x, y]);
            } else {
                point.setCoord([x, y]);
                outerPoint.setCoord([x * ratio, y * ratio]);
            }

            point.updateLineEnds();
            return true;
        };

        interactiveAnalogClock.minutePoint = graph.addMovablePoint({
            graph: graph,
            coord: graph.polar(interactiveAnalogClock.minuteRadius, interactiveAnalogClock.minuteStartAngle),
            constraints: {
                fixedDistance: {
                    dist: interactiveAnalogClock.minuteRadius,
                    point: [0, 0],
                    snapPoints: 12
                }
            },
            onMove: function(x, y) {
                return movePartnerPoint({
                    x: x,
                    y: y,
                    point: this,
                    outerPoint: interactiveAnalogClock.outerMinutePoint,
                    isOuterPoint: false
                });
            },
            normalStyle: redStyle,
            highlightStyle: redStyle
        });

        interactiveAnalogClock.outerMinutePoint = graph.addMovablePoint({
            graph: graph,
            coord: graph.polar(outerPointRadius, interactiveAnalogClock.minuteStartAngle),
            constraints: {
                fixedDistance: {
                    dist: outerPointRadius,
                    point: [0, 0],
                    snapPoints: 12
                }
            },
            onMove: function(x, y) {
                return movePartnerPoint({
                    x: x,
                    y: y,
                    point: interactiveAnalogClock.minutePoint,
                    outerPoint: this,
                    isOuterPoint: true
                });
            },
            normalStyle: redStyle,
            highlightStyle: redStyle
        });

        interactiveAnalogClock.hourPoint = graph.addMovablePoint({
            graph: graph,
            coord: graph.polar(interactiveAnalogClock.hourRadius, interactiveAnalogClock.hourStartAngle),
            constraints: {
                fixedDistance: {
                    dist: interactiveAnalogClock.hourRadius,
                    point: [0, 0],
                    snapPoints: hourSnapPoints
                }
            },
            onMove: function(x, y) {
                return movePartnerPoint({
                    x: x,
                    y: y,
                    point: this,
                    outerPoint: interactiveAnalogClock.outerHourPoint,
                    isOuterPoint: false
                });
            },
            normalStyle: blueStyle,
            highlightStyle: blueStyle
        });

        interactiveAnalogClock.outerHourPoint = graph.addMovablePoint({
            graph: graph,
            coord: graph.polar(outerPointRadius, interactiveAnalogClock.hourStartAngle),
            constraints: {
                fixedDistance: {
                    dist: outerPointRadius,
                    point: [0, 0],
                    snapPoints: hourSnapPoints
                }
            },
            onMove: function(x, y) {
                return movePartnerPoint({
                    x: x,
                    y: y,
                    point: interactiveAnalogClock.hourPoint,
                    outerPoint: this,
                    isOuterPoint: true
                });
            },
            normalStyle: blueStyle,
            highlightStyle: blueStyle
        });

        interactiveAnalogClock.minuteHand = graph.addMovableLineSegment({
            graph: graph,
            pointA: interactiveAnalogClock.minutePoint,
            coordZ: [0, 0],
            fixed: true,
            normalStyle: {
                stroke: KhanUtil.RED,
                "stroke-width": 10
            }
        });

        interactiveAnalogClock.hourHand = graph.addMovableLineSegment({
            graph: graph,
            pointA: interactiveAnalogClock.hourPoint,
            coordZ: [0, 0],
            fixed: true,
            normalStyle: {
                stroke: KhanUtil.BLUE,
                "stroke-width": 10
            }
        });

        var centerPoint = graph.addMovablePoint({
            graph: graph,
            coord: [0, 0],
            constraints: {
                fixed: true
            },
            normalStyle: {
                fill: "#fff",
                stroke: "#000",
                "stroke-width": 2
            }
        });

        // Return the position of the minute and hour hands
        interactiveAnalogClock.getHandPositions = function() {
            return [interactiveAnalogClock.minutePoint.coord, interactiveAnalogClock.hourPoint.coord];
        };

        // Test whether the clock is set to correctMinute and correctHour
        interactiveAnalogClock.validate = function(guess, correctMinute, correctHour) {
            var minuteAngle = graph.cartToPolar(guess[0])[1];
            var hourAngle = graph.cartToPolar(guess[1])[1];

            minuteAngle = KhanUtil.roundToNearest(minuteSnapDegrees, minuteAngle);
            hourAngle = KhanUtil.roundToNearest(hourSnapDegrees, hourAngle);

            // If hands have not been moved, return `""`
            if (minuteAngle === interactiveAnalogClock.minuteStartAngle && hourAngle === interactiveAnalogClock.hourStartAngle) {
                return "";
            }

            var correctMinuteAngle = KhanUtil.timeToDegrees(correctMinute);
            var correctHourAngle = KhanUtil.timeToDegrees(5 * (correctHour + correctMinute / 60));
            correctMinuteAngle = KhanUtil.roundToNearest(minuteSnapDegrees, correctMinuteAngle);
            correctHourAngle = KhanUtil.roundToNearest(hourSnapDegrees, correctHourAngle);

            if ((minuteAngle !== correctMinuteAngle) || (hourAngle !== correctHourAngle)) {
                if ((minuteAngle === correctHourAngle) && (hourAngle === correctMinuteAngle)) {
                    return $._("Remember the hour hand is the short hand and the minute hand is the long hand");
                }
                else if ((minuteAngle === correctMinuteAngle) && (hourAngle !== correctHourAngle) &&
                         (hourAngle === KhanUtil.roundToNearest(hourSnapDegrees, KhanUtil.timeToDegrees(5 * correctHour)))) {
                    return $._("Remember the hour hand needs to move over the course of the hour");
                }
                return false;
            }
            return true;
        };

        // Show semi-transparent hands set at the correct time
        interactiveAnalogClock.showCorrectTime = function(correctMinute, correctHour) {
            var correctMinuteAngle = KhanUtil.timeToDegrees(correctMinute);
            var correctHourAngle = KhanUtil.timeToDegrees(5 * (correctHour + correctMinute / 60));
            correctMinuteAngle = KhanUtil.roundToNearest(minuteSnapDegrees, correctMinuteAngle);
            correctHourAngle = KhanUtil.roundToNearest(hourSnapDegrees, correctHourAngle);

            var minuteCoord = graph.polar(interactiveAnalogClock.minuteRadius, correctMinuteAngle);
            var hourCoord = graph.polar(interactiveAnalogClock.hourRadius, correctHourAngle);

            var dotOpacity = 0.4;
            var handOpacity = 0.3;

            interactiveAnalogClock.graph.addMovableLineSegment({
                coordA: minuteCoord,
                coordZ: [0, 0],
                fixed: true,
                normalStyle: {
                    stroke: KhanUtil.RED,
                    "stroke-width": 10,
                    "stroke-dasharray": ".",
                    "stroke-linecap": "round",
                    "stroke-opacity": dotOpacity
                }
            });

            interactiveAnalogClock.graph.addMovableLineSegment({
                coordA: minuteCoord,
                coordZ: [0, 0],
                fixed: true,
                normalStyle: {
                    stroke: KhanUtil.RED,
                    "stroke-width": 10,
                    "stroke-linecap": "round",
                    "stroke-opacity": handOpacity
                }
            });

            interactiveAnalogClock.graph.addMovableLineSegment({
                coordA: hourCoord,
                coordZ: [0, 0],
                fixed: true,
                normalStyle: {
                    stroke: KhanUtil.BLUE,
                    "stroke-width": 10,
                    "stroke-dasharray": ".",
                    "stroke-linecap": "round",
                    "stroke-opacity": dotOpacity
                }
            });

            interactiveAnalogClock.graph.addMovableLineSegment({
                coordA: hourCoord,
                coordZ: [0, 0],
                fixed: true,
                normalStyle: {
                    stroke: KhanUtil.BLUE,
                    "stroke-width": 10,
                    "stroke-linecap": "round",
                    "stroke-opacity": handOpacity
                }
            });

            // for some reason this doesn't work, so for now, create another center point
            // centerPoint.toFront();
            interactiveAnalogClock.graph.addMovablePoint({
                coord: [0, 0],
                constraints: {
                    fixed: true
                },
                normalStyle: {
                    fill: "#fff",
                    stroke: "#000",
                    "stroke-dasharray": "",
                    "stroke-width": 2,
                    "stroke-opacity": 1
                }
            });
        };

        return interactiveAnalogClock;
    },

    /* Map time in minutes to angle in degrees
     * - Minutes start at positive y-axis and increase clockwise
     * - Angle starts at positive x-axis and increases counterclockwise
     * - (e.g., 0 minutes => 90 degrees; 15 minutes => 0 degrees;
     *   30 minutes => 270 degrees; 45 minutes => 180 degrees)
     * - Will return angle in radians if `angleInRadians` is specified as
     *   truthy.
     */
    timeToDegrees: function(minutes, angleInRadians) {
        // p is the proportion of total time
        var p = minutes / 60;
        var angleProportion;

        if (p <= 0.25) {
            angleProportion = (0.25 - p);
        } else {
            angleProportion = (1.25 - p);
        }

        if (angleInRadians) {
            return 2 * Math.PI * angleProportion;
        }
        return 360 * angleProportion;
    }
});

});

define('utils/triangle-congruence.js',['require'],function(require) {

$.extend(KhanUtil, {

    initCongruence: function(options) {
        options = $.extend({
            ticks: [],
            numArcs: [0, 0, 0],
            reflected: false
        }, options);

        options.sides = options.triangle.sideLengths.slice();
        options.angles = options.triangle.angles.slice();

        var randomAngle = function(current) {
            var angle = current;
            while (Math.abs(angle - current) < 10) {
                angle = Math.floor(KhanUtil.random() * 70) + 10;
            }
            return angle;
        };

        var randomSide = function(current) {
            var side = current;
            while (Math.abs(side - current) < 1) {
                side = KhanUtil.random() * 30 / 10 + 1;
            }
            return side;
        };


        var triangle;
        //
        // Side-Side-Side
        //
        if (options.type === "SSS") {
            options.angles[0] = randomAngle(options.angles[0]);
            options.angles[1] = randomAngle(options.angles[1]);
            options.angles[2] = randomAngle(options.angles[2]);
            options.ticks = [1, 2, 3];
            triangle = KhanUtil.addInteractiveTriangle(options);

            // Point 0 is a fixed distance from point 1
            triangle.points[0].constraints.fixedDistance = { dist: options.sides[0], point: triangle.points[1] };

            // Point 1 can be used to rotate the shape
            triangle.setRotationPoint(1);

            // Point 2 can be used to rotate the shape
            triangle.setRotationPoint(2);

            // Point 3 is a fixed distance from point 2
            triangle.points[3].constraints.fixedDistance = { dist: options.sides[2], point: triangle.points[2] };

            // When point 0 moves, check if it's close enough to point 3 to make a triangle
            triangle.points[0].onMove = function(coordX, coordY) {
                triangle.points[0].coord = [coordX, coordY];
                if (KhanUtil.getDistance(triangle.points[0].coord, triangle.points[3].coord) < 0.3) {
                    triangle.snapCorrect();
                }
                triangle.update();
                return triangle.points[0].coord;
            };

            // When point 3 moves, check if it's close enough to point 0 to make a triangle
            triangle.points[3].onMove = function(coordX, coordY) {
                triangle.points[3].coord = [coordX, coordY];
                if (KhanUtil.getDistance(triangle.points[0].coord, triangle.points[3].coord) < 0.3) {
                    triangle.snapCorrect();
                }
                triangle.update();
                return triangle.points[3].coord;
            };

            triangle.snapCorrect = function() {
                // Check to see if SSS was 'reflected' by being turned inside out
                if (Math.abs(((options.triangle.angles[1] * (triangle.reflected ? -1 : 1) + 360) % 360) - ((KhanUtil.findAngle(this.points[0].coord, this.points[2].coord, this.points[1].coord) + 360) % 360)) > 90) {
                    triangle.reflected = !triangle.reflected;
                }
                this.points[0].setCoord(this.points[0].applyConstraint(this.points[0].coord, {
                    fixedAngle: {
                        angle: options.triangle.angles[1] * (triangle.reflected ? -1 : 1),
                        vertex: this.points[1],
                        ref: this.points[2]
                    }
                }));
                this.points[3].setCoord(this.points[3].applyConstraint(this.points[3].coord, {
                    fixedAngle: {
                        angle: options.triangle.angles[2] * (triangle.reflected ? 1 : -1),
                        vertex: this.points[2],
                        ref: this.points[1]
                    }
                }));
            };


        //
        // Side-Side-Angle
        //
        } else if (options.type === "SSA") {
            options.angles[0] = randomAngle(options.angles[0]);
            options.angles[1] = randomAngle(options.angles[1]);
            options.sides[2] = randomSide(options.sides[2]);
            options.ticks = [1, 2, 0];
            options.numArcs = [0, 1, 0];
            triangle = KhanUtil.addInteractiveTriangle(options);

            // Point 0 is a fixed distance from point 1
            triangle.points[0].constraints.fixedDistance = { dist: options.sides[0], point: triangle.points[1] };

            // Point 1 can be used to rotate the shape
            triangle.setRotationPoint(1);

            // Point 2 is a fixed distance from point 1
            triangle.points[2].constraints.fixedDistance = { dist: options.sides[1], point: triangle.points[1] };

            // Point 3 is a fixed angle from points 1 and 2
            triangle.points[3].constraints.fixedAngle = { angle: options.angles[2] * (triangle.reflected ? 1 : -1), vertex: triangle.points[2], ref: triangle.points[1] };

            // When point 0 moves, check if it's close enough to point 3 to make a triangle
            triangle.points[0].onMove = function(coordX, coordY) {
                triangle.points[0].coord = [coordX, coordY];
                if (KhanUtil.getDistance(triangle.points[0].coord, triangle.points[3].coord) < 0.2) {
                    triangle.snapCorrect();
                }
                triangle.update();
                return triangle.points[0].coord;
            };

            // When point 2 moves, point 3 moves along with it
            triangle.points[2].onMove = function(coordX, coordY) {
                var origCoord = triangle.points[2].coord;
                triangle.points[2].coord = [coordX, coordY];
                triangle.points[3].setCoord(triangle.points[3].applyConstraint(triangle.points[3].coord, {
                    fixedDistance: {
                        dist: KhanUtil.getDistance(triangle.points[3].coord, origCoord),
                        point: triangle.points[2]
                    }
                }));
                // Check if point 3 ends up close enough to point 0 to make a triangle
                if (KhanUtil.getDistance(triangle.points[0].coord, triangle.points[3].coord) < 0.2) {
                    triangle.snapCorrect();
                }
                triangle.update();
            };

            // When point 3 moves, check if it's close enough to point 0 to make a triangle
            triangle.points[3].onMove = function(coordX, coordY) {
                triangle.points[3].coord = [coordX, coordY];
                if (KhanUtil.getDistance(triangle.points[0].coord, triangle.points[3].coord) < 0.2) {
                    triangle.snapCorrect();
                }
                triangle.update();
                return triangle.points[3].coord;
            };

            triangle.snapCorrect = function() {
                var angle1 = options.triangle.angles[1] * (triangle.reflected ? -1 : 1);
                // SSA has two possible shapes: See which one we're closest to'
                if (Math.abs(KhanUtil.getDistance(triangle.points[2].coord, triangle.points[3].coord) - options.triangle.sideLengths[2]) > 1.0) {
                    this.isCongruent = false;
                    angle1 = Math.abs(angle1);
                    var angle2 = Math.abs(options.triangle.angles[2] * (triangle.reflected ? -1 : 1));
                    angle1 = (180 - 2 * angle2 - angle1) * (triangle.reflected ? -1 : 1);
                } else {
                    this.isCongruent = true;
                }
                this.points[0].setCoord(this.points[0].applyConstraint(this.points[0].coord, {
                    fixedAngle: {
                        angle: angle1,
                        vertex: this.points[1],
                        ref: this.points[2]
                    }
                }));
                this.points[3].setCoord(this.points[0].coord);
            };


        //
        // Side-Angle-Side
        //
        } else if (options.type === "SAS") {
            options.angles[0] = randomAngle(options.angles[0]);
            options.sides[2] = randomSide(options.sides[2]);
            options.angles[2] = randomAngle(options.angles[2]);
            options.ticks = [1, 2, 0];
            options.numArcs = [1, 0, 0];
            triangle = KhanUtil.addInteractiveTriangle(options);

            // Point 0 can be used to rotate the shape
            triangle.setRotationPoint(0);

            // Point 1 is a fixed distance from point 2
            triangle.points[1].constraints.fixedDistance = { dist: options.sides[1], point: triangle.points[2] };

            // Point 2 can be used to rotate the shape
            triangle.setRotationPoint(2);

            // Point 3 is unconstrained

            // When point 1 moves, point 0 moves along with it
            triangle.points[1].onMove = function(coordX, coordY) {
                triangle.points[1].coord = [coordX, coordY];
                triangle.points[0].setCoord(triangle.points[0].applyConstraint(triangle.points[0].coord, {
                    fixedDistance: {
                        dist: options.sides[0],
                        point: triangle.points[1]
                    },
                    fixedAngle: {
                        angle: options.angles[1] * (triangle.reflected ? -1 : 1),
                        vertex: triangle.points[1],
                        ref: triangle.points[2]
                    }
                }));
                // Check if point 0 ends up close enough to point 3 to make a triangle
                if (KhanUtil.getDistance(triangle.points[0].coord, triangle.points[3].coord) < 0.2) {
                    triangle.snapCorrect();
                }
                triangle.update();
                return triangle.points[1].coord;
            };

            // When point 3 moves, check if it's close enough to point 0 to make a triangle
            triangle.points[3].onMove = function(coordX, coordY) {
                triangle.points[3].coord = [coordX, coordY];
                if (KhanUtil.getDistance(triangle.points[0].coord, triangle.points[3].coord) < 0.2) {
                    triangle.snapCorrect();
                }
                triangle.update();
                return triangle.points[3].coord;
            };

            triangle.snapCorrect = function() {
                this.points[3].setCoord(this.points[0].coord);
            };


        //
        // Side-Side-Angle
        //
        } else if (options.type === "SAA") {
            options.angles[0] = randomAngle(options.angles[0]);
            options.sides[1] = randomSide(options.sides[1]);
            options.sides[2] = randomSide(options.sides[2]);
            options.ticks = [1, 0, 0];
            options.numArcs = [1, 2, 0];
            triangle = KhanUtil.addInteractiveTriangle(options);

            // Point 0 can be used to rotate the shape
            triangle.setRotationPoint(0);

            // Point 1 is a fixed angle from points 3 and 2
            triangle.points[1].constraints.fixedAngle = { angle: options.angles[2] * (triangle.reflected ? -1 : 1), vertex: triangle.points[2], ref: triangle.points[3] };

            // Point 2 can be used to rotate the shape
            triangle.setRotationPoint(2);

            // Point 3 is a fixed angle from points 1 and 2
            triangle.points[3].constraints.fixedAngle = { angle: options.angles[2] * (triangle.reflected ? 1 : -1), vertex: triangle.points[2], ref: triangle.points[1] };

            // When point 1 moves, point 0 moves along with it
            triangle.points[1].onMove = function(coordX, coordY) {
                triangle.points[1].coord = [coordX, coordY];
                triangle.points[0].setCoord(triangle.points[0].applyConstraint(triangle.points[0].coord, {
                    fixedDistance: {
                        dist: options.sides[0],
                        point: triangle.points[1]
                    },
                    fixedAngle: {
                        angle: options.angles[1] * (triangle.reflected ? -1 : 1),
                        vertex: triangle.points[1],
                        ref: triangle.points[2]
                    }
                }));
                // Check if point 0 ends up close enough to point 3 to make a triangle
                if (KhanUtil.getDistance(triangle.points[0].coord, triangle.points[3].coord) < 0.3) {
                    triangle.snapCorrect();
                }
                triangle.update();
                return triangle.points[1].coord;
            };

            // When point 3 moves, check if it's close enough to point 0 to make a triangle
            triangle.points[3].onMove = function(coordX, coordY) {
                triangle.points[3].coord = [coordX, coordY];
                if (KhanUtil.getDistance(triangle.points[0].coord, triangle.points[3].coord) < 0.3) {
                    triangle.snapCorrect();
                }
                triangle.update();
                return triangle.points[3].coord;
            };

            triangle.snapCorrect = function() {
                this.points[1].setCoord(this.points[1].applyConstraint(this.points[1].coord, {
                    fixedDistance: {
                        dist: options.triangle.sideLengths[1],
                        point: this.points[2]
                    }
                }));
                this.points[0].setCoord(this.points[0].applyConstraint(this.points[0].coord, {
                    fixedDistance: {
                        dist: options.triangle.sideLengths[0],
                        point: this.points[1]
                    },
                    fixedAngle: {
                        angle: options.angles[1] * (this.reflected ? -1 : 1),
                        vertex: this.points[1],
                        ref: this.points[2]
                    }
                }));
                this.points[3].setCoord(this.points[3].applyConstraint(this.points[3].coord, {
                    fixedDistance: {
                        dist: options.triangle.sideLengths[2],
                        point: this.points[2]
                    }
                }));
            };


        //
        // Angle-Side-Angle
        //
        } else if (options.type === "ASA") {
            options.sides[0] = randomSide(options.sides[0]);
            options.angles[0] = randomAngle(options.angles[0]);
            options.sides[2] = randomSide(options.sides[2]);
            options.ticks = [0, 1, 0];
            options.numArcs = [1, 2, 0];
            triangle = KhanUtil.addInteractiveTriangle(options);

            // Point 0 is a fixed angle from points 2 and 1
            triangle.points[0].constraints.fixedAngle = { angle: options.angles[1] * (triangle.reflected ? -1 : 1), vertex: triangle.points[1], ref: triangle.points[2] };

            // Point 1 can be used to rotate the shape
            triangle.setRotationPoint(1);

            // Point 2 can be used to rotate the shape
            triangle.setRotationPoint(2);

            // Point 3 is a fixed angle from points 1 and 2
            triangle.points[3].constraints.fixedAngle = { angle: options.angles[2] * (triangle.reflected ? 1 : -1), vertex: triangle.points[2], ref: triangle.points[1] };

            // When point 0 moves, check if it's close enough to point 3 to make a triangle
            triangle.points[0].onMove = function(coordX, coordY) {
                triangle.points[0].coord = [coordX, coordY];
                if (KhanUtil.getDistance(triangle.points[0].coord, triangle.points[3].coord) < 0.3) {
                    triangle.snapCorrect();
                }
                triangle.update();
                return triangle.points[0].coord;
            };

            // When point 3 moves, check if it's close enough to point 0 to make a triangle
            triangle.points[3].onMove = function(coordX, coordY) {
                triangle.points[3].coord = [coordX, coordY];
                if (KhanUtil.getDistance(triangle.points[0].coord, triangle.points[3].coord) < 0.3) {
                    triangle.snapCorrect();
                }
                triangle.update();
                return triangle.points[3].coord;
            };

            triangle.snapCorrect = function() {
                this.points[0].setCoord(this.points[0].applyConstraint(this.points[0].coord, {
                    fixedDistance: {
                        dist: options.triangle.sideLengths[0],
                        point: this.points[1]
                    }
                }));
                this.points[3].setCoord(this.points[3].applyConstraint(this.points[3].coord, {
                    fixedDistance: {
                        dist: options.triangle.sideLengths[2],
                        point: this.points[2]
                    }
                }));
            };


        //
        // Angle-Angle-Angle
        //
        } else if (options.type === "AAA") {
            var scale = KhanUtil.random() < 0.5 ? 1 : KhanUtil.random() > 0.5 ? KhanUtil.random() * 0.4 + 1.2 : KhanUtil.random() * 0.2 + 0.6;
            options.sides[0] *= scale;
            options.sides[1] *= scale;
            options.sides[2] *= scale;
            options.numArcs = [2, 3, 1];
            triangle = KhanUtil.addInteractiveTriangle(options);
            triangle.isCongruent = scale === 1;

            // The shape is always a triangle, so we don't need 4 points visible
            triangle.points[0].visibleShape.remove();
            triangle.points[0].mouseTarget.remove();
            triangle.points[0].visible = false;

            // Point 1 can be used to rotate the shape
            triangle.setRotationPoint(1);

            // Point 2 can be used to rotate the shape
            triangle.setRotationPoint(2);

            // Point 3 is a fixed angle from the centroid
            triangle.points[3].constraints.fixedAngle = {
                angle: KhanUtil.findAngle(triangle.points[3].coord, triangle.points[1].coord, triangle.rotationPoint.coord),
                vertex: triangle.rotationPoint,
                ref: triangle.points[1]
            };

            // When point 3 moves, scale the entire triangle
            triangle.points[3].onMove = function(coordX, coordY) {
                triangle.points[3].coord = [coordX, coordY];
                triangle.points[0].setCoord([coordX, coordY]);
                var scaleFactor = KhanUtil.getDistance([coordX, coordY], triangle.rotationPoint.coord) / triangle.radii[3];
                triangle.points[1].setCoord(triangle.points[1].applyConstraint(triangle.points[1].coord, {
                    fixedDistance: {
                        dist: triangle.radii[1] * scaleFactor,
                        point: triangle.rotationPoint
                    }
                }));
                triangle.points[2].setCoord(triangle.points[2].applyConstraint(triangle.points[2].coord, {
                    fixedDistance: {
                        dist: triangle.radii[2] * scaleFactor,
                        point: triangle.rotationPoint
                    }
                }));
                // Check if the triangle is close enough to congruent to make it easier/possible to get wrong
                if (Math.abs(KhanUtil.getDistance(triangle.points[0].coord, triangle.points[1].coord) - options.triangle.sideLengths[0]) < 0.3) {
                    triangle.snapCorrect();
                    triangle.isCongruent = true;
                } else {
                    triangle.isCongruent = false;
                }
                triangle.update();
                return triangle.points[3].coord;
            };

            triangle.snapCorrect = function() {
                this.points[3].setCoord(this.points[0].applyConstraint(this.points[0].coord, {
                    fixedDistance: {
                        dist: KhanUtil.getDistance(options.triangle.points[0], options.triangle.centroid),
                        point: this.rotationPoint
                    }
                }));
                this.points[0].setCoord(this.points[3].coord);
                this.points[1].setCoord(this.points[1].applyConstraint(this.points[1].coord, {
                    fixedDistance: {
                        dist: KhanUtil.getDistance(options.triangle.points[1], options.triangle.centroid),
                        point: this.rotationPoint
                    }
                }));
                this.points[2].setCoord(this.points[2].applyConstraint(this.points[2].coord, {
                    fixedDistance: {
                        dist: KhanUtil.getDistance(options.triangle.points[2], options.triangle.centroid),
                        point: this.rotationPoint
                    }
                }));
            };


        }
        KhanUtil.currentGraph.interactiveTriangle = triangle;

    },


    addInteractiveTriangle: function(options) {
        var triangle = $.extend({
            points: [],
            lines: [],
            numArcs: options.numArcs,
            arcs: [],
            radii: [],
            reflected: false,
            animating: false,
            isCongruent: true,
            isTriangle: false
        }, options);

        // Redraw/refresh the triangle
        triangle.update = function() {
            if (!KhanUtil.dragging) {
                // if the shape is a triangle, rotate around the centroid, otherwise use the center of the bounding box
                if (Math.abs(triangle.points[0].coord[0] - triangle.points[3].coord[0]) < 0.001 && Math.abs(triangle.points[0].coord[1] - triangle.points[3].coord[1]) < 0.001) {
                    triangle.isTriangle = true;
                    triangle.rotationPoint.setCoord([
                        1 / 3 * (triangle.points[0].coord[0] + triangle.points[1].coord[0] + triangle.points[2].coord[0]),
                        1 / 3 * (triangle.points[0].coord[1] + triangle.points[1].coord[1] + triangle.points[2].coord[1])
                    ]);
                } else {
                    triangle.isTriangle = false;
                    var minX = Math.min(triangle.points[0].coord[0], triangle.points[1].coord[0], triangle.points[2].coord[0], triangle.points[3].coord[0]);
                    var maxX = Math.max(triangle.points[0].coord[0], triangle.points[1].coord[0], triangle.points[2].coord[0], triangle.points[3].coord[0]);
                    var minY = Math.min(triangle.points[0].coord[1], triangle.points[1].coord[1], triangle.points[2].coord[1], triangle.points[3].coord[1]);
                    var maxY = Math.max(triangle.points[0].coord[1], triangle.points[1].coord[1], triangle.points[2].coord[1], triangle.points[3].coord[1]);

                    triangle.rotationPoint.setCoord([(maxX - minX) / 2 + minX, (maxY - minY) / 2 + minY]);
                }

                for (var point = 0; point < 4; ++point) {
                    triangle.radii[point] = KhanUtil.getDistance(triangle.points[point].coord, triangle.rotationPoint.coord);
                    if (triangle.points[point].isRotationPoint) {
                        triangle.points[point].constraints.fixedDistance = { dist: triangle.radii[point], point: triangle.rotationPoint };
                    }
                }
            }

            var graph = KhanUtil.currentGraph;
            graph.style({ stroke: KhanUtil.BLUE, opacity: 1.0, "stroke-width": 2 });
            for (var angle = 0; angle < 2; ++angle) {
                $(triangle.arcs[angle]).each(function() { this.remove(); });
                triangle.arcs[angle] = graph.drawArcs(triangle.points[angle].coord, triangle.points[angle + 1].coord, triangle.points[angle + 2].coord, options.numArcs[angle]);
            }
            if (options.numArcs[2]) {
                $(triangle.arcs[2]).each(function() { this.remove(); });
                triangle.arcs[angle] = graph.drawArcs(triangle.points[2].coord, triangle.points[3].coord, triangle.points[1].coord, options.numArcs[2]);
            }

            $(triangle.lines).each(function() {
                this.transform(true);
                this.toFront();
            });
            $(triangle.points).each(function() { this.toFront(); });
        };

        // Call to set one of the points to rotate the entire shape
        triangle.setRotationPoint = function(point) {
            triangle.points[point].isRotationPoint = true;
            triangle.points[point].normalStyle = { fill: KhanUtil.BLUE, stroke: KhanUtil.BLUE, scale: 1 };
            triangle.points[point].highlightStyle = { fill: KhanUtil.BLUE, stroke: KhanUtil.BLUE, scale: 1.5 };
            triangle.points[point].visibleShape.attr(triangle.points[point].normalStyle);
            triangle.points[point].constraints.fixedDistance = { dist: triangle.radii[point], point: triangle.rotationPoint };

            triangle.points[point].onMove = function(coordX, coordY) {
                var dAngle = KhanUtil.findAngle([coordX, coordY], triangle.points[point].coord, triangle.rotationPoint.coord) * Math.PI / 180;
                for (var i = 0; i < 4; ++i) {
                    if (i !== point) {
                        triangle.points[i].setCoord([
                            (triangle.points[i].coord[0] - triangle.rotationPoint.coord[0]) * Math.cos(dAngle) - (triangle.points[i].coord[1] - triangle.rotationPoint.coord[1]) * Math.sin(dAngle) + triangle.rotationPoint.coord[0],
                            (triangle.points[i].coord[0] - triangle.rotationPoint.coord[0]) * Math.sin(dAngle) + (triangle.points[i].coord[1] - triangle.rotationPoint.coord[1]) * Math.cos(dAngle) + triangle.rotationPoint.coord[1]
                        ]);
                    }
                }
                triangle.points[point].coord = [coordX, coordY];
                triangle.update();
            };
        };

        $(".question").prepend("<button id='reflect' type='button'>" +
            $._("Reflect shape") + "</button>");
        $("button#reflect").bind("click", function(event) {
            this.blur();
            if (!triangle.animating) {
                triangle.animating = true;
                var startPoints = $.map(triangle.points, function(pt) { return [pt.coord.slice()]; });
                var xMin = Math.min.apply(Math, $.map(startPoints, function(x) { return x[0]; }));
                var xMax = Math.max.apply(Math, $.map(startPoints, function(x) { return x[0]; }));
                var xMid = (xMin + xMax) / 2;
                var endPoints = $.map(triangle.points, function(pt) { return [[xMid - pt.coord[0] + xMid, pt.coord[1]]]; });

                // flip the angles around
                $(triangle.points).each(function(n, point) {
                    if (typeof point.constraints.fixedAngle.angle === "number") {
                        point.constraints.fixedAngle.angle *= -1;
                    }
                });
                triangle.reflected = !triangle.reflected;

                // remove the angle arc decorations since (without some effort) they look funny during the animation
                $(triangle.arcs[0]).each(function() { this.remove(); });
                $(triangle.arcs[1]).each(function() { this.remove(); });
                $(triangle.arcs[2]).each(function() { this.remove(); });

                var xCoords = { 0: startPoints[0][0], 1: startPoints[1][0], 2: startPoints[2][0], 3: startPoints[3][0] };
                $(xCoords).animate({ 0: endPoints[0][0], 1: endPoints[1][0], 2: endPoints[2][0], 3: endPoints[3][0] }, {
                    duration: 500,
                    easing: "linear",
                    step: function(now, fx) {
                        $(triangle.points).each(function(n) { this.setCoord([xCoords[n], endPoints[n][1]]); });
                        $(triangle.lines).each(function() { this.transform(true); });
                    },
                    complete: function() {
                        $(triangle.points).each(function(n) { this.setCoord(endPoints[n]); });
                        triangle.update();
                        triangle.animating = false;
                    }
                });
            }
        });

        // Flip the angles around if the triangle starts out reflected
        var angles = options.angles.slice();

        if (!options.reflected) {
            $(angles).each(function(n) {
                angles[n] *= -1;
            });
        }

        var graphie = KhanUtil.currentGraph;
        // Start at 0,0 and build the shape, logo-style
        var coord = [0, 0];
        triangle.points.push(graphie.addMovablePoint({ coord: coord }));

        coord[0] += options.sides[0] * Math.cos(angles[0] * Math.PI / 180);
        coord[1] += options.sides[0] * Math.sin(angles[0] * Math.PI / 180);
        triangle.points.push(graphie.addMovablePoint({ coord: coord, bounded: false }));

        coord[0] += options.sides[1] * Math.cos(-(180 - angles[1] - angles[0]) * Math.PI / 180);
        coord[1] += options.sides[1] * Math.sin(-(180 - angles[1] - angles[0]) * Math.PI / 180);
        triangle.points.push(graphie.addMovablePoint({ coord: coord, bounded: false }));

        coord[0] += options.sides[2] * Math.cos((angles[2] + angles[1] + angles[0]) * Math.PI / 180);
        coord[1] += options.sides[2] * Math.sin((angles[2] + angles[1] + angles[0]) * Math.PI / 180);
        triangle.points.push(graphie.addMovablePoint({ coord: coord, bounded: false }));

        triangle.lines.push(graphie.addMovableLineSegment({ pointA: triangle.points[0], pointZ: triangle.points[1], ticks: options.ticks[0], highlightStyle: { "stroke": KhanUtil.BLUE, "stroke-width": 4 } }));
        triangle.lines.push(graphie.addMovableLineSegment({ pointA: triangle.points[1], pointZ: triangle.points[2], ticks: options.ticks[1], highlightStyle: { "stroke": KhanUtil.BLUE, "stroke-width": 4 } }));
        triangle.lines.push(graphie.addMovableLineSegment({ pointA: triangle.points[2], pointZ: triangle.points[3], ticks: options.ticks[2], highlightStyle: { "stroke": KhanUtil.BLUE, "stroke-width": 4 } }));

        triangle.rotationPoint = graphie.addMovablePoint({ visible: false });

        // Translate the triangle so it's all visible
        var xlateX = 4 - Math.max(triangle.points[0].coord[0], triangle.points[1].coord[0], triangle.points[2].coord[0], triangle.points[3].coord[0]);
        var xlateY = 4 - Math.max(triangle.points[0].coord[1], triangle.points[1].coord[1], triangle.points[2].coord[1], triangle.points[3].coord[1]);
        $(triangle.points).each(function() { this.setCoord([this.coord[0] + xlateX, this.coord[1] + xlateY]); });

        // Dragging the lines translates the entire shape
        for (var line = 0; line < 3; ++line) {
            triangle.lines[line].onMove = function(dX, dY) {
                $(triangle.points).each(function() { this.setCoord([this.coord[0] + dX, this.coord[1] + dY]); });
                triangle.update();
            };
            triangle.lines[line].onMoveEnd = function() {
                triangle.update();
            };
        }

        // Always redraw the triangle after a point moves
        for (var point = 0; point < 4; ++point) {
            triangle.points[point].onMoveEnd = function(coordX, coordY) {
                triangle.update();
            };
        }

        triangle.update();
        return triangle;
    },



    addTriangleDecorations: function(triangle, type) {
        var ticks = [0, 0, 0];
        var arcs = [0, 0, 0];
        if (type === "SSS") {
            ticks = [1, 2, 3];
        } else if (type === "SSA") {
            arcs = [0, 0, 1];
            ticks = [1, 2, 0];
        } else if (type === "SAS") {
            arcs = [0, 1, 0];
            ticks = [1, 2, 0];
        } else if (type === "SAA") {
            arcs = [0, 1, 2];
            ticks = [1, 0, 0];
        } else if (type === "ASA") {
            arcs = [0, 1, 2];
            ticks = [0, 1, 0];
        } else if (type === "AAA") {
            arcs = [1, 2, 3];
        }

        var graphie = KhanUtil.currentGraph;
        graphie.addMovableLineSegment({ coordA: triangle.points[0], coordZ: triangle.points[1], fixed: true, ticks: ticks[0], normalStyle: { stroke: "#b1c9f5", "stroke-width": 2 } });
        graphie.addMovableLineSegment({ coordA: triangle.points[1], coordZ: triangle.points[2], fixed: true, ticks: ticks[1], normalStyle: { stroke: "#b1c9f5", "stroke-width": 2 } });
        graphie.addMovableLineSegment({ coordA: triangle.points[2], coordZ: triangle.points[0], fixed: true, ticks: ticks[2], normalStyle: { stroke: "#b1c9f5", "stroke-width": 2 } });
        graphie.drawArcs(triangle.points[2], triangle.points[0], triangle.points[1], arcs[0]);
        graphie.drawArcs(triangle.points[0], triangle.points[1], triangle.points[2], arcs[1]);
        graphie.drawArcs(triangle.points[1], triangle.points[2], triangle.points[0], arcs[2]);
        $(triangle.set).each(function() { this.toBack(); });
    }

});

});

define('utils/unit-circle.js',['require','../third_party/jquery.mobile.vmouse.js'],function(require) {

require("../third_party/jquery.mobile.vmouse.js");

$.extend(KhanUtil, {
    initUnitCircle: function(degrees) {
        var graph = KhanUtil.currentGraph;

        // Create a properly scaled 600x600px graph
        var options = {
            xpixels: 514,
            ypixels: 514,
            range: [[-1.2, 1.2], [-1.2, 1.2]]
        };
        options.scale = [options.xpixels / (options.range[0][1] - options.range[0][0]),
                          options.ypixels / (options.range[1][1] - options.range[1][0])];
        graph.init(options);

        // Attach the metrics to the graph for later reference
        graph.xpixels = options.xpixels;
        graph.ypixels = options.ypixels;
        graph.range = options.range;
        graph.scale = options.scale;

        graph.angle = 0;
        graph.revolutions = 0;
        graph.quadrant = 1;

        graph.dragging = false;
        graph.highlight = false;
        graph.degrees = degrees;

        // Axes and circle
        graph.style({
            stroke: "#ddd",
            strokeWidth: 1,
            arrows: "->"
        }, function() {
            graph.circle([0, 0], 1);
            graph.line([-1.2, 0], [1.2, 0]);
            graph.line([0, -1.2], [0, 1.2]);
            graph.line([1.2, 0], [-1.2, 0]);
            graph.line([0, 1.2], [0, -1.2]);
        });

        // Tick marks at -1, 1
        graph.style({
            strokeWidth: 2
        }, function() {
            graph.line([-1, -5 / graph.scale[0]], [-1, 5 / graph.scale[0]]);
            graph.line([1, -5 / graph.scale[0]], [1, 5 / graph.scale[0]]);
            graph.line([-5 / graph.scale[0], -1], [5 / graph.scale[0], -1]);
            graph.line([-5 / graph.scale[0], 1], [5 / graph.scale[0], 1]);
        });

        // Declare all the graphic elements that get manipulated each time the angle changes
        graph.triangle = KhanUtil.bogusShape;
        graph.rightangle = KhanUtil.bogusShape;
        graph.spiral = KhanUtil.bogusShape;
        graph.arrow = KhanUtil.bogusShape;
        graph.cosLabel = KhanUtil.bogusShape;
        graph.sinLabel = KhanUtil.bogusShape;
        graph.radiusLabel = KhanUtil.bogusShape;
        graph.angleLabel = KhanUtil.bogusShape;
        graph.angleLines = KhanUtil.bogusShape;

        KhanUtil.initMouseHandlers();
        KhanUtil.setAngle(graph.angle);
    },

    // Not all shapes are needed to depict every angle. If a shape isn't
    // needed, it's replaced with bogusShape which just has stub methods
    // that successfully do nothing.
    // The alternative would be 'if..typeof' checks all over the place.
    bogusShape: {
        animate: function() {},
        attr: function() {},
        remove: function() {}
    },


    initMouseHandlers: function() {
        var graph = KhanUtil.currentGraph;

        // Another SVG element on top of everything else where we can add
        // invisible shapes with mouse handlers wherever we want.
        graph.mouselayer = Raphael("unitcircle", graph.xpixels, graph.ypixels);
        $(graph.mouselayer.canvas).css("z-index", 1);
        Khan.scratchpad.disable();

        // Visible orange point that gets dragged
        graph.style({
            stroke: KhanUtil.ORANGE,
            fill: KhanUtil.ORANGE
        }, function() {
            graph.dragPoint = graph.circle([1, 0], 4 / graph.scale[0]);
        });

        // The invisible circle that gets mouse events.
        graph.mouseTarget = graph.mouselayer.circle(
                (1 - graph.range[0][0]) * graph.scale[0],
                (graph.range[1][1] - 0) * graph.scale[1], 15);
        graph.mouseTarget.attr({fill: "#000", "opacity": 0.0});

        $(graph.mouseTarget[0]).css("cursor", "move");
        $(graph.mouseTarget[0]).bind("vmousedown vmouseover vmouseout", function(event) {
            var graph = KhanUtil.currentGraph;
            if (event.type === "vmouseover") {
                graph.highlight = true;
                if (!graph.dragging) {
                    KhanUtil.highlightAngle();
                }

            } else if (event.type === "vmouseout") {
                graph.highlight = false;
                if (!graph.dragging) {
                    KhanUtil.unhighlightAngle();
                }

            } else if (event.type === "vmousedown" && (event.which === 1 || event.which === 0)) {
                event.preventDefault();
                $(document).bind("vmousemove vmouseup", function(event) {
                    event.preventDefault();
                    graph.dragging = true;

                    // mouseY is in pixels relative to the SVG; coordY is the scaled y-coordinate value
                    var mouseY = event.pageY - $("#unitcircle").offset().top;
                    var mouseX = event.pageX - $("#unitcircle").offset().left;
                    var coordX = (mouseX / graph.scale[0]) + graph.range[0][0];
                    var coordY = graph.range[1][1] - mouseY / graph.scale[1];

                    if (event.type === "vmousemove") {
                        // Find the angle from the origin to the mouse pointer
                        var angle;
                        if (coordX) {
                            angle = Math.atan(coordY / coordX);
                        } else {
                            // Fill in where atan is undefined
                            if (coordY > 0) {
                                angle = -Math.PI / 2;
                            } else {
                                angle = -Math.PI / 2;
                            }
                        }

                        // Round the angle to the nearest 5 degree increment
                        angle = Math.round(angle / (Math.PI / 36)) * (Math.PI / 36);

                        // Figure out what quadrant the mouse is in. Since atan
                        // is only defined in Q1 and Q4 (and is negative in Q4),
                        // adjust the angle appropriately to represent the correct
                        // positive angle in the unit circle.
                        //
                        // If moving between Q1 and Q4, keep track of the number of revolutions.
                        if (coordX > 0 && coordY >= 0) {
                            if (graph.quadrant === 4) {
                                ++graph.revolutions;
                            }
                            graph.quadrant = 1;

                        } else if (coordX <= 0 && coordY > 0) {
                            angle += Math.PI;
                            graph.quadrant = 2;

                        } else if (coordX < 0 && coordY <= 0) {
                            angle += Math.PI;
                            graph.quadrant = 3;

                        } else if (coordX >= 0 && coordY < 0) {
                            angle += 2 * Math.PI;
                            if (graph.quadrant === 1) {
                                --graph.revolutions;
                            }
                            graph.quadrant = 4;
                        }

                        // Limit the number of revolutions to 2 in either direction.
                        if (graph.revolutions <= -3) {
                            graph.revolutions = -3;
                            angle = 2 * Math.PI;
                        } else if (graph.revolutions >= 2) {
                            graph.revolutions = 2;
                            angle = 0;
                        }

                        // Now ((2pi * revolutions) + angle) represents the full angle
                        // Redraw the angle only if it's changed
                        if (graph.angle !== angle + (graph.revolutions * 2 * Math.PI)) {
                            KhanUtil.setAngle(angle + (graph.revolutions * 2 * Math.PI));
                        }

                    } else if (event.type === "vmouseup") {
                        $(document).unbind("vmousemove vmouseup");
                        graph.dragging = false;
                        if (!graph.highlight) {
                            KhanUtil.unhighlightAngle();
                        }
                    }
                });
            }
        });

    },


    highlightAngle: function() {
        var graph = KhanUtil.currentGraph;
        graph.dragPoint.animate({ scale: 2 }, 50);
        graph.angleLines.animate({ stroke: KhanUtil.ORANGE }, 100);
        graph.spiral.animate({ stroke: KhanUtil.ORANGE }, 100);
        graph.arrow.animate({ fill: KhanUtil.ORANGE }, 100);
        $(graph.angleLabel).animate({ color: KhanUtil.ORANGE }, 100);
        //$(graph.angleLabel).css({ color: KhanUtil.ORANGE });
    },


    unhighlightAngle: function() {
        var graph = KhanUtil.currentGraph;
        graph.dragPoint.animate({ scale: 1 }, 50);
        graph.angleLines.animate({ stroke: KhanUtil.BLUE }, 100);
        graph.spiral.animate({ stroke: KhanUtil.BLUE }, 100);
        graph.arrow.animate({ fill: KhanUtil.BLUE }, 100);
        $(graph.angleLabel).animate({ color: KhanUtil.BLUE }, 100);
        //$(graph.angleLabel).css({ color: KhanUtil.BLUE });
    },


    // Redraw the angle
    setAngle: function(angle) {
        var graph = KhanUtil.currentGraph;
        graph.angle = angle;

        graph.quadrant = (Math.floor((angle + 10 * Math.PI) / (Math.PI / 2)) % 4) + 1;
        graph.revolutions = Math.floor(angle / (2 * Math.PI));

        // Remove everything dynamic. It should be safe to call remove()
        // on everything since unused stuff should be instances of bogusShape
        graph.triangle.remove();
        graph.rightangle.remove();
        graph.spiral.remove();
        graph.arrow.remove();
        graph.cosLabel.remove();
        graph.sinLabel.remove();
        graph.radiusLabel.remove();
        graph.angleLabel.remove();
        graph.angleLines.remove();

        var highlightColor = KhanUtil.BLUE;
        if (graph.dragging || graph.highlight) {
            highlightColor = KhanUtil.ORANGE;
        }

        // Draw the bold angle lines
        graph.style({ stroke: highlightColor, strokeWidth: 3 });
        graph.angleLines = graph.path([[1, 0], [0, 0], [Math.cos(angle), Math.sin(angle)]]);


        graph.style({ stroke: KhanUtil.BLUE, strokeWidth: 1 });
        graph.triangle = graph.path([[0, 0], [Math.cos(angle), 0], [Math.cos(angle), Math.sin(angle)], [0, 0]]);

        var cosText = KhanUtil.roundTo(3, Math.cos(angle));
        var sinText = KhanUtil.roundTo(3, Math.sin(angle));

        // Include radicals for common 45-45-90 and 30-60-90 values
        var prettyAngles = {
            "0.866": "\\frac{\\sqrt{3}}{2}\\;(0.866)",
            "-0.866": "-\\frac{\\sqrt{3}}{2}\\;(-0.866)",
            "0.707": "\\frac{\\sqrt{2}}{2}\\;(0.707)",
            "-0.707": "-\\frac{\\sqrt{2}}{2}\\;(-0.707)",
            "0.5": "\\frac{1}{2}\\;(0.5)",
            "-0.5": "-\\frac{1}{2}\\;(-0.5)"
        };

        cosText = prettyAngles[cosText] ? prettyAngles[cosText] : cosText;
        sinText = prettyAngles[sinText] ? prettyAngles[sinText] : sinText;

        // Position the distance labels and right-angle marker based on quadrant
        if (angle % Math.PI === 0) {
            graph.cosLabel = graph.label([Math.cos(angle) / 2, 0], cosText, "below");
        } else if (angle % (Math.PI / 2) === 0) {
            graph.sinLabel = graph.label([Math.cos(angle), Math.sin(angle) / 2], sinText, "right");
        } else if (graph.quadrant === 1) {
            graph.cosLabel = graph.label([Math.cos(angle) / 2, 0], cosText, "below");
            graph.sinLabel = graph.label([Math.cos(angle), Math.sin(angle) / 2], sinText, "right");
            graph.radiusLabel = graph.label([Math.cos(angle) / 2, Math.sin(angle) / 2], 1, "above left");
            graph.rightangle = graph.path([[Math.cos(angle) - 0.04, 0], [Math.cos(angle) - 0.04, 0.04], [Math.cos(angle), 0.04]]);
        } else if (graph.quadrant === 2) {
            graph.cosLabel = graph.label([Math.cos(angle) / 2, 0], cosText, "below");
            graph.sinLabel = graph.label([Math.cos(angle), Math.sin(angle) / 2], sinText, "left");
            graph.radiusLabel = graph.label([Math.cos(angle) / 2, Math.sin(angle) / 2], 1, "above right");
            graph.rightangle = graph.path([[Math.cos(angle) + 0.04, 0], [Math.cos(angle) + 0.04, 0.04], [Math.cos(angle), 0.04]]);
        } else if (graph.quadrant === 3) {
            graph.cosLabel = graph.label([Math.cos(angle) / 2, 0], cosText, "above");
            graph.sinLabel = graph.label([Math.cos(angle), Math.sin(angle) / 2], sinText, "left");
            graph.radiusLabel = graph.label([Math.cos(angle) / 2, Math.sin(angle) / 2], 1, "below right");
            graph.rightangle = graph.path([[Math.cos(angle) + 0.04, 0], [Math.cos(angle) + 0.04, -0.04], [Math.cos(angle), -0.04]]);
        } else if (graph.quadrant === 4) {
            graph.cosLabel = graph.label([Math.cos(angle) / 2, 0], cosText, "above");
            graph.sinLabel = graph.label([Math.cos(angle), Math.sin(angle) / 2], sinText, "right");
            graph.radiusLabel = graph.label([Math.cos(angle) / 2, Math.sin(angle) / 2], 1, "below left");
            graph.rightangle = graph.path([[Math.cos(angle) - 0.04, 0], [Math.cos(angle) - 0.04, -0.04], [Math.cos(angle), -0.04]]);
        }

        // Draw the spiral angle indicator
        var points = [];
        for (var i = 0; i <= 50; ++i) {
            points.push([Math.cos(i * angle / 50) * (0.1 + ((i * Math.abs(angle) / 50 / Math.PI) * 0.02)),
                          Math.sin(i * angle / 50) * (0.1 + ((i * Math.abs(angle) / 50 / Math.PI) * 0.02))]);
        }
        graph.style({ strokeWidth: 2, stroke: highlightColor });

        graph.spiral = graph.path(points);

        // Draw an arrow at the end of the spiral angle indicator
        var spiralEndX = points[50][0];
        var spiralEndY = points[50][1];
        graph.style({ stroke: false, fill: highlightColor }, function() {
            if (angle > Math.PI / 12) {
                // positive angles big enough to need an arrow
                graph.arrow = graph.path([[spiralEndX, spiralEndY - 0.005],
                                           [spiralEndX - 0.02, spiralEndY - 0.03],
                                           [spiralEndX + 0.02, spiralEndY - 0.03],
                                           [spiralEndX, spiralEndY - 0.005]]);
                graph.arrow.rotate((angle - Math.PI / 20) * (-180 / Math.PI), (spiralEndX - graph.range[0][0]) * graph.scale[0], (graph.range[1][1] - spiralEndY) * graph.scale[1]);
            } else if (angle < -Math.PI / 12) {
                // negative angles "big" enough to need an arrow
                graph.arrow = graph.path([[spiralEndX, spiralEndY + 0.005],
                                           [spiralEndX - 0.02, spiralEndY + 0.03],
                                           [spiralEndX + 0.02, spiralEndY + 0.03],
                                           [spiralEndX, spiralEndY + 0.005]]);
                graph.arrow.rotate((angle + Math.PI / 20) * (-180 / Math.PI), (spiralEndX - graph.range[0][0]) * graph.scale[0], (graph.range[1][1] - spiralEndY) * graph.scale[1]);
            } else {
                // no room for an arrow
                graph.arrow = KhanUtil.bogusShape;
            }
        });


        // Figure out how to display the angle
        var angleText = angle;
        if (graph.degrees) {
            angleText *= (180 / Math.PI);
            angleText = Math.round(angleText);
            angleText += "^{\\circ}";
        } else if (-15 < angle && angle < 15 && angle !== 0) {
            angleText = KhanUtil.piFraction(angle);
        }

        // Put the angle value somewhere obvious, but not in the way of anything else. This
        // could probably be improved, but it at least prevents text on top of other text.
        if (angle < -3.5 * Math.PI) {
            graph.angleLabel = graph.label([-0.2, 0.2], angleText, "center");
        } else if (angle < -0.15 * Math.PI) {
            graph.angleLabel = graph.label([Math.cos(angle / 2) / 5, Math.sin(angle / 2) / 5], angleText, "center");
        } else if (angle < 0.15 * Math.PI) {
            graph.angleLabel = graph.label([0, 0], angleText, "left");
        } else if (angle < 3.5 * Math.PI) {
            graph.angleLabel = graph.label([Math.cos(angle / 2) / 5, Math.sin(angle / 2) / 5], angleText, "center");
        } else {
            graph.angleLabel = graph.label([-0.2, -0.2], angleText, "center");
        }
        $(graph.angleLabel).css("color", highlightColor);


        // Reposition the mouse target and indicator
        graph.mouseTarget.attr("cx", (Math.cos(angle) - graph.range[0][0]) * graph.scale[0]);
        graph.mouseTarget.attr("cy", (graph.range[1][1] - Math.sin(angle)) * graph.scale[1]);
        graph.dragPoint.attr("cx", (Math.cos(angle) - graph.range[0][0]) * graph.scale[0]);
        graph.dragPoint.attr("cy", (graph.range[1][1] - Math.sin(angle)) * graph.scale[1]);
        graph.angleLines.toFront();
        graph.dragPoint.toFront();
    },


    goToAngle: function(angle) {
        var graph = KhanUtil.currentGraph;
        if (graph.degrees) {
            angle *= (Math.PI / 180);
        }
        var duration = 1000 * Math.abs(angle - graph.angle) / Math.PI;
        $(graph).animate({
            angle: angle
        }, {
            duration: duration,
            easing: "linear",
            step: function(now, fx) {
                KhanUtil.setAngle(now);
            }
        });
    },


    showCoordinates: function(angle, highlightCoord) {
        var graph = KhanUtil.currentGraph;
        if (graph.degrees) {
            angle *= (Math.PI / 180);
        }

        graph.style({stroke: 0, fill: KhanUtil.BLUE}, function() {
            graph.circle([Math.cos(angle), Math.sin(angle)], 4 / graph.scale[0]);
        });
        graph.dragPoint.toFront();

        var xCoord = KhanUtil.roundTo(3, Math.cos(angle));
        var yCoord = KhanUtil.roundTo(3, Math.sin(angle));
        
        if (highlightCoord === 'x') {
            xCoord = "\\pink{" + xCoord + "}";
        }

        if (highlightCoord === 'y') {
            yCoord = "\\pink{" + yCoord + "}";
        }

        var coordText = "(" + xCoord + ", " + yCoord + ")";

        if (Math.floor(angle / Math.PI) % 2) {
            graph.coordLabel = graph.label([Math.cos(angle), Math.sin(angle)], coordText, "below");
        } else {
            graph.coordLabel = graph.label([Math.cos(angle), Math.sin(angle)], coordText, "above");
        }

    }

});

});

define('utils/visualizing-derivatives.js',['require'],function(require) {

$.extend(KhanUtil, {

    PiecewiseFunction: function(options) {
        options = $.extend(true, {
            INTERVAL_WIDTH: 2,
            fnArray: [],
            rangeArray: [],
            _paths: {}
        }, options);

        $.extend(this, options);
        _.bindAll(this);

        this.length = function() {
            return this.fnArray.length;
        };

        this.width = function() {
            var n = this.length();
            return this.rangeArray[n - 1][1] - this.rangeArray[0][0];
        };

        this.toTextArray = function(fnArray) {
            if (!fnArray) {
                fnArray = this.fnArray;
            }
            return _.map(fnArray, function(fn) {
                return fn.text();
            });
        };

        this._shiftArray = function() {
            var w = this.INTERVAL_WIDTH;
            return _.map(this.rangeArray, function(range, i) {
                // shift by the original interval start points
                // (before trimming if the problem is offset)
                return Math.floor(range[0] / w) * w;
            });
        };

        this._shiftFnArray = function() {
            var shiftArray = this._shiftArray();
            return _.map(this.fnArray, function(fn, i) {
                return fn.scale(1, -shiftArray[i]);
            });
        };

        this.derivative = function(fnArray) {
            if (!fnArray) {
                fnArray = this.fnArray;
            }
            return _.map(fnArray, function(fn, i) {
                return fn.derivative();
            });
        };

        this.translate = function(dx, dy) {
            // dx changes rangeArray
            if (dx) {
                this.rangeArray = _.map(this.rangeArray, function(range) {
                    return _.map(range, function(x) {
                        return x + dx;
                    });
                });
            }

            // dy changes functions
            if (dy) {
                this.fnArray = _.map(this.fnArray, function(fn) {
                    var result = fn.add(dy);
                    return result;
                });
            }
        };

        // shift rangeArray so that it starts at x = 0
        // shift fnArray so that smallest value is at y = 0
        this.calibrate = function() {
            var dx = this.rangeArray[0][0];

            var w = this.INTERVAL_WIDTH;
            var dy = this.fnArray[0].evalOf(0);
            _.each(this.fnArray, function(fn) {
                // NOTE: only checks start and endpoints at the moment
                var start = fn.evalOf(0);
                var end = fn.evalOf(w);
                dy = Math.min(dy, start, end);
            });

            this.translate(-dx + 2, -dy);
        };

        // like w/ JS arrays, startIndex is inclusive, endIndex is exclusive
        this.slice = function(startIndex, endIndex) {
            if (startIndex >= endIndex) {
                return null;
            }

            var crop = function(array) {
                return array.slice(startIndex, endIndex);
            };

            return new KhanUtil.PiecewiseFunction({
                fnArray: crop(this.fnArray),
                rangeArray: crop(this.rangeArray)
            });
        };

        // returns a new piecewiseFunction
        this.concat = function(piecewiseFn) {

            var fnArray = this.fnArray.concat(piecewiseFn.fnArray);

            // shift the rangeArray of the second function
            var offset = piecewiseFn.rangeArray[0][0];
            var start = this.rangeArray[this.rangeArray.length - 1][1];
            var shiftedRangeArray = _.map(piecewiseFn.rangeArray, function(range) {
                return _.map(range, function(x) {
                    return x - offset + start;
                });
            });
            var rangeArray = this.rangeArray.concat(shiftedRangeArray);

            return new KhanUtil.PiecewiseFunction({
                fnArray: fnArray,
                rangeArray: rangeArray
            });

        };

        // find matches w/ piecewiseFunction in this object
        // only compares fnArray, not rangeArray
        this.matches = function(piecewiseFunction, useDerivative) {

            var original = this.fnArray;
            var other = piecewiseFunction.fnArray;

            if (useDerivative) {
                original = this.derivative();
                other = piecewiseFunction.derivative();
            }

            original = this.toTextArray(original);
            other = this.toTextArray(other);

            // no matches if the parameter object has more segments than this
            // object
            var n = other.length;
            var diff = original.length - n;
            if (diff < 0) {
                return null;
            }

            var matches = [];
            _.times(diff + 1, function(i) {
                if (_.isEqual(original.slice(i, i + n), other)) {
                    matches.push(i);
                }
            });
            return matches;
        };

        // used in generating the problem graphs
        // ex: [[0, 1], [1, 2]] with offset == 0.25
        //          ==> [[0.25, 1], [1, 1.75]]
        this.trimRangeArrayEnds = function(offset) {
            // for some reason, an offset of 0 causes this to crash
            // without this line. ?_?
            if (offset === 0) {
                return;
            }
            var n = this.length();
            var offsetAmt = this.INTERVAL_WIDTH * offset;
            this.rangeArray[0][0] += offsetAmt;
            this.rangeArray[n - 1][1] += (offsetAmt - this.INTERVAL_WIDTH);
        };

        this._makePlotArray = function(fnArray) {
            if (!fnArray) {
                fnArray = this.fnArray;
            }
            return _.map(fnArray, function(fn, i) {
                return function(x) {
                    return fn.evalOf(x);
                };
            });
        };

        this._plotEndpoints = function(color, plotDerivative, omitEnds) {
            var shiftedFnArray = this._shiftFnArray();
            var antiderivFnArray;
            if (plotDerivative) {
                antiderivFnArray = shiftedFnArray;
                shiftedFnArray = this.derivative(shiftedFnArray);
            }

            // compute endpoints
            var emptyEndpoints = [];
            var filledEndpoints = [];
            var derivEndpoints = [];

            var prevX = null;
            var prevY = null;
            var prevOrigY = null;
            var n = this.rangeArray.length;

            _.each(this.rangeArray, function(range, i) {
                var fn = shiftedFnArray[i],
                    origFn;

                if (plotDerivative) {
                    origFn = antiderivFnArray[i];
                }

                _.each(range, function(x, j) {
                    var y = fn.evalOf(x);
                    var origY = plotDerivative ? origFn.evalOf(x) : null;

                    if (i > 0 && j === 0) {
                        // if the graph is not connected, add endpoints
                        if (y !== prevY || x !== prevX) {
                            // arbitrarily always set "earlier" endpoint as
                            // filled
                            filledEndpoints.push([prevX, prevY]);
                            emptyEndpoints.push([x, y]);

                        } else {
                            // don't add endpoints to derivative if both the
                            // graph and derivative are continuous at (x, y)
                            if (origY !== prevOrigY || x !== prevX) {
                                derivEndpoints.push([x, y]);
                            }
                        }
                    }

                    // start off with an empty first endpoint
                    // omit first and last endpoints in a cropped window
                    if (i === 0 && j === 0 && !omitEnds) {
                        emptyEndpoints.push([x, y]);
                    }

                    // end with a filled endpoint
                    if (i === n - 1 && j === 1 && !omitEnds) {
                        filledEndpoints.push([x, y]);
                    }

                    prevX = x;
                    prevY = y;
                    prevOrigY = origY;
                });
            });

            // all endpoints are undefined (empty) in a derivative graph
            if (plotDerivative) {
                emptyEndpoints = derivEndpoints.concat(emptyEndpoints)
                                               .concat(filledEndpoints);
                filledEndpoints = [];
            }

            // plot endpoints
            var self = this;

            this._paths["emptyEndpoints"] = this.graphie.style({
                stroke: color,
                strokeWidth: 3,
                fill: "#FFFFFF"
            }, function() {
                return self.graphie.plotEndpointCircles(emptyEndpoints);
            });

            this._paths["filledEndpoints"] = this.graphie.style({
                stroke: color,
                strokeWidth: 3,
                fill: color
            }, function() {
                return self.graphie.plotEndpointCircles(filledEndpoints);
            });
        };

        this._plotSegments = function(color, plotDerivative) {
            var shiftedFnArray = this._shiftFnArray();
            if (plotDerivative) {
                shiftedFnArray = this.derivative(shiftedFnArray);
            }

            var plotArray = this._makePlotArray(shiftedFnArray);

            var self = this;
            this._paths["segments"] = this.graphie.style({
                stroke: color,
                strokeWidth: 3
            }, function() {
                return self.graphie.plotPiecewise(plotArray, self.rangeArray);
            });
        };

        this.plot = function(options) {
            options = $.extend(true, {
                color: KhanUtil.GREEN,
                plotDerivative: false,
                omitEnds: false
            }, options);

            this.graphie = options.graphie || KhanUtil.currentGraph;

            // plot segments
            this._plotSegments(options.color, options.plotDerivative);

            // plot endpoints
            this._plotEndpoints(options.color, options.plotDerivative, options.omitEnds);
        };

        this.translatePlot = function(dx, dy) {
            var scaled = this.graphie.scaleVector([dx, dy]);
            _.each(this._paths, function(pathSet) {
                pathSet.translate(scaled[0], scaled[1]);
            });
        };

        // simply changes the opacity of the segment and endpoint paths so
        // they aren't visible
        this.hide = function(speed) {
            if (this.hidden) {
                return;
            }

            speed = speed || 100;

            _.each(this._paths, function(pathSet) {
                if (pathSet.length === 0) {
                    return;
                }
                pathSet.animate({
                    "fill-opacity": 0,
                    "opacity": 0
                }, speed);
            });

            this.hidden = true;
        };

        // make paths visible again
        this.show = function(speed) {
            if (!this.hidden) {
                return;
            }

            speed = speed || 100;

            _.each(this._paths, function(pathSet) {
                if (pathSet.length === 0) {
                    return;
                }
                pathSet.animate({
                    "fill-opacity": 1,
                    "opacity": 1
                }, speed);
            });

            this.hidden = false;
        };

        this.toFront = function() {
            _.each(this._paths, function(pathSet) {
                pathSet.toFront();
            });
        };

        this.cleanup = function() {
            _.each(this._paths, function(pathSet) {
                pathSet.remove();
            });
            this._paths = {};
        };
    },

    PiecewiseFunctionGenerator: {

        _init: (function() {
            _.bindAll(KhanUtil.PiecewiseFunctionGenerator);
        })(),

        // UTILITY FUNCTIONS
        _isInRange: function(ylims, val) {
            return !(val <= ylims[0] || val >= ylims[1]);
        },

        // create an n-length array
        _scramble: function(n) {
            var newIndices = [];
            _.times(n, function(i) {
                var newIndex = KhanUtil.randRangeExclude(0, n - 1, newIndices);
                newIndices.push(newIndex);
            });
            return newIndices;
        },

        // add new piecewise functions here
        curveTypes: {
            "line": {
                // slopes
                params: {
                    m: [-1, -0.5, 0, 0.5, 1]
                },
                // convert from f(x) = m(x - a) + b
                // to f(x) = Ax + B
                // return [B, A]
                generate: function(m, b) {
                    var coefs = [b, m];
                    return new KhanUtil.Polynomial(0, 1, coefs);
                }
            },
            "curve": {
                params: {
                    isLeftCurve: [true, false],
                    m: [-1, 1]
                },
                // convert from f(x) = m(x - a)^2 + b
                // to f(x) = Ax^2 + Bx + C
                // return [C, B, A]
                generate: function(isLeftCurve, m, b, intervalWidth) {
                    b = isLeftCurve ? b - m * intervalWidth : b;
                    var a = isLeftCurve ? intervalWidth : 0;
                    m = m / intervalWidth;
                    var coefs = [Math.pow(a, 2) * m + b, -2 * a * m, m];
                    return new KhanUtil.Polynomial(0, 2, coefs);
                }
            }
        },

        // converts curveTypes into an array of options used in the
        // recursive generator function
        makeCombinations: function() {

            // [[1,2,3], ["one", "two", "three"], ["a", "b", "c"]];
            var makeParamSets = function(curveTypes) {
                var paramSets = [];

                _.each(curveTypes, function(curveType, key) {
                    // since key is a string, it needs to be wrapped in
                    // an array
                    var paramSet = [[key]];
                    _.each(curveType.params, function(val) {
                        paramSet.push(val);
                    });
                    paramSets.push(paramSet);
                });

                return paramSets;
            };

            var addParam = function(currList, paramSet, paramIndex) {
                if (paramIndex === paramSet.length) {
                    combinations.push(currList);
                    return;
                }

                var params = paramSet[paramIndex];

                for (var i = 0; i < params.length; i++) {
                    currList.push(params[i]);
                    addParam(currList.slice(), paramSet, paramIndex + 1);
                    currList.pop();
                }
            };

            var makeCombinations = function() {
                var paramSets = makeParamSets(self.curveTypes);
                _.each(paramSets, function(paramSet) {
                    addParam([], paramSet, 0);
                });
            };

            // POSSIBLE TODO(stephanie): make combinations not a global variable
            var self = this;
            var combinations = [];
            makeCombinations();

            return combinations;
        },

        _randomY: function(ylims, excludes) {
            return KhanUtil.randRangeExclude(ylims[0], ylims[1], ylims.concat(excludes));
        },

        generate: function(options) {
            options = $.extend(true, {
                INTERVAL_WIDTH: 2,
                YLIMS: [],
                numSegments: 1,
                startVal: null, // overrides prevSegment start val
                prevSegment: null,
                breakIndex: null
            }, options);

            if (!this.combinations) {
                this.combinations = this.makeCombinations();
            }

            var self = this;
            var YLIMS = options.YLIMS;
            var INTERVAL_WIDTH = options.INTERVAL_WIDTH;

            var endVal = function(segment) {
                return segment.evalOf(options.INTERVAL_WIDTH);
            };

            // start the segment at startVal
            var createSegment = function(startVal, prevSegment) {
                // POSSIBLE TODO(stephanie): add weights to the combinations

                if (startVal == null) {
                    if (prevSegment == null) {
                        startVal = self._randomY(YLIMS);
                    } else {
                        startVal = endVal(prevSegment);
                    }
                }

                // iterate through combinations in a random order each time
                var indices = self._scramble(self.combinations.length);

                for (var j = 0; j < indices.length; j++) {
                    var params = self.combinations[indices[j]].slice();

                    var curveType = self.curveTypes[params[0]];

                    // add the value of "b" to the params array
                    params.push(startVal);
                    params.push(INTERVAL_WIDTH);

                    var segment = curveType["generate"].apply(null, params.slice(1));

                    var y = endVal(segment);

                    // segment is not qualified if it causes the graph to go
                    // outside the y limits
                    if (!self._isInRange(YLIMS, y)) {
                        continue;
                    }

                    // segment is not allowed to have the same params as
                    // the previous one
                    if (prevSegment) {
                        var y0 = prevSegment.evalOf(0);
                        var s0 = prevSegment.subtract(y0).text();
                        var s1 = segment.subtract(startVal).text();
                        if (s0 === s1) {
                            continue;
                        }
                    }

                    // POSSIBLE TODO(stephanie): check for other constraints here
                    return segment;
                }
                return null;
            };

            var makePiecewiseGraph = function() {
                var segments = [];
                var start = options.startVal;
                var prev = options.prevSegment;

                while (segments.length < options.numSegments) {
                    var len = segments.length;
                    if (options.breakIndex && len === options.breakIndex) {
                        start = self._randomY(YLIMS, [start]);
                    }

                    var segment = createSegment(start, prev);

                    // no possible problem with these starting segments,
                    // so start over completely
                    if (!segment) {
                        segments = [];
                        prev = options.prevSegment;
                        start = options.startVal;
                    }

                    segments.push(segment);
                    prev = segment;
                    start = null;
                }

                return segments;
            };

            var fnArray = makePiecewiseGraph();

            var rangeArray = [];
            _.each(fnArray, function(fn, i) {
                var x = i * options.INTERVAL_WIDTH;
                rangeArray.push([x, x + options.INTERVAL_WIDTH]);
            });

            return new KhanUtil.PiecewiseFunction({
                fnArray: fnArray,
                rangeArray: rangeArray
            });
        }
    },

    VisualizingDerivativesProblem: function(options) {
        options = $.extend(true, {
            XLIMS: [0, 14],
            YLIMS: [-2, 4],
            GRAPH_LIMS: [[], []],
            INTERVAL_WIDTH: 2,

            problem: null,
            graph: null,

            nIntervals: 7,
            nProblemIntervals: 1,
            offset: 0.5,
            breakIndex: 3,
            noSolution: false,
            moveDerivative: true,

            fnColor: KhanUtil.BLUE,
            derivColor: KhanUtil.RED

        }, options);

        $.extend(this, options);

        this._setAxisLims = function() {
            var width = this.INTERVAL_WIDTH;
            var n = this.nIntervals;
            this.XLIMS = [0, width * n];
            this.YLIMS = [-width, 2 * width];

            var pad = function(lims, padAmt) {
                return [lims[0] - padAmt, lims[1] + padAmt];
            };

            this.GRAPH_LIMS = [pad(this.XLIMS, width), pad(this.YLIMS, 1)];
        };

        this._invalidParams = function(piecewiseFn, startIndex, nIntervals) {
            var outOfBounds = startIndex + nIntervals > piecewiseFn.length();
            if (!piecewiseFn || startIndex === null ||
                nIntervals === 0 || outOfBounds) {
                return true;
            }
            return false;
        };

        this.chooseProblemStart = function(totalIntervals, nIntervals, offset) {
            var upperBound = totalIntervals - (nIntervals + Math.ceil(offset));
            return KhanUtil.randRange(0, upperBound);
        };

        this.matchesToProblemRanges = function(matches, nIntervals, offset) {
            var w = this.INTERVAL_WIDTH;
            return _.map(matches, function(matchIndex) {
                var startIndex = matchIndex + offset;
                var endIndex = startIndex + nIntervals;
                return _.map([startIndex, endIndex], function(x) {
                    return w * x;
                });
            });
        };

        this.generateProblem = function(piecewiseFn, startIndex, nIntervals, offset) {
            // we need one more interval if there's an offset
            nIntervals += (offset === 0) ? 0 : 1;

            if (this._invalidParams(piecewiseFn, startIndex, nIntervals)) {
                return null;
            }

            var endIndex = startIndex + nIntervals;
            var problem = piecewiseFn.slice(startIndex, endIndex);

            // we need to trim the rangeArray if there's an offset
            problem.trimRangeArrayEnds(offset);

            return problem;
        };

        this.generateBogusProblem = function(piecewiseFn, startIndex, nIntervals, offset) {
            // we need one more interval if there's an offset
            nIntervals += (offset === 0) ? 0 : 1;

            if (this._invalidParams(piecewiseFn, startIndex, nIntervals)) {
                return null;
            }

            var generator = KhanUtil.PiecewiseFunctionGenerator;
            var bogusProblem;

            var loopCount = 0;

            var validBogus = false;
            while (!validBogus) {
                // only one interval, so it must be bogus/invalid
                if (nIntervals === 1) {
                    bogusProblem = generator.generate({
                        nIntervals: 1,
                        INTERVAL_WIDTH: this.INTERVAL_WIDTH,
                        YLIMS: this.YLIMS
                    });

                } else {
                    // as few as 1 and as many as all but one interval can be
                    // valid
                    var nValidIntervals = KhanUtil.randRange(1, nIntervals - 1);

                    // the rest of the intervals are bogus
                    var nBogusIntervals = nIntervals - nValidIntervals;

                    var endIndex = startIndex + nValidIntervals;
                    var prefixFn = piecewiseFn.slice(startIndex, endIndex);

                    var n = prefixFn.length();
                    var prevSegment = prefixFn.fnArray[n - 1];

                    bogusProblem = generator.generate({
                        numSegments: nBogusIntervals,
                        prevSegment: prevSegment,
                        INTERVAL_WIDTH: this.INTERVAL_WIDTH,
                        YLIMS: this.YLIMS
                    });

                    bogusProblem = prefixFn.concat(bogusProblem);
                }

                var matches = piecewiseFn.matches(bogusProblem, true);
                if (!matches.length) {
                    validBogus = true;
                }

                // if we can't find a valid bogus in a reasonable # of tries,
                // quit and generate a new problem. 50 is an arbitrary
                // threshold.
                if (loopCount > 50) {
                    return null;
                }

                loopCount++;
            }

            // we need to trim the rangeArray if there's an offset
            bogusProblem.trimRangeArrayEnds(offset);

            return bogusProblem;
        };

        this.initSlidingWindow = function(options) {
            this.graphie.addMouseLayer();

            var problem = options.problem;

            // compute lims
            var xlims = this.GRAPH_LIMS[0];
            var ylims = this.GRAPH_LIMS[1];

            // window cannot move past (the edges of the graph area - 1)
            var xmin = xlims[0] + 1;
            var xmax = xlims[1] - 1;

            // window extends to the top and bottom edges of the graph area
            var ymin = ylims[0];
            var ymax = ylims[1];
            var height = ymax - ymin;

            var slidingWindow = this.graphie.addRectGraph({
                x: xmin,
                y: ymin,
                width: problem.width(),
                height: height,
                normalStyle: {
                    area: {
                        "fill-opacity": 0.08,
                        fill: options.color
                    },
                    edges: {
                        "stroke-width": 0
                    },
                    points: {
                        opacity: 0
                    }
                },
                hoverStyle: {
                    area: {
                        "fill-opacity": 0.14,
                        fill: options.color
                    },
                    points: {
                        opacity: 0
                    }
                },
                fixed: {
                    edges: [true, true, true, true],
                    points: [true, true, true, true]
                },
                constraints: {
                    constrainX: false,
                    constrainY: true,
                    xmin: xmin,
                    xmax: xmax
                },
                onMove: function(dx, dy) {
                    problem.translatePlot(dx, dy);
                    problem.toFront();
                },
                snapX: 1
            });

            // number of milliseconds it takes the slidingWindow to fade in/out
            var speed = 20;

            slidingWindow.doHide = function() {
                slidingWindow.hide(speed);
                problem.hide(speed);
                options.onHide();
            };

            slidingWindow.doShow = function() {
                slidingWindow.show(speed);
                problem.show(speed);
                options.onShow();
            };

            // problem graph should be in front of sliding window
            slidingWindow.toFront();
            problem.toFront();

            var xOffset = xmin + -problem.rangeArray[0][0];
            problem.translatePlot(xOffset, 0);

            slidingWindow.startRange = [xmin, xmin + problem.width()];

            // attach sliding window to this object
            this.slidingWindow = slidingWindow;
        };

        this.init = function() {
            var generator = KhanUtil.PiecewiseFunctionGenerator;

            // SET AXIS LIMS
            this._setAxisLims();

            // MAKE BASE GRAPH
            this.graph = generator.generate({
                numSegments: this.nIntervals,
                breakIndex: this.breakIndex,
                INTERVAL_WIDTH: this.INTERVAL_WIDTH,
                YLIMS: this.YLIMS
            });

            // MAKE PROBLEM
            var n = this.nProblemIntervals;
            var offset = this.offset;
            var start = this.chooseProblemStart(this.graph.length(), n, offset);

            if (this.noSolution) {
                this.problem = this.generateBogusProblem(this.graph, start, n, offset);

                // if a valid bogus problem could not be generated for this
                // initial graph, just start all over again
                if (this.problem === null) {
                    this.init();
                    return;
                }

            } else {
                this.problem = this.generateProblem(this.graph, start, n, offset);
            }

            // FIND MATCHES
            var matches = this.graph.matches(this.problem, true);
            this.problemRanges = this.matchesToProblemRanges(matches, n, offset);
        };

        // TODO(stephanie) LATER: refactor this and initAutoscaledGraph in
        // derivative intuition
        var initRectAutoscaledGraph = function(range, options) {
            var graph = KhanUtil.currentGraph;

            var xlims = range[0];
            var ylims = range[1];

            var xrange = xlims[1] - xlims[0];
            var yrange = ylims[1] - ylims[0];

            var xpixels = 480;

            options = $.extend({
                tickOpacity: 0.6,
                labelOpacity: 0.6,
                xpixels: xpixels,
                ypixels: xpixels * yrange / xrange,
                xdivisions: xrange,
                ydivisions: yrange,
                labels: true,
                unityLabels: true,
                range: (typeof range === "undefined" ? [[-10, 10], [-10, 10]] : range)
            }, options);

            options.scale = [options.xpixels / xrange,
                             options.ypixels / yrange];
            options.gridStep = [xrange / options.xdivisions,
                                yrange / options.ydivisions];

            // Attach the resulting metrics to the graph for later reference
            graph.xpixels = options.xpixels;
            graph.ypixels = options.ypixels;
            graph.range = options.range;
            graph.scale = options.scale;

            graph.graphInit(options);
        };

        this.render = function(options) {

            // PLOT BASE GRAPH AND PROBLEM GRAPH
            initRectAutoscaledGraph(this.GRAPH_LIMS, {});

            // store current graph for use by resetCurrentGraph()
            this.graphie = KhanUtil.currentGraph;

            var windowColor = this.derivColor;
            if (this.moveDerivative) {
                this.graph.plot({
                    color: this.fnColor,
                    graphie: this.graphie
                });
                this.problem.plot({
                    color: this.derivColor,
                    plotDerivative: true,
                    omitEnds: false,
                    graphie: this.graphie
                });
            } else {
                this.graph.plot({
                    color: this.derivColor,
                    plotDerivative: true,
                    graphie: this.graphie
                });
                this.problem.plot({
                    color: this.fnColor,
                    omitEnds: true,
                    graphie: this.graphie
                });
                windowColor = this.fnColor;
            }

            // CREATE SLIDING WINDOW
            var checkboxIdentifier = ".sol.no-solution :checkbox";
            this.initSlidingWindow({
                problem: this.problem,
                color: windowColor,
                onHide: function() {
                    $(checkboxIdentifier).attr("checked", true);
                },
                onShow: function() {
                    $(checkboxIdentifier).attr("checked", false);
                }
            });

            // when user clicks "no solution", hide the sliding window
            this.bindNoSolutionHide(checkboxIdentifier);

            return this.slidingWindow;
        };

        // after displaying hint, reset KhanUtil.currentGraph to graphie
        // element containing the problem graph to solve bug whereby the
        // movable window is less responsive after hint graphs are added to
        // the page
        this.resetCurrentGraph = function() {
            KhanUtil.currentGraph = this.graphie;
        };

        this.hints = function() {
            var hints = [];

            this.hintproblems = [];

            var moveDeriv = this.moveDerivative;

            var self = this;
            _.each(this.problem.fnArray, function(fn, i) {
                var nth = i > 0 ?
                    $._("next") :
                    $._("first");

                fn = fn.derivative();

                var nCoefs = fn.coefs.length;
                var hint;
                if (nCoefs === 1) {
                    var val = "<code>" + fn.coefs[0] + "</code>";
                    if (moveDeriv) {
                        hint = $._("The %(nth)s section of the derivative has a constant " +
                            "value of %(val)s, so it corresponds to an original function with " +
                            "a constant <b>slope</b> of %(val)s.", {nth: nth, val: val});
                    } else {
                        hint = $._("The %(nth)s section of the antiderivative has a constant " +
                            "slope of %(val)s, so it corresponds to an original function " +
                            "that has a constant value of %(val)s.", {nth: nth, val: val});
                    }
                } else if (nCoefs === 2) {
                    var inc;
                    var val = fn.evalOf(0) + fn.evalOf(self.INTERVAL_WIDTH);
                    if (val >= 0) {
                        if (fn.coefs[1] > 0) {
                            inc = $._("increasing and positive");
                        } else {
                            inc = $._("decreasing and positive");
                        }
                    } else {
                        if (fn.coefs[1] > 0) {
                            inc = $._("increasing and negative");
                        } else {
                            inc = $._("decreasing and negative");
                        }
                    }

                    if (moveDeriv) {
                        hint = $._("The %(nth)s section of the derivative is %(inc)s, " +
                            "so it corresponds to an original function whose " +
                            "<b>slope</b> is %(inc)s.", {nth: nth, inc: inc});
                    } else {
                        hint = $._("The %(nth)s section of the antiderivative has a " +
                            "%(inc)s slope, so it corresponds to an original " +
                            "function that is %(inc)s.", {nth: nth, inc: inc});
                    }
                }


                var hintproblem = self.problem.slice(i, i + 1);
                hintproblem.calibrate();
                self.hintproblems.push(hintproblem);

                hints.push("<p>" + hint + "</p><div class='clearfix'> <div class='graphie vis-deriv-hint-graph' id='orig" + i + "'>   PROBLEM.showHint(" + i + ", " + moveDeriv + ");</div>" +
                    "<div class='graphie vis-deriv-hint-graph' id='orig" + i + "'> PROBLEM.showHint(" + i + ", " + !moveDeriv + ");</div> </div>");
            });

            var lastHint;
            if (this.noSolution) {
                lastHint = $._("Because these sections do not appear next " +
                    "to each other in the graph of <code>f(x)</code>, " +
                    "there is no solution.");
                hints.push("<p>" + lastHint + "</p>");
                hints.push("<div class='graphie'> PROBLEM.showNoAnswer(); </div>");
            } else {
                var solnText = this.problemRanges.map(function(range) {
                                return "<code>x \\in [" + range.join(", ") + "]</code>";
                            }).join(" and ");
                var fnVar = moveDeriv ? "f'(x)" : "F(x)";
                lastHint = $._("The function in the window corresponds to " +
                    "<code>%(fnVar)s</code> where %(solution)s.",
                    {fnVar: fnVar, solution: solnText});

                var firstAnswer = this.problemRanges[0][0];
                hints.push("<p>" + lastHint + "</p>");
                hints.push("<div class='graphie'> PROBLEM.showAnswer(" + firstAnswer + "); </div>");
            }

            return hints;
        };

        // TODO(stephanie) LATER: refactor this and initAutoscaledGraph in
        // derivative intuition
        var initHintGraph = function(range, options) {
            var graph = KhanUtil.currentGraph;

            var xlims = range[0];
            var ylims = range[1];

            var xrange = xlims[1] - xlims[0];
            var yrange = ylims[1] - ylims[0];

            var xpixels = 480 / 18 * Math.abs(range[0][1] - range[0][0]);

            options = $.extend({
                xpixels: xpixels,
                ypixels: xpixels * yrange / xrange,
                xdivisions: xrange,
                ydivisions: yrange,
                labels: true,
                unityLabels: true,
                range: range
            }, options);

            options.scale = [options.xpixels / xrange,
                             options.ypixels / yrange];
            options.gridStep = [xrange / options.xdivisions,
                                yrange / options.ydivisions];

            // Attach the resulting metrics to the graph for later reference
            graph.xpixels = options.xpixels;
            graph.ypixels = options.ypixels;
            graph.range = options.range;
            graph.scale = options.scale;

            graph.graphInit(options);

            return graph;
        };

        this.showHint = function(i, deriv) {

            var segment = this.hintproblems[i];
            var hintGraphie;
            if (deriv) {
                hintGraphie = initHintGraph([[1, 5], [-3, 3]], {
                    axisOpacity: 1,
                    labelOpacity: 0.01,
                    tickOpacity: 0.01
                });
                segment.plot({
                    color: this.derivColor,
                    plotDerivative: true,
                    omitEnds: false,
                    graphie: hintGraphie
                });
            } else {
                hintGraphie = initHintGraph([[1, 5], [-3, 3]], {
                    axisOpacity: 0.01,
                    labelOpacity: 0.01,
                    tickOpacity: 0.01
                });
                segment.plot({
                    color: this.fnColor,
                    omitEnds: true,
                    graphie: hintGraphie
                });
            }

            this.resetCurrentGraph();
        };

        this.showAnswer = function(firstAnswer) {
            this.slidingWindow.doShow();
            this.slidingWindow.moveTo(firstAnswer, 0);
            this.resetCurrentGraph();
        };

        this.showNoAnswer = function() {
            this.slidingWindow.doHide();
            this.resetCurrentGraph();
        };

        // hide sliding window if "no solution" is selected
        this.bindNoSolutionHide = function(checkboxIdentifier) {
            var slidingHidden = false;
            var sliding = this.slidingWindow;
            $("body").on("click", checkboxIdentifier, function() {
                slidingHidden = !slidingHidden;
                // just switched to being hidden
                if (slidingHidden) {
                    sliding.doHide();
                } else {
                    sliding.doShow();
                }
            });
        };

        this.init();
    }
});

});

define('utils/word-problems.js',['require','./math.js'],function(require) {

require("./math.js");

// Example usage:
// <var>person(1)</var> traveled 5 mi by <var>vehicle(1)</var>. Let
// <var>his(1)</var> average speed be <var>personVar(1)</var>.
// Let <var>person(2)</var>'s speed be <var>personVar(2)</var>.
//
// Note that initials (-Var) are guaranteed to be unique in each category,
// but not across them.

$.extend(KhanUtil, {
    // TODO(csilvers): I18N: rename serialCommafy and copy from webapp.
    toSentence: function(items) {
        var n = items.length;

        // This seems to be a pretty l10n-aware, actually.  cf.
        //    http://comments.gmane.org/gmane.comp.audio.musicbrainz.i18n/15
        // The only possible problem is chinese, which it looks like
        // prefers a special character to the comma, which we hard-code in
        // items_with_commas.
        if (n === 0) {
            return "";
        } else if (n === 1) {
            return items[0];
        } else if (n === 2) {
            return $._("%(item1)s and %(item2)s",
                       {item1: items[0], item2: items[1]});
        } else {
            return $._("%(items_with_commas)s, and %(last_item)s",
                       {items_with_commas: items.slice(0, n - 1).join(", "),
                        last_item: items[n - 1]});
        }
    },

    toSentenceTex: function(array, highlight, highlightClass) {
        var wrapped = $.map(array, function(elem) {
            if ((_.isFunction(highlight) && highlight(elem)) || (highlight !== undefined && elem === highlight)) {
                return "<code class='" + highlightClass + "'>" + elem + "</code>";
            }
            return "<code>" + elem + "</code>";
        });
        return KhanUtil.toSentence(wrapped);
    },

    capitalize: function(str) {
        return str.charAt(0).toUpperCase() + str.slice(1);
    },

    AMBIGUOUS_PLURAL: function(word, num) {
        if (typeof console !== "undefined" && console.error) {
            console.error("Ambiguous plural variable usage: ", String(word));
        }

        KhanUtil.debugLog("ERROR: Ambiguous plural variable usage: " +
            String(word));

        // Check if the word is pluralizable
        var plural_word = word && word.plural ?
            word.plural(num) :
            (num == null ? this.plural(word) : this.plural(word, num));

        return "<span class='error'>" + plural_word + "</span>";
    },

    plural_form: function(word, num) {
        // Check if the word is pluralizable
        if (word && word.plural) {
            return word.plural(num);
        }

        if (typeof console !== "undefined" && console.error) {
            console.error("Word not in plural dictionary: ", String(word));
        }

        KhanUtil.debugLog("ERROR: Word not in plural dictionary: " +
            String(word));

        return "<span class='error'>" +
            (num == null ? this.plural(word) : this.plural(word, num)) +
            "</span>";
    },

    isSingular: function(num) {
        return num === 1;
    },

    // DEPRECATED
    // pluralization helper.  There are two signatures
    // - plural(NUMBER, singular):
    //        - if necessary, magically pluralize <singular>
    //        - return "NUMBER word"
    // - plural(NUMBER, singular, plural):
    //        - return "NUMBER word"
    // - plural(singular, NUMBER):
    //        - if necessary, magically pluralize <singular>
    //        - return "word"
    // - plural(singular, plural, NUMBER):
    //        - return "word"
    plural: (function() {
        var oneOffs = {
            "quiz": "quizzes",
            "shelf": "shelves",
            "loaf": "loaves",
            "potato": "potatoes",
            "person": "people",
            "is": "are",
            "was": "were",
            "foot": "feet",
            "square foot": "square feet",
            "tomato": "tomatoes"
        };

        var pluralizeWord = function(word) {

            // Check if this is a new Plural object, and just use that plural
            if (word && word.plural) {
                return word.plural(2);
            }

            // noone really needs extra spaces at the edges, do they?
            word = $.trim(word);

            // determine if our word is all caps.  If so, we'll need to
            // re-capitalize at the end
            var isUpperCase = (word.toUpperCase() === word);
            var oneOff = oneOffs[word.toLowerCase()];
            var words = word.split(/\s+/);

            // first handle simple one-offs
            // ({}).watch is a function in Firefox, blargh
            if (typeof oneOff === "string") {
                return oneOff;
            }

            // multiple words
            else if (words.length > 1) {
                // for 3-word phrases where the middle word is 'in' or 'of',
                // pluralize the first word
                if (words.length === 3 && /\b(in|of)\b/i.test(words[1])) {
                    words[0] = KhanUtil.plural(words[0]);
                }

                // otherwise, just pluraize the last word
                else {
                    words[words.length - 1] =
                        KhanUtil.plural(words[words.length - 1]);
                }

                return words.join(" ");
            }

            // single words
            else {
                // "-y" => "-ies"
                if (/[^aeiou]y$/i.test(word)) {
                    word = word.replace(/y$/i, "ies");
                }

                // add "es"; things like "fish" => "fishes"
                else if (/[sxz]$/i.test(word) || /[bcfhjlmnqsvwxyz]h$/.test(word)) {
                    word += "es";
                }

                // all the rest, just add "s"
                else {
                    word += "s";
                }

                if (isUpperCase) {
                    word = word.toUpperCase();
                }
                return word;
            }
        };

        return function(value, arg1, arg2) {
            if (typeof value === "number") {
                var usePlural = (value !== 1);

                // if no extra args, just add "s" (if plural)
                if (arguments.length === 1) {
                    return usePlural ? "s" : "";
                }

                if (usePlural) {
                    arg1 = arg2 || pluralizeWord(arg1);
                }

                return value + " " + arg1;
            } else if (typeof value === "string" || typeof value === "object") {
                // We need to accept objects here as well for new Plural objects
                var plural = pluralizeWord(value);
                if (typeof arg1 === "string" && arguments.length === 3) {
                    plural = arg1;
                    arg1 = arg2;
                }
                var usePlural = (arguments.length < 2 || (typeof arg1 === "number" && arg1 !== 1));
                return usePlural ? plural : value;
            }
        };
    })()
});

var Plural = KhanUtil.Plural = function(plural_fn) {
    this.plural_fn = plural_fn;
};

KhanUtil.Plural.prototype = {
    plural: function(num) {
        // There are some cases where plural is called with only a word
        // (and no number). In this case we just want to return the plural
        // form of that word, as best as we can. This might have some slight
        // incongruities across platforms
        num = num === undefined ? 2 : num;

        return this.plural_fn(num);
    },

    toString: function() {
        return this.plural_fn(1);
    }
};

KhanUtil.numberPlaceNames = [
    new Plural(function(num) {
        return $.ngettext("one", "ones", num);
    }),
    new Plural(function(num) {
        return $.ngettext("ten", "tens", num);
    }),
    new Plural(function(num) {
        return $.ngettext("hundred", "hundreds", num);
    }),
    new Plural(function(num) {
        return $.ngettext("thousand", "thousands", num);
    }),
    new Plural(function(num) {
        return $.ngettext("ten thousand", "ten thousands", num);
    })
];

KhanUtil.decimalPlaceNames = [
    new Plural(function(num) {
        return $.ngettext("one", "ones", num);
    }),
    new Plural(function(num) {
        return $.ngettext("tenth", "tenths", num);
    }),
    new Plural(function(num) {
        return $.ngettext("hundredth", "hundredths", num);
    }),
    new Plural(function(num) {
        return $.ngettext("thousandth", "thousandths", num);
    }),
    new Plural(function(num) {
        return $.ngettext("ten thousandth", "ten thousandths", num);
    })
];

KhanUtil.metricUnits = [
    [$._("m"), new Plural(function(num) {
        return $.ngettext("meter", "meters", num);
    })],
    [$._("cm"), new Plural(function(num) {
        return $.ngettext("centimeter", "centimeters", num);
    })]
];

KhanUtil.imperialUnits = [
    ["in", new Plural(function(num) {
        return $.ngettext("inch", "inches", num);
    })],
    ["ft", new Plural(function(num) {
        return $.ngettext("foot", "feet", num);
    })]
];

KhanUtil.genericUnit = ["", new Plural(function(num) {
    return $.ngettext("unit", "units", num);
})];

$.fn["word-problemsLoad"] = function() {

    var IncrementalShuffler = function(array) {
        // Shuffle an array incrementally so we only use as many random calls
        // as we need, so names can be added/removed without breaking all
        // random seeds for all word problems
        // - get(0); get(0); will use only one call
        // - get(0); get(1); will have each use one random call
        // - get(1); get(0); will use two random calls then none and each call
        //   will give the same result as running 0 then 1
        array = [].slice.call(array, 0);
        var shuffled = 0;

        this.get = function(i) {
            if (i < 0 || i >= array.length) {
                return undefined;
            }

            while (shuffled <= i) {
                var top = array.length - shuffled,
                    newEnd = Math.floor(KhanUtil.random() * top),
                    tmp = array[newEnd];

                array[newEnd] = array[top - 1];
                array[top - 1] = tmp;
                shuffled++;
            }

            // Since we shuffle items from the end to the front, return the
            // items in reverse order
            return array[array.length - i - 1];
        };
    };

    var names = [
        // I18N: Female name
        [$._("Ashley"), "f"],
        // I18N: Male name
        [$._("Brandon"), "m"],
        // I18N: Male name
        [$._("Ben"), "m"],
        // I18N: Male name
        [$._("Christopher"), "m"],
        // I18N: Male name
        [$._("Daniel"), "m"],
        // I18N: Female name
        [$._("Emily"), "f"],
        // I18N: Female name
        [$._("Gabriela"), "f"],
        // I18N: Male name
        [$._("Ishaan"), "m"],
        // I18N: Female name
        [$._("Jessica"), "f"],
        // I18N: Male name
        [$._("Kevin"), "m"],
        // I18N: Male name
        [$._("Luis"), "m"],
        // I18N: Male name
        [$._("Michael"), "m"],
        // I18N: Female name
        [$._("Nadia"), "f"],
        // I18N: Male name
        [$._("Omar"), "m"],
        // I18N: Female name
        [$._("Stephanie"), "f"],
        // I18N: Female name
        [$._("Tiffany"), "f"],
        // I18N: Female name
        [$._("Umaima"), "f"],
        // I18N: Female name
        [$._("Vanessa"), "f"],
        // I18N: Male name
        [$._("William"), "m"]
    ];

    // We only want one name per letter of the alphabet, so group people with
    // the same initial before shuffling the names up
    var people = _.map(_.groupBy(names, function(name) {
        return name[0].charAt(0);
    }), function(group) {
        return new IncrementalShuffler(group);
    });
    people = new IncrementalShuffler(people);

    // NOTE(jeresig): I18N: These strings are expected to work prefixed with
    // just the letter "A", as in "A gorilla"
    var vehicles = new IncrementalShuffler([
        new Plural(function(num) {
            return $.ngettext("bike", "bikes", num);
        }),
        new Plural(function(num) {
            return $.ngettext("car", "cars", num);
        }),
        new Plural(function(num) {
            return $.ngettext("horse", "horses", num);
        }),
        new Plural(function(num) {
            return $.ngettext("motorcycle", "motorcycles", num);
        }),
        new Plural(function(num) {
            return $.ngettext("scooter", "scooters", num);
        }),
        new Plural(function(num) {
            return $.ngettext("train", "trains", num);
        })
    ]);

    // NOTE(jeresig): I18N: These strings are expected to work prefixed with
    // just the letter "A", as in "A gorilla"
    var courses = new IncrementalShuffler([
        $._("chemistry"),
        $._("geometry"),
        $._("history"),
        $._("math"),
        $._("physics"),
        $._("language")
    ]);

    var exams = new IncrementalShuffler([
        new Plural(function(num) {
            return $.ngettext("exam", "exams", num);
        }),
        new Plural(function(num) {
            return $.ngettext("test", "tests", num);
        }),
        new Plural(function(num) {
            return $.ngettext("quiz", "quizzes", num);
        })
    ]);

    var binops = new IncrementalShuffler([
        "\\barwedge",
        "\\veebar",
        "\\odot",
        "\\oplus",
        "\\otimes",
        "\\oslash",
        "\\circledcirc",
        "\\boxdot",
        "\\bigtriangleup",
        "\\bigtriangledown",
        "\\dagger",
        "\\diamond",
        "\\star",
        "\\triangleleft",
        "\\triangleright"
    ]);

    var collections = new IncrementalShuffler([
        [new Plural(function(num) {
            return $.ngettext("party favor", "party favors", num);
        }), new Plural(function(num) {
            return $.ngettext("bag", "bags", num);
        })],
        [new Plural(function(num) {
            return $.ngettext("jelly bean", "jelly beans", num);
        }), new Plural(function(num) {
            return $.ngettext("bag", "bags", num);
        })],
        [new Plural(function(num) {
            return $.ngettext("book", "books", num);
        }), new Plural(function(num) {
            return $.ngettext("shelf", "shelves", num);
        })],
        [new Plural(function(num) {
            return $.ngettext("can of food", "cans of food", num);
        }), new Plural(function(num) {
            return $.ngettext("box", "boxes", num);
        })]
    ]);

    // NOTE(jeresig): I18N: These strings are expected to work prefixed with
    // just the letter "A", as in "A gorilla"
    var stores = new IncrementalShuffler([
        {
            name: new Plural(function(num) {
                return $.ngettext("hardware", "hardwares", num);
            }),
            items: new IncrementalShuffler([
                new Plural(function(num) {
                    return $.ngettext("hammer", "hammers", num);
                }),
                new Plural(function(num) {
                    return $.ngettext("nail", "nails", num);
                }),
                new Plural(function(num) {
                    return $.ngettext("saw", "saws", num);
                })
            ])
        },
        {
            name: new Plural(function(num) {
                return $.ngettext("grocery", "groceries", num);
            }),
            items: new IncrementalShuffler([
                new Plural(function(num) {
                    return $.ngettext("banana", "bananas", num);
                }),
                new Plural(function(num) {
                    return $.ngettext("loaf of bread", "loaves of bread", num);
                }),
                new Plural(function(num) {
                    return $.ngettext("liter of milk", "liters of milk", num);
                }),
                new Plural(function(num) {
                    return $.ngettext("potato", "potatoes", num);
                })
            ])
        },
        {
            name: new Plural(function(num) {
                return $.ngettext("gift", "gifts", num);
            }),
            items: new IncrementalShuffler([
                new Plural(function(num) {
                    return $.ngettext("toy", "toys", num);
                }),
                new Plural(function(num) {
                    return $.ngettext("game", "games", num);
                }),
                new Plural(function(num) {
                    return $.ngettext("souvenir", "souvenirs", num);
                })
            ])
        },
        {
            name: new Plural(function(num) {
                return $.ngettext("school supply", "school supplies", num);
            }),
            items: new IncrementalShuffler([
                new Plural(function(num) {
                    return $.ngettext("pen", "pens", num);
                }),
                new Plural(function(num) {
                    return $.ngettext("pencil", "pencils", num);
                }),
                new Plural(function(num) {
                    return $.ngettext("notebook", "notebooks", num);
                })
            ])
        },
        {
            name: new Plural(function(num) {
                return $.ngettext("toy", "toys", num);
            }),
            items: new IncrementalShuffler([
                new Plural(function(num) {
                    return $.ngettext("stuffed animal", "stuffed animals", num);
                }),
                new Plural(function(num) {
                    return $.ngettext("video game", "video games", num);
                }),
                new Plural(function(num) {
                    return $.ngettext("race car", "race cars", num);
                }),
                new Plural(function(num) {
                    return $.ngettext("doll", "dolls", num);
                })
            ])
        }
    ]);

    var pizzas = new IncrementalShuffler([
        new Plural(function(num) {
            return $.ngettext("pizza", "pizzas", num);
        }),
        new Plural(function(num) {
            return $.ngettext("pie", "pies", num);
        }),
        new Plural(function(num) {
            return $.ngettext("cake", "cakes", num);
        })
    ]);

    var timesofday = new IncrementalShuffler([
        $._("in the morning"),
        $._("around noon"),
        $._("in the evening"),
        $._("at night")
    ]);

    var exercises = new IncrementalShuffler([
        new Plural(function(num) {
            return $.ngettext("push-up", "push-ups", num);
        }),
        new Plural(function(num) {
            return $.ngettext("sit-up", "sit-ups", num);
        }),
        new Plural(function(num) {
            return $.ngettext("squat", "squats", num);
        }),
        new Plural(function(num) {
            return $.ngettext("jumping jack", "jumping jacks", num);
        })
    ]);

    var fruits = new IncrementalShuffler([
        new Plural(function(num) {
            return $.ngettext("apple", "apples", num);
        }),
        new Plural(function(num) {
            return $.ngettext("banana", "bananas", num);
        }),
        new Plural(function(num) {
            return $.ngettext("coconut", "coconuts", num);
        }),
        new Plural(function(num) {
            return $.ngettext("eggplant", "eggplants", num);
        }),
        new Plural(function(num) {
            return $.ngettext("kiwi fruit", "kiwi fruit", num);
        }),
        new Plural(function(num) {
            return $.ngettext("lemon", "lemons", num);
        }),
        new Plural(function(num) {
            return $.ngettext("mango", "mangos", num);
        }),
        new Plural(function(num) {
            return $.ngettext("nectarine", "nectarines", num);
        }),
        new Plural(function(num) {
            return $.ngettext("orange", "oranges", num);
        }),
        new Plural(function(num) {
            return $.ngettext("pomegranate", "pomegranates", num);
        }),
        new Plural(function(num) {
            return $.ngettext("watermelon", "watermelons", num);
        })
    ]);

    var deskItems = new IncrementalShuffler([
        new Plural(function(num) {
            return $.ngettext("binder", "binders", num);
        }),
        new Plural(function(num) {
            return $.ngettext("crayon", "crayons", num);
        }),
        new Plural(function(num) {
            return $.ngettext("eraser", "erasers", num);
        }),
        new Plural(function(num) {
            return $.ngettext("folder", "folders", num);
        }),
        new Plural(function(num) {
            return $.ngettext("glue stick", "glue sticks", num);
        }),
        new Plural(function(num) {
            return $.ngettext("marker", "markers", num);
        }),
        new Plural(function(num) {
            return $.ngettext("notebook", "notebooks", num);
        }),
        new Plural(function(num) {
            return $.ngettext("pencil", "pencils", num);
        }),
        new Plural(function(num) {
            return $.ngettext("rubber stamp", "rubber stamps", num);
        })
    ]);

    // NOTE(jeresig): I18N: These strings are expected to work prefixed with
    // just the letter "A", as in "A gorilla"
    var colors = new IncrementalShuffler([
        $._("red"),
        // NOTE(jeresig): I18N: Removed because it begins with a vowel and is
        // used with an()
        //"orange",
        $._("yellow"),
        $._("green"),
        $._("blue"),
        $._("purple"),
        $._("white"),
        $._("black"),
        $._("brown"),
        $._("silver"),
        $._("gold"),
        $._("pink")
    ]);

    var schools = new IncrementalShuffler([
        // I18N: This is a generic school name
        $._("Loyola"),
        // I18N: This is a generic school name
        $._("Gardner Bullis"),
        // I18N: This is a generic school name
        $._("Almond"),
        // I18N: This is a generic school name
        $._("Covington"),
        // I18N: This is a generic school name
        $._("Springer"),
        // I18N: This is a generic school name
        $._("Santa Rita"),
        // I18N: This is a generic school name
        $._("Oak")
    ]);

    var furnitureStore = new IncrementalShuffler([
        new Plural(function(num) {
            return $.ngettext("chair", "chairs", num);
        }),
        new Plural(function(num) {
            return $.ngettext("table", "tables", num);
        }),
        new Plural(function(num) {
            return $.ngettext("bed frame", "bed frames", num);
        }),
        new Plural(function(num) {
            return $.ngettext("sofa", "sofas", num);
        }),
        new Plural(function(num) {
            return $.ngettext("couch", "couches", num);
        }),
        new Plural(function(num) {
            return $.ngettext("desk", "desks", num);
        }),
        new Plural(function(num) {
            return $.ngettext("book shelf", "book shelves", num);
        })
    ]);

    var electronicStore = new IncrementalShuffler([
        new Plural(function(num) {
            return $.ngettext("television", "televisions", num);
        }),
        new Plural(function(num) {
            return $.ngettext("computer", "computers", num);
        }),
        new Plural(function(num) {
            return $.ngettext("laptop", "laptops", num);
        }),
        new Plural(function(num) {
            return $.ngettext("camera", "cameras", num);
        })
    ]);

    var clothes = new IncrementalShuffler([
        new Plural(function(num) {
            return $.ngettext("hat", "hats", num);
        }),
        new Plural(function(num) {
            return $.ngettext("belt", "belts", num);
        }),
        new Plural(function(num) {
            return $.ngettext("necklace", "necklaces", num);
        }),
        new Plural(function(num) {
            return $.ngettext("pair of shoes", "pairs of shoes", num);
        }),
        new Plural(function(num) {
            return $.ngettext("watch", "watches", num);
        }),
        new Plural(function(num) {
            return $.ngettext("pair of socks", "pairs of socks", num);
        }),
        new Plural(function(num) {
            return $.ngettext("sweatshirt", "sweatshirts", num);
        }),
        new Plural(function(num) {
            return $.ngettext("sweater", "sweaters", num);
        }),
        new Plural(function(num) {
            return $.ngettext("tie", "ties", num);
        }),
        new Plural(function(num) {
            return $.ngettext("scarf", "scarves", num);
        }),
        new Plural(function(num) {
            return $.ngettext("pair of shorts", "pairs of shorts", num);
        }),
        new Plural(function(num) {
            return $.ngettext("pair of jeans", "pairs of jeans", num);
        }),
        new Plural(function(num) {
            return $.ngettext("pair of gloves", "pairs of gloves", num);
        }),
        new Plural(function(num) {
            return $.ngettext("shirt", "shirts", num);
        }),
        new Plural(function(num) {
            return $.ngettext("pair of suspenders", "pairs of suspenders", num);
        }),
        new Plural(function(num) {
            return $.ngettext("jacket", "jackets", num);
        }),
        new Plural(function(num) {
            return $.ngettext("pair of glasses", "pairs of glasses", num);
        }),
        new Plural(function(num) {
            return $.ngettext("pair of boots", "pairs of boots", num);
        }),
        new Plural(function(num) {
            return $.ngettext("backpack", "backpacks", num);
        })
    ]);

    var sides = new IncrementalShuffler([
        "left",
        "right"
    ]);

    var shirtStyles = new IncrementalShuffler([
        "long-sleeved",
        "short-sleeved"
    ]);

    // animal, avg-lifespan, stddev-lifespan
    // (data is from cursory google searches and wild guessing)
    // NOTE(jeresig): I18N: These strings are expected to work prefixed with
    // just the letter "A", as in "A gorilla"
    var animals = new IncrementalShuffler([
        // NOTE(jeresig): I18N: Removed because it begins with a vowel and is
        // used with an()
        //["alligator", 68, 20],
        //["anteater", 15, 10],
        [new Plural(function(num) {
            return $.ngettext("bear", "bears", num);
        }), 40, 20],
        //["elephant", 60, 10],
        [new Plural(function(num) {
            return $.ngettext("gorilla", "gorillas", num);
        }), 20, 5],
        [new Plural(function(num) {
            return $.ngettext("lion", "lions", num);
        }), 12, 5],
        [new Plural(function(num) {
            return $.ngettext("lizard", "lizards", num);
        }), 3, 1],
        [new Plural(function(num) {
            return $.ngettext("meerkat", "meerkats", num);
        }), 13, 5],
        [new Plural(function(num) {
            return $.ngettext("porcupine", "porcupines", num);
        }), 20, 5],
        [new Plural(function(num) {
            return $.ngettext("seal", "seals", num);
        }), 15, 10],
        [new Plural(function(num) {
            return $.ngettext("sloth", "sloths", num);
        }), 16, 5],
        [new Plural(function(num) {
            return $.ngettext("snake", "snakes", num);
        }), 25, 10],
        [new Plural(function(num) {
            return $.ngettext("tiger", "tigers", num);
        }), 22, 5],
        [new Plural(function(num) {
            return $.ngettext("turtle", "turtles", num);
        }), 100, 20],
        [new Plural(function(num) {
            return $.ngettext("zebra", "zebras", num);
        }), 25, 10]
    ]);

    // TODO(emily): I18N: add both "row of CROP" as well as just "CROP" for
    // pluralization. For example, in Polish, adding "row of" to "tomatoes"
    // changes the pluralization of "tomatoes".
    var farmers = new IncrementalShuffler([
        {
            farmer: new Plural(function(num) {
                return $.ngettext("farmer", "farmers", num);
            }),
            crops: new IncrementalShuffler([
                new Plural(function(num) {
                    return $.ngettext("tomato", "tomatoes", num);
                }),
                new Plural(function(num) {
                    return $.ngettext("potato", "potatoes", num);
                }),
                new Plural(function(num) {
                    return $.ngettext("carrot", "carrots", num);
                }),
                new Plural(function(num) {
                    return $.ngettext("bean", "beans", num);
                }),
                new Plural(function(num) {
                    return $.ngettext("corn stalk", "corn stalks", num);
                })
            ]),
            field: new Plural(function(num) {
                return $.ngettext("field", "fields", num);
            })
        },
        {
            farmer: new Plural(function(num) {
                return $.ngettext("gardener", "gardeners", num);
            }),
            crops: new IncrementalShuffler([
                new Plural(function(num) {
                    return $.ngettext("rose", "roses", num);
                }),
                new Plural(function(num) {
                    return $.ngettext("tulip", "tulips", num);
                }),
                new Plural(function(num) {
                    return $.ngettext("daisy", "daisies", num);
                }),
                new Plural(function(num) {
                    return $.ngettext("iris", "irises", num);
                }),
                new Plural(function(num) {
                    return $.ngettext("lily", "lilies", num);
                })
            ]),
            field: new Plural(function(num) {
                return $.ngettext("garden", "gardens", num);
            })
        }
    ]);

    var distances = new IncrementalShuffler([
        new Plural(function(num) {
            return $.ngettext("mile", "miles", num);
        }),
        new Plural(function(num) {
            return $.ngettext("kilometer", "kilometers", num);
        })
    ]);

    // TODO(jeresig): I18N: Kill this.
    var indefiniteArticle = function(word) {
        var vowels = ["a", "e", "i", "o", "u"];
        if (_(vowels).indexOf(word[0].toLowerCase()) > -1) {
            return "An " + word;
        }
        return "A " + word;
    };

    $.extend(KhanUtil, {
        person: function(i) {
            return people.get(i - 1).get(0)[0];
        },

        personVar: function(i) {
            return people.get(i - 1).get(0)[0].charAt(0).toLowerCase();
        },

        // TODO(jeresig): I18N: Kill this.
        he: function(i) {
            return people.get(i - 1).get(0)[1] === "m" ? "he" : "she";
        },

        // TODO(jeresig): I18N: Kill this.
        him: function(i) {
            return people.get(i - 1).get(0)[1] === "m" ? "him" : "her";
        },

        isMale: function(i) {
            return people.get(i - 1).get(0)[1] === "m";
        },

        // TODO(jeresig): I18N: Kill this.
        an: function(word) {
            return indefiniteArticle(word).toLowerCase();
        },

        vehicle: function(i) {
            return vehicles.get(i - 1);
        },

        vehicleVar: function(i) {
            return vehicles.get(i - 1).charAt(0);
        },

        course: function(i) {
            return courses.get(i - 1);
        },

        courseVar: function(i) {
            return courses.get(i - 1).charAt(0).toLowerCase();
        },

        exam: function(i) {
            return exams.get(i - 1);
        },

        binop: function(i) {
            return binops.get(i - 1);
        },

        item: function(i) {
            return collections.get(i - 1)[0];
        },

        group: function(i) {
            return collections.get(i - 1)[1];
        },

        store: function(i) {
            return stores.get(i).name;
        },

        storeItem: function(i, j) {
            return stores.get(i).items.get(j);
        },

        pizza: function(i) {
            return pizzas.get(i);
        },

        exercise: function(i) {
            return exercises.get(i - 1);
        },

        timeofday: function(i) {
            return timesofday.get(i - 1);
        },

        school: function(i) {
            return schools.get(i - 1);
        },

        clothing: function(i) {
            return clothes.get(i - 1);
        },

        color: function(i) {
            return colors.get(i - 1);
        },

        fruit: function(i) {
            return fruits.get(i);
        },

        deskItem: function(i) {
            return deskItems.get(i);
        },

        distance: function(i) {
            return distances.get(i - 1);
        },

        farmer: function(i) {
            return farmers.get(i - 1).farmer;
        },

        crop: function(i) {
            return farmers.get(i - 1).crops.get(0);
        },

        field: function(i) {
            return farmers.get(i - 1).field;
        },

        side: function(i) {
            return sides.get(i - 1);
        },

        shirtStyle: function(i) {
            return shirtStyles.get(i - 1);
        },

        furniture: function(i) {
            return furnitureStore.get(i - 1);
        },

        electronic: function(i) {
            return electronicStore.get(i - 1);
        },

        animal: function(i) {
            return animals.get(i - 1)[0];
        },

        animalAvgLifespan: function(i) {
            return animals.get(i - 1)[1];
        },

        animalStddevLifespan: function(i) {
            return animals.get(i - 1)[2];
        }
    });
};

});

// For legacy reasons, Perseus assumes that some modules (such as knumber) are
// executed immediately when the exercise content bundle is loaded, so we load
// them all here.

require("./khan-exercise.js");

require("./utils/answer-types.js");
require("./utils/graphie.js");
require("./utils/interactive.js");
require("./utils/kline.js");
require("./utils/knumber.js");
require("./utils/kpoint.js");
require("./utils/kray.js");
require("./utils/kvector.js");
require("./utils/math.js");

define("main.js", function(){});

}());